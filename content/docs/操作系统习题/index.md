---
title: "操作系统习题"
date: 2022-01-07
draft: false
tags: ["操作系统"]
---

## 第一章 习题

## 1. 判断以下命题是否正确，并说明理由。 

1. 设计操作系统的主要目标是什么？ 

   > 1. 方便性：使计算机更易于用户使用。
   > 2. 有效性：以有效的方式管理计算机系统的资源，合理地组织计算机的工作流程， 以防止对计算机资源的不当或错误使用。这是操作系统可用的关键因素。
   > 3. 可扩展性：为用户的的开发搭建一个平台，允许修改、并引进新的功能。 操作系统为计算机上所有软件的性能提高提供了平台，另外，操作系统提供了一系列功能用以支持用户程序的运行。

2. 操作系统的基本功能是什么? 

   > 1. 操作系统是用户和计算机硬件之间的接口。
   > 2. 操作系统是计算机系统资源的管理者。
   > 3. 操作系统用作扩充机器，使得裸机功能更强、更方便使用。

3. 多道批处理系统形成和发展的主要动力是什么？ 

   > 计算机体系的不断发展，需要不断提高计算机资源的利用率和系统吞吐量的需要。

4. 推动分时操作系统形成和发展的主要动力是什么？ 

   > 为了满足用户对人机交互的需求，出现了分时系统。

5. 操作系统的结构大致可分为哪几类？UNIX 的结构有什么特点？

   > 三类：整体、分层、微内核
   >
   > UNIX是分层结构
   >
   > - 优点
   >   - 增加了系统的可读性和可适应性，简化了系统的设计和实现。
   >   - **易于调试、修改、扩充、维护和保证正确性**。
   > - 缺点
   >   - **操作系统的效率不高**。
   >   - **层的定义较为困难**。

##  第二章 习题

## 1. 判断以下命题是否正确，并说明理由。 

1.  多道程序设计的目的是为了提高程序员编制程序的效率。 

   > 错。多道程序是为了充分发挥CPU和计算机系统部件并进行工作的能力，从而提高CPU的利用率。

2.  采用多道程序设计，能充分发挥处理机的使用效率，缩短每个进程的周转时间。 

   > 错。周转时间是指从作业提交到作业完成之间的时间间隔，有一些短进程可能由于进程调度方式，导致其等待时间增加，相比于单独处理它，短进程的周转时间增加了。
   >
   > 因此只能说是缩短平均周转时间，而不是每个进程的周转时间。

3.  操作系统的设计必须要保证进程具有可再现性。 

   > 错。可再现性是指：程序只要初始条件相同，运行结果一定相同，即运行结果与执行速度无关。单道程序的顺序执行必须保证可再现性，但是在多道程序并发执行的条件下，可再现性无法保证，取而代之的是不确定性，也许程序的运行结果相同，但是执行速度是不确定的。

4.  进程控制块是进程存在的唯一标识。 

   > 对。PCB提供了几乎所有管理进程的所需信息，标识了进程的存亡。

5. 只有在某些条件成立时才可能发生进程调度。 

   > 对。进程调度是指进程由活跃就绪态转换为运行态的过程。在等待的事件得到满足或者处于静止就绪态并且内存空闲已经有大片空闲时，会由其他状态转为活跃就绪态，进而发生进程调度，获得处理机，进入运行态。

6. 中级调度即从就绪队列中选择一个进程，分配处理机使其运行。

   > 错。中级调度负责静止态和活跃态的转换，分配处理机是进程调度（低级调度）所需要负责的事



## 2. 单项选择题

1. 在单处理机的多进程系统中，进程什么时候占用处理机和能占用多长时间取决于（ ）。 

   A、进程相应的程序段的长度 B、进程总共需要运行时间多少 

   **C、进程自身和进程调度策略** D、进程完成什么功能 

2.  进程自身决定（ ）。 

   **A、从执行状态到阻塞状态** B、从执行状态到就绪状态 

   C、从就绪状态到执行状态 D、从阻塞状态到就绪状态 

3.  下列选项中，导致创建新进程的操作是：（ ）。

    1、用户登录成功

    2、设备分配 

    3、启动程序执行

    A、仅 1 和 2 	B、仅 2 和 3

    **C、仅 1 和 3** 	D、1、2、3 

4.  在支持多线程的系统中，进程 P 创建的若干个线程不能共享的是（ ）。 

   A、进程 P 的代码段	 B、进程 P 中打开的文件 

   C、进程 P 的全局变量	 **D、进程 P 中某线程的栈指针** 

5.  下列选项中，降低进程优先权级的合理时机是（ ）。 

   **A、进程的时间片用完** B、进程刚完成 I/O，进入就绪队列 

   C、进程长期处于就绪队列 D、进程从就绪态转为执行态 

6. 设有 3 个作业 J1、J2、J3，其运行时间分别是 2、5、3 小时，假定它们同时到达，并 在同一台处理器上以单道方式运行，则平均周转时间最小的执行序列是（ ）。

    A、J1、J2、J3 	B、J3、J2、J1	 C、J2、J1、J3 	**D、J1、J3、J2**

## 3. 填空题

1. 建立多进程的主要目的是提高 <u>CPU</u> 的利用率。 
2. 在多进程多线程系统中，资源分给 <u>进程</u>，CPU 按 <u>线程</u> 调度。 
3. UNIX 进程控制块由 <u>proc</u> 和 <u>user</u> 构成。 
4. UNIX 进程的上下文由 <u>用户级</u> 、 <u>寄存器</u> 和 <u>系统级</u> 三个层次的内容构成。 
5. UNIX 进程可在 <u>用户态</u> 态和 <u>核心态</u> 态下执行。至于具体处于何种态是由 <u>PCB</u> 中相应位决定的。 
6. 决定 UNIX 进程状态的 proc 数据项有：<u>p_stat</u> 、<u>p_flag</u> 和 <u>p_pri</u> 。

## 4. 什么是多道程序设计，其主要优点是什么？

> 多道程序设计：指允许让多个计算问题同时装入一个计算机系统的主存储器，并允许它们共享资源、并发执行的程序设计技术。
>
> 优点：
>
> 1. 并发：提高CPU和外围设备、外围设备和外围设备间的并行工作能力
> 2. 资源共享：提高CPU及其他各种资源的利用率。

## 5. 程序并发执行时失去程序的封闭性的主要原因是什么？

> 并发执行的程序不再是独占资源，而是资源共享，而这些资源的状态受多个程序影响，进而程序间产生了某种联系，因此失去了封闭性，同时也失去了可再现性

## 6. 何为进程？系统为了控制进程的运行，都要保护什么？

> 进程是一个程序在某个数据集上的一次执行；
>
> 保护进程的PCB（PCB的内容）
>
> ![image-20220427200753099](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/202204272007556.png)

## 7. 比较作业和进程的异同。

> 作业与进程之间的区别
>
> 1. 本质
>
>    > 作业就是**用户要求**计算机完成的一项任务；
>    >
>    > 进程是**系统**为了完成作业而设置的**动态执行体**。
>
> 2. 资源
>
>    > 作业中的作业说明书事先说好了资源的分配关系，这是静态的；
>    >
>    > 进程是操作系统分配资源的基本单位，这是动态的。
>
> 3. 作业和进程的对应关系
>
>    > 一个进程对应一个作业
>    >
>    > 一个作业需要多个进程

## 8. 比较进程和程序的异同。

> 1. 考虑动态性
>
> > 进程是程序的一次执行过程，进程是一个动态概念；
> >
> > 而程序是完成某个特定功能的指令的有序序列，即程序是一个静态概念。
> >
> > **程序是代码的集合，而进程是程序的执行。** 
> >
> > 程序可以作为一种软件资源长期保存，可以被复制，可以在不同的计算机上运行；
> >
> > 而进程，是有生命周期的，它动态地被创建，并被调度执行后消亡。
>
> 2. 考虑并发性
>
> > 进程具有并发特征，而程序没有。由于一个进程可以与其他进程并发执行，即进程具有并发性；而程序并不反映执行过程，所以不具有并发特征。 
>
> 3. 考虑资源
>
> > 进程是系统进行资源分配和调度的一个独立单位，即资源分配是以进程为单位的，而不是以程序为单位的。 
>
> 4. 考虑结构
>
> > 程序的组成是代码，而进程实体的组成包括：程序、数据和 PCB。 
>
> 5. 考虑生成性
>
> > 进程可以生成其他进程，而程序则无法生成新的程序。 
>
> 6. 考虑对应关系
>
> > 一个程序多次执行可以对应多个进程；通过调用关系，一个进程也可以包括多个程序。
>

## 9. 在创建和撤销一个进程时所要完成的主要工作是什么？

- 在创建和撤销一个进程时所要完成的主要工作是什么？

  > - 进程创建：
  >   1. 申请空闲PCB
  >   2. 分配资源
  >   3. 初始化PCB的信息
  >   4. 将新进程插入就绪队列
  > - 撤销进程：
  >   1. 修改该进程的状态，设置重新调度标志
  >   2. 检测子孙进程，递归终止
  >   3. 递归归还资源
  >   4. 递归释放PCB
  >   5. 若重新调度标志位真，调用进程调度程序，重新分配处理机

- 当进程 A 由于所分配的时间片到，由执行状态转入就绪状态；而进程 B 被调度程序选中由就绪状态转为执行状态时，系统所要做的主要工作是什么？

  > 将A的状态改为就绪态，并剥夺其CPU，将其放入就绪队列；
  >
  > 将B的状态改为执行态，将其移出就绪队列，并分配CPU。

## 11. 处理机调度分为几级？每一级调度的主要任务是什么？

> 四级
>
> 1. 作业（高级）调度
>
>    按一定的原则，从输入井中选择一个作业（或一批作业），将其 调入内存、分配必要的资源，并为其建立相应的进程，以使该（批）作业具有竞争 CPU 的 资格；当然，作业执行完毕时，作业调度还需负责回收系统资源。
>
> 2. 交换（中程）调度
>
>    按照一定的原则，将处于外存对换区中具备运行条件的就绪进程调入内存；或者，将处于内存中阻塞状态或者就绪状态的进程换出到外存交换区。
>
> 3. 进程（低级）调度
>
>    是按照一定的策略，选取一个处于活跃就绪状态的进 程占用 CPU 并进行进程的上下文切换。
>
> 4. 线程调度
>
>    对于内核级线程调度，其实质与调度的策略都与进程调度十分类似，因此也有人并不对进程调度与内核级线程调度进行区分，而把内核级线程调度也称为短程调度或低级调度。
>
>    

## 13. 列出 3 个引起进程阻塞和唤醒的事件，并写出唤醒原语的执行步骤。

> (1) 向系统请求共享资源失败。 (2) 等待某种操作的完成。 (3) 新数据尚未到达。 (4) 等待新任务的到达。
>
> 操作步骤
>
> > 1. 找出标识
> >
> > 2. 从阻塞队列移出
> >
> > 3. 设置为就绪态
> >
> > 4. 插入就绪队列
> >
> > 5. 考虑被唤醒进程和当前运行进程的优先级
> >
> >    > 若被唤醒进程优先级更高则需要设置调度标志，并转进程调度程序。

## 19. 若系统中运行的主要是这 2 类进程，采用什么调度算法更有利于资源的利用率？为什么？

将“I/O 为主”的进程定义为：当此类进程单独运行时，用于 I/O 处理的时间远远多于 处理机的处理时间。将“计算为主”的进程定义为：当此类进程单独运行时，处理机的处理时间远远多于处理的时间。若系统中运行的主要是这 2 类进程，采用什么调度算法更有利于资源的利用率？为什么？

> 以IO为主的进程可以理解为短进程，因为每次IO处理完之后都会重新排队
>
> 以计算为主的进程可以理解为长进程。
>
> 多级反馈队列可以有效兼顾长短进程

## 20. 采用“抢先方式的最高优先级”调度算法，回答以下问题：

某多道程序设计系统中配有一台处理器 CPU 和两台输入输出设备 I/O1 和 I/O2，现有优先级由高到低的三个进程 P1、P2、P3 同时存在，它们使用资源的先后次序和占用时间分别是： 进程 P1：I/O2（30ms），CPU（10ms），I/O1（30ms），CPU（10ms），I/O2（10ms）； 进程 P2：I/O1（20ms），CPU（20ms），I/O2（40ms）； 进程 P3：CPU（30ms），I/O1（20ms）。 若进程调度采用“**抢先方式的最高优先级**”调度算法，且忽略调度等所需要的时间， 回答以下问题： 

1. 进程 P1、P2、P3 从开始到完成所用的时间分别是多少？（用坐标画出进程 P1、 P2、P3 工作过程，其中横坐标表示时间，纵坐标表示 CPU 和 I/O 设备。） 

2. 三个进程从开始到全部结束完成时 CPU 的利用率是多少？I/O 利用率是多少？

   > ![img](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/202204272359353.png)

## 22. 采用最短周期优先调度算法，回答以下问题

假定有一组作业（或进程），它们提交时间及要求运行的时间如下表所示（单位为小时， 并以十进制计）

![image-20220427194312013](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/202204271943079.png)

如果采用最短周期优先调度算法，计算出该组作业的平均周转时间 T=1.725 小时和平均带权周转时间 W=6.875 小时。对吗？为什么？

> | 作业号 | 提交时间 | 运行时间 | 等待时间 | 完成时间 | 周转时间 | 代权周转时间 |
> | ------ | -------- | -------- | -------- | -------- | -------- | ------------ |
> | 1      | 8:00     | 2        | 0        | 10:00    | 2        | 1            |
> | 3      | 9:00     | 0.1      | 1        | 10:06    | 1.1      | 11           |
> | 4      | 9:50     | 0.2      | 16/60    | 10:18    | 28/60    | 2.33         |
> | 2      | 8:50     | 0.5      | 88/60    | 10:48    | 108/60   | 3.6          |
> | 平均值 |          |          |          |          | 0.775    | 4.4825       |

## 23. 求在采用如下算法时进程的平均周转时间和平均带权周转时间。

下表列出了五个进程的执行时间和优先数，规定优先数越小优先级越大，在某时刻这五个进程按照 P0、P1、P2、P3、P4 的顺序同时到达，求在采用如下算法时进程的平均周转时间和平均带权周转时间。（调度方式为非抢先方式，且忽略进程调度所花时间。）

![image-20220427194438076](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/202204271944151.png)

1. 先来先服务调度算法；

   | 先来先服务 |          |          |          |          |          |              |
   | ---------- | -------- | -------- | -------- | -------- | -------- | ------------ |
   | 进程名     | 提交时间 | 运行时间 | 等待时间 | 完成时间 | 周转时间 | 代权周转时间 |
   | P0         | 0        | 20       | 0        | 20       | 20       | 1            |
   | P1         | 0        | 15       | 20       | 35       | 35       | 2.333333333  |
   | P2         | 0        | 35       | 35       | 70       | 70       | 2            |
   | P3         | 0        | 25       | 70       | 95       | 95       | 3.8          |
   | P4         | 0        | 40       | 95       | 135      | 135      | 3.375        |
   |            |          |          |          |          |          |              |
   | 平均值     |          |          |          |          | 71       | 2.501666667  |

2. 最短周期优先调度算法；

   | 最短周期优先 |          |          |          |          |          |              |
   | ------------ | -------- | -------- | -------- | -------- | -------- | ------------ |
   | 进程名       | 提交时间 | 运行时间 | 等待时间 | 完成时间 | 周转时间 | 代权周转时间 |
   | P0           | 0        | 20       | 0        | 20       | 20       | 1            |
   | P1           | 0        | 15       | 20       | 35       | 35       | 2.333333333  |
   | P3           | 0        | 25       | 35       | 60       | 60       | 2.4          |
   | P2           | 0        | 35       | 60       | 95       | 95       | 2.714285714  |
   | P4           | 0        | 40       | 95       | 135      | 135      | 3.375        |
   |              |          |          |          |          |          |              |
   | 平均值       |          |          |          |          | 69       | 2.36452381   |

3. 时间片轮转调度算法（时间片为 5ms）；

   | 时间片轮转 |          |          |          |          |          |              |
   | ---------- | -------- | -------- | -------- | -------- | -------- | ------------ |
   | 进程名     | 提交时间 | 运行时间 | 等待时间 | 完成时间 | 周转时间 | 代权周转时间 |
   | P0         | 0        | 20       | 80       | 105      | 105      | 1            |
   | P1         | 0        | 15       | 40       |          | 35       | 2.333333333  |
   | P2         | 0        | 35       | 35       | 70       | 70       | 2            |
   | P3         | 0        | 25       | 70       | 95       | 95       | 3.8          |
   | P4         | 0        | 40       | 95       | 135      | 135      | 3.375        |
   |            |          |          |          |          |          |              |
   | 平均值     |          |          |          |          | 71       | 2.501666667  |

4. 最高优先级优先调度算法。

   | 优先级优先 |          |          |          |          |          |              |
   | ---------- | -------- | -------- | -------- | -------- | -------- | ------------ |
   | 进程名     | 提交时间 | 运行时间 | 等待时间 | 完成时间 | 周转时间 | 代权周转时间 |
   | P1         | 0        | 15       | 0        | 15       | 15       | 1            |
   | P3         | 0        | 25       | 15       | 40       | 40       | 1.6          |
   | P0         | 0        | 20       | 40       | 60       | 60       | 3            |
   | P2         | 0        | 35       | 60       | 95       | 95       | 2.714285714  |
   | P4         | 0        | 40       | 95       | 135      | 135      | 3.375        |
   |            |          |          |          |          |          |              |
   | 平均值     |          |          |          |          | 69       | 2.337857143  |

## 24. 计算平均周转时间

下表给出作业 1、2、3、4 的到达时间和运行时间。请分别给出采用非抢先方式最短周期优先调度算法和先来先服务调度算法时作业调度次序，并计算平均周转时间。（时间单位： 小时，以十进制进行计算）

![image-20220427194523549](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/202204271945663.png)

| 最短周期优先 |          |          |          |          |          |              |
| ------------ | -------- | -------- | -------- | -------- | -------- | ------------ |
| 作业号       | 提交时间 | 运行时间 | 等待时间 | 完成时间 | 周转时间 | 代权周转时间 |
| 1            | 2:00     | 2        | 0        | 4:00     | 2        | 1            |
| 3            | 3:00     | 0.1      | 1        | 4:06     | 1.1      | 11           |
| 4            | 3:30     | 0.2      | 0.6      | 4:18     | 0.8      | 4            |
| 2            | 2:30     | 0.5      | 1.8      | 4:48     | 2.3      | 4.6          |
|              |          |          |          |          |          |              |
| 平均值       |          |          |          |          | 1.55     | 5.15         |



| 先来先服务 |          |          |          |          |          |              |
| ---------- | -------- | -------- | -------- | -------- | -------- | ------------ |
| 作业号     | 提交时间 | 运行时间 | 等待时间 | 完成时间 | 周转时间 | 代权周转时间 |
| 1          | 2:00     | 2.0      | 0        | 4:00     | 2        | 1            |
| 2          | 2:30     | 0.5      | 2        | 6:30     | 4        | 8            |
| 3          | 3:00     | 0.1      | 3.5      | 6:36     | 3.6      | 36           |
| 4          | 3:30     | 0.2      | 3.1      | 6:48     | 3.3      | 16.5         |
|            |          |          |          |          |          |              |
| 平均值     |          |          |          |          | 3.225    | 15.375       |

## 第三章习题

## 1. 判断以下命题是否正确，并说明理由。

1. 如果 CPU 正在执行一个 Down 操作的时候，一个最高级中断到来，那么中断处理进程会抢夺 CPU。 

   > 错。Down是原语操作，不可中断。

2. 临界区是进程执行程序中对临界资源访问的那一段程序代码。

   > 对。临界区就是在进程中访问临界资源的那一段程序。

3.  仅当一个进程退出临界区之后，另一个进程才能进入相应的临界区。

   > 对。临界区是用于访问临界资源的，临界资源必须是互斥访问的。

4.  进程 A 与进程 B 共享变量 S1，需要互斥；进程 B 与进程 C 共享变量 S2，需要互斥。 从而，进程 A 与进程 C 也必须互斥。 

   > 错。互斥没有传递性，进程A与进程C并不共享变量。

5. 系统处于不安全状态必然导致系统死锁。

   > 错。死锁一定处于不安全状态，但系统处于不安全状态不一定导致系统死锁。

6.  一个系统的状态如果不是死锁状态那么就一定是安全状态。

   > 错。不是死锁状态不代表现在不是不安全状态。
   >
   > 死锁一定处于不安全状态，但系统处于不安全状态不一定导致系统死锁。



## 2. 单项选择题。

1. 在操作系统中，Down、Up 操作是一种（ ）。

    A、机器指令 B、系统调用命令 C、作业控制命令 **D、低级进程通信原语** 

   > 进程通信类型包括低级通信和高级通信。
   > 进程通信指进程之间的信息交换，进程同步所交换的信息量少，称为低级通信。
   >
   > 高级进程通信是指用户可直接利用操作系统所提供的一组通信命令，高效传送大量数据的一种通信方式。

2. 下列选项中，在用户态执行的是（ ）。 

   **A、命令解释程序** B、缺页处理程序 C、进程调度程序 D 时钟中断处理程序 

   > 缺页处理程序和时钟中断都属于中断，在核心态执行。
   >
   > 进程调度属于系统调用，在核心态执行。
   >
   > 命令解释程序属于命令接口，在用户态执行。

3. 设与某资源相关联的信号量初值为 3，当前值为 1，若 M 表示该资源的可用个数，N 表示等待该资源的进程数，则 M，N 分别是（ ）。 

   A、0，1	 **B、1，0** 	C、1，2 	D、2，0 

   > 信号量表示相关资源的当前可用数量

4. 某计算机系统中有 8 台打印机，有 K 个进程竞争使用，每个进程最多需要 3 台打印 机，该系统可能会发生死锁的 K 的最小值是（ ）。

    A、2 	B、3 	**C、4** 	D、5
    
    > 每个进程3台，不会产生死锁；对于三个进程，可以有两个进程分别获得3台，使其执行完释放后让第三个进程获得3台，所以也不会产生死锁；对于四个进程，假若每个进程各获得2台而同时需要另外一台，产生了死锁，所以产生死锁的最小值是4。
    >
    > 
    >
    > 类似题型(1)：假设现在有P个进程，每个进程最多需要m个资源，并且有r个资源可用。什么样的条件可以保证死锁不会发生 解：如果一个进程有m个资源它就能够结束，不会使自己陷入死锁中。因此最差情况是每个进程有m-1个资源并且需要另外一个资源。如果留下有一个资源可用，那么其中某个进程就能够结束并释放它的所有资源．使其它进程也能够结束。所以避免死锁的条件是： r≥p(m-1)+1。 由此条件解上题：r=8，m=3，带入公式得：2p≤7。即当P小于等于3时才可保证死锁不会发生，所以可能会产生死锁的最小值是4。 
    >
    > 类似题型(2)：某系统中有3个并发进程，都需要同类资源4个，试问该系统不会发生死锁的最少资源数是多少 解：带入上述条件公式：r≥3*(4-1)+1=10。所以答案为10个。

## 3. 填空题

1. 设系统有 10 个并发进程通过 Down、Up 操作原语共享同一临界资源，若该临界资源
   互斥信号量为 Mutex，初值设置为 1，则 Mutex 的值域为<u>（-9,1）</u>。

   > 有m 个进程共享同一临界资源，若使用信号量机制实现对一临界资源的互斥访问，则信号量的变化范围是(A )。
   > A.1 至–(m-1) B.1 至m-1 C.1 至–m D.1 至m

2.  引起进程相互制约的 2 类原因是：<u>直接制约</u> 和 <u>间接制约</u>。

   > ![image-20220420130940896](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/202204201309971.png)
   >
   > 解决临界区问题的一个必要条件是各个进程对于临界资源必须互斥使用，这些只由对临界资源的争用而引起的进程间的关系，构成了进程间的间接制约关系；（进程异步）
   >
   > 相对应地，由于必须互相合作而呈现的直接的协同关系，则构成了进程间的直接制约关系。（进程同步）

3. 为实现消息缓冲通信，在 PCB 中应增加 <u>mq、mutex 和 sm</u> 三个数据项。

   > ![image-20220420131415826](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/202204201314885.png)

4. 进程通信有直接通信方式和间接通信方式，邮箱机制是一种 <u>间接通信方式</u>。

   > 邮箱机制是消息传递系统的一种，而且是一种间接通信方式。

5.  当且仅当 S 状态的资源分配图是 <u>不可化简的</u>，S 为死锁状态。

6. 对待死锁，一般应考虑死锁的预防、避免、检测和清除四个问题。典型的银行家算法
   是属于<u>避免</u> ，破坏循环等待条件是属于 <u>预防</u>，而抢占资源是 <u>清除</u> 的基本方法。



## 4. 什么是 Bernstein 条件？若并发执行的程序不满足 Bernstein 条件可能会失去哪些性质？

Bernstein 条件是进程的执行与时间无关的一个充分条件，而非必要条件。

Bernstein 条件指出：如果并发执行的各程序段中语句或指令满足 Bernstein 条件，那么并发执行不会对执行结果的封闭性和可再现性产生影响。

如果不满足，则程序失去封闭性和可再现性

## 5. 什么是信号量？什么是信号量的 Down、Up 操作？如何利用信号量这两个操作来实施进程间的通信？

信号量就是一种特殊的整型变量，该整型变量一般被用于描述资源的个数，因此一个信号量通常被初始化为一个非负整数。

Down、Up 操作是低级进程通信原语，对信号量执行减和加的操作，对应于资源的分配和释放。

每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程1把数据从用户空间拷到内核缓冲区,进程2再从内核缓冲区把数据读走,内核提供的这种机制称为**进程间通信**机制。

信号量用来管理临界资源的。它本身只是一种外部资源的标识，不具有数据交换功能，而是通过控制其他的通信资源实现进程间通信。 

就是两个进程共享信号量s，一旦其中一个进程执行了P(s)操作，它将得到信号量，并可以进入临界区，使s减1。而第二个进程将被阻止进入临界区，因为当它试图执行P(s)时，s为0，它会被挂起以等待第一个进程离开临界区域并执行V(s)释放信号量，这时第二个进程就被唤醒恢复执行了。

## 6. 举例说明若 Down、Up 操作不实现为原语，就不能实现对临界区的互斥。

如果进程P1在执行Down(s)时被中断，P2上处理机，那么P2就会让s=0，并顺利进入临界区，在P2访问临界区还没结束时，P1又上处理机，而此时P1将会继续执行Down操作，然后也顺利进入临界区，此时的临界区就有两个进程在同时运行，因此若 Down、Up 操作不实现为原语，就不能实现对临界区的互斥。

## 8. 说明同步、互斥的区别与联系。

区别：

- 相互互斥的进程在逻辑上是无关的，不具有时间次序的特征，他们是因为对临界资源的争用而产生了间接制约的关系，而互斥便是解决进程间间接制约的手段；

- 相互同步的进程，具有时间次序的特征，是相互合作而呈现的直接制约关系，同步便是解决进程间直接制约的手段

联系：

- 互斥是一种特殊的同步。因为同步的进程在执行时间上必须基于某个条件按一定的顺序协调进行，互斥的进程也必须基于某个条件（即对共享资源的互斥访问）按一定的顺序协调进行，只不过是互斥的进程的这种顺序不是固定的，而是可以任意的（只要满足互斥）。

## 10. 请解释操作系统中“管道”和“管程”这两个名词。

管道，是指能够连接一个写进程和一个读进程、专门用于进程之间的数据通信的**共享文件**。

管程，是关于共享资源的数据结构及一组针对该资源的操作过程所构成的**软件模块**。

## 12. 请用Down、Up 操作作为同步机制描述对应于计算进程和打印进程的程序。

设有 N 个计算进程和 M 个打印进程共享同一个缓冲区，缓冲区的长度为 8。各计算进程不断地把计算得到的结果送入缓冲区，各打印进程不断地从缓冲区取数并打印。要求，既不漏打，也不重复打印任何一个结果，并且，**为了提高工作效率，计算进程在使用缓冲区的同时，运行打印进程从缓冲区中取数**，反之亦然。请用Down、Up 操作作为同步机制描述对应于计算进程和打印进程的程序。

```c
int empty = 8;
int full = 0;
computer(){
	while(1){
        prepare a num;//生产数据
        P(empty);//申请空闲缓存空间
        add num to buffer;//将数据放入缓冲区
        V(full);//满缓冲区加一
    }
}
print(){
    while(1){
        P(full);
        remove a num from buffer;
        V(empty);
        print a num;
    }
}
```



## 20. 死锁产生的四个必要条件是什么？用于保证系统不会产生死锁的方法有哪些？

1. 互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有，此时若有其他进程请求该资源，则请求进程只能等待
2. 请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求时，该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放
3. 不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)
4. 循环等待条件: 若干进程间形成首尾相接循环等待资源的关系



- 死锁检测与死锁恢复
- 死锁预防，破坏4个必要条件
- 死锁避免，银行家算法



## 21. 简述“死锁”与“饿死”。

二者都是由于资源的争夺和资源的分配策略而引起的

不同点：

①从进程状态考虑，死锁进程都处于等待态（等待某一不可被剥夺资源被释放）,饿死进程可能处于忙式等待(就绪队列上等待可剥夺处理机资源)。（忙式等待：不进入等待状态的等待实际状态为”运行“或者”就绪“忙式等待空耗处理器资源因而是低效的,进程无法向前推进等待某一事件，但不主动放弃处理器而是不断循环检测资源是否可用）。

②死锁进程等待永远不会被释放的资源，饿死进程等待会被释放但却不会分配给自己的资源。

③死锁一定发生了循环等待，而饿死则不然，这也表明通过资源分配图可以检测死锁存在与否，但不能检测是否有进程饿死。

④死锁一定涉及多个进程·，而饥饿或被饿死的进程可能只有一个。



## 23. 某系统有同类资源 m 个，供 n 个进程使用；如果每个进程对资源的最大需求量为 k，

1. 为使系统不发生死锁，k 的最大值为多少？ 

   如果一个进程有k个资源它就能够结束，不会使自己陷入死锁中。因此最差情况是每个进程有k-1个资源并且需要另外一个资源。如果留下有一个资源可用，那么其中某个进程就能够结束并释放它的所有资源．使其它进程也能够结束。

   因此，总共只有m个，要分给n个进程，最差的情况是每个进程都有k-1个资源并需要另外的资源，因此m >= n(k-1) + 1，k<=(m-1)/n+1

2.  按（1）的结果，当 n=3，m 分别取值 2、3、4 时，对应的 k 值是多少，就可以使系统不发生死锁？

​		n=3,m=2	k<1/3+1	k=1

​		n=3,m=3	k<2/3+1	k=1

​		n=3,m=4	k<3/3+1	k=2



## 26. 请描述用于死锁避免的银行家算法的主要思想并列出其需要使用的数据结构，并简单分析这种算法能解决实际问题中的死锁吗？

- 主要思想:

  > 允许进程动态地申请资源，但在系统在进行资源分配之前，应先计算此次资源分配的安全性，若此次分配会导致系统进入不安全状态，则将资源分配给进程；否则，令进程等待。

- 数据结构共有七种：

  > 1. 向量 Available = ( V1, V2, …, Vm ) 用于表示系统**初始**可供使用的资源总数；
  > 2. 向量 Work = ( W1, W2, …, Wm ) 用于表示系统**当前**可供使用的资源总数，刚开始初始化为 Available 向量；
  > 3. 向量 Finish = ( F1, F2, …, Fn ) 用于表示 n 个进程被标记的情况，初始值为false，当某个进程获得所需的全部资源，并能释放全部资源时标记为ture；
  > 4. 矩阵Max[Mij]，其中矩阵中的元素 Mij表示第 i 号进程对第 j 类资源 的总需求数目；
  > 5. 矩阵Allocation[Aij]，其中矩阵中的元素 Aij 表示第 i 号进程当前分配的第 j 类资源的数目；
  > 6. 矩阵Need[Nij]其中矩阵中的元素 Nij 表示第 i 号进程还需要的第 j 类资源的数目；
  > 7. 向量Request = ( R1, R2, …, Rm ) 用于表示某个进程的某次资源请求，Ri表示该次请求的第 i 类资源的数量。

- 这种算法能解决实际问题中的死锁吗？

  > 不能。
  >
  > 因为假象条件太过理想，比如：预先知道进程需要的最大资源数。



## 28. 某系统有 4 类资源，有 5 个并发进程。各进程的最大资源请求和已分配的资源矩阵以及当前资源剩余向量如下表所示：

![image-20220421094557754](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/202204210946900.png)![image-20220421094613987](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/202204210946097.png)

![image-20220421094650817](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/202204210946923.png)

按银行家算法回答： 

1. 计算需求矩阵 Need。

   Need = Max - Allocation

   | P0   | 0    | 0    | 0    | 0    |
   | ---- | ---- | ---- | ---- | ---- |
   | P1   | 0    | 7    | 5    | 0    |
   | P2   | 1    | 0    | 0    | 2    |
   | P3   | 0    | 0    | 2    | 0    |
   | P4   | 0    | 6    | 4    | 2    |

   

2.  系统当前处于安全状态吗？

   P0可释放，回收资源 0 0 1 2，则剩余资源1,2,4,6

   | 分配给P2         | 分配给P3                                   |
   | ---------------- | ------------------------------------------ |
   | 回收资源2,3,5,6  | 0,6,5,2                                    |
   | 剩余资源3,5,9,12 | 1,8,9,8                                    |
   |                  |                                            |
   | 剩余P1，P4       | 剩余P1，P4，对比剩余资源，可满足           |
   | R2类资源剩余5    | 分配给P1                       分配给P4    |
   | 不满足P1和P4     | 回收0,7,5,0                   回收0,6,4,2  |
   | 不安全           | 剩余1,15,14,8               剩余1,14,13,10 |
   |                  | 分配给P4                      分配给P1     |

   安全序列 0,3,1,4 或者 0,3,4,1

3. 进程 P2 此时发出请求向量 Request(0, 3, 2, 0)，系统能立即满足吗？

   不能，P0释放后还剩余资源1,2,4,6，不满足P2的需求。
