---

title: 细节或技巧
date: 2021-01-03
showDate: true
tags: ["SQL","内存","操作系统","Java"]

---

## 数组越界问题

```c
int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i<=3; i++){
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}
```

疑问：这段代码的运行结果理论上是无限打印，实际上VS编译器中只打印了四次。

在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。根据我们前面讲的数组寻址公式，a[3]也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。

那么，为什么&arr[3]=&i呢？

因为，函数体内的局部变量存在栈上，而且是连续压栈。在Linux进程的内存布局中，栈区在高地址，且从高向低增长，那么实际上arr和i在内存中的状态如下表所示。

| arr[0] | arr[1] | arr[2] | i    |
| ------ | ------ | ------ | ---- |



## 什么时候使用数组而不使用ArrayList等容器

1. 需要存储基本类型
2. 对性能要求较高
3. 需要表达多维时，数组比较直观
4. 数据大小事先已知且操作简单

## 在多条件模糊查询的时候，如何确定SQL语句（实战技巧）

![image-20220410201941262](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/202204102019434.png)

如图，在这`"businessAddress like '%"+businessAddress+"%'"`句之前是否需要加and？

解决：利用永真式1=1

```java
String sql = "select * from business where 1=1 ";
        if (businessName!=null&&!businessName.equals("")){//判断字符串是否为空
            sql += "and businessName like '%"+businessName+"%'";
        }
        if (businessAddress!=null&&!businessAddress.equals("")){//判断字符串是否为空
            sql += "and businessAddress like '%"+businessAddress+"%'";
        }
```

## String和StringBuffer的选用

String的字符串对象是字符串常量池里的，如果需要频繁的连接和改动的话，会导致很多不用的字符串常量被废弃

此时，选用StringBuffer效率更高

![image-20220410202733398](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/202204102030320.png)

## SQL查询

### where写布尔表达式的注意事项

1. 找出与“Smith”居住在同一城市、同一街道的所有客户的名字。

   ```sql
   --正确
   SELECT
   	customer_name 
   FROM
   	customer 
   WHERE
   	Customer_street IN ( 
           SELECT Customer_street 
           FROM customer 
           WHERE Customer_name = 'Smith' 
       ) 
   	AND 
   	Customer_city IN ( 
           SELECT Customer_city 
           FROM customer 
           WHERE Customer_name = 'Smith' 
       );
       
   --错误 where后并列查询不可以直接用逗号表示，用and
   Select 
   	customer_name 
   from 
   	customer
   where 
   	Customer_street, Customer_city in (
       select Customer_street, Customer_city 
       from customer 
       where Customer_name=’ Smith’ 
   );
   ```

## 操作系统

1. **“访管”指令**仅在**用户态**下使用，执行“访管”指令将用户态转变为核心态。因操作系统不允许用户直接执行某些“危险性高”的指令，因此用户态运行这些指令的结果会转成操作系统的核心态去运行。这个过程就是**访管中断**。

2. 中断处理流程的前三个步骤是由硬件直接实现（隐指令）的。地址映射中需要基地址（或页表）寄存器和地址加法器的支持。而在时钟管理中，需要硬件计数器保持时钟的运行。

   > 中断处理流程：
   >
   > 1. 中断请求
   >    1. 每个中断源向CPU发出中断的时机是随机的；
   >    2. 内中断不能被屏蔽，外中断有可屏蔽和不可屏蔽之分
   >    3. 为了记录这些中断事件和区分不同的中断源，中断系统为每一个中断源设置了一个中断请求标志触发器。如果某个中断源发出了中断，就将相应的标志触发器置为1；
   >    4. 对于外中断，CPU统一在每条指令执行阶段结束前向中断控制器发出中断查询信号，去查询是否有中断请求要去处理。
   >       
   > 2. 中断判优先级
   >    1. 如果有多个中断源发出了中断请求。则需要根据中断优先级选择优先级高的中断请求先进行响应
   >    2. 中断默认优先级是由一个硬件排队器来实现的
   >    3. 但是中断屏蔽字可以动态改变中断优先级。
   > 3. 中断响应
   >    1. CPU向中断源发出中断响应信号
   >    2. 关中断
   >    3. 保存断电（PC）
   >    4. 找到中断服务的入口地址（中断向量）
   > 4. 中断服务
   >    1. 保存现场：通用寄存器和状态寄存器和屏蔽字
   >    2. 开中断
   >    3. 中断处理过程
   >    4. 关中断
   >    5. 恢复现场
   >    6. 开中断
   >    7. 中断返回
   > 5. 中断返回
   >    1. 回到断电处
   >    2. 恢复硬件
   >    3. 继续执行原程序

3. **中断程序本身可能是用户程序，但是进入中断的处理程序一定是OS程序**。若被中断的是用户程序，则系统将从目态转入管态，在管态下进行中断的处理；若被中断的是低级中断，则仍然保持在管态，而用户程序只能在目态下运行，因此进入中断处理的程序只能是OS程序。

4. 计算机通过**硬件**中断机制完成由用户态到核心态的转换，核心态到用户态的转换是由操作系统程序执行后完成的。

5. 广义指令只能在核心态执行，广义指令就是系统调用。要分清调用和执行的区别，调用可能在用户态，执行一定在核心态。

6. **特权用户**程序能够执行特权指令，这句话是**错**的，只有**操作系统**程序可以。

7. 下列选项中，不可能在用户态发生的事件是（C）。

   - ```
     系统调用
     ```

   - ```
     外部中断
     ```

   - ```
     进程切换
     ```

   - ```
     缺页
     ```

     > 1.系统调用可能在用户态和内核态发生，系统调用把应用程序的请求（用户态的请求）传入内核，由内核（内核态）处理请求并将结果返回给应用程序（用户态） 用户态->核心态 
     >
     >   2.中断的发生与CPU当前的状态无关，既可以发生在用户态，又可以发生在内核态，因为无论系统处于何种状态都需要处理外部设备发来的中断请求。 
     >
     >   3.进程切换在核心态下完成，不能发生在用户态。原因：需要调度处理器和系统资源，为保证系统安全? 
     >
     >   4.缺页（异常）也是用户态->内核态 
     >
     >   ABD（系统调用中断异常）都是用户态转向内核态，而进程切换只能发生在内核态 
     >
     >   所以选C进程切换

8. 中断处理要保存而子程序不用保存的数据是<u>PSW</u>。因为子程序调用只需保存程序断点，即该指令的下一条指令的地址：中断处理不仅要保存断点(PC的内容)，还要保存程序状态字寄存器(PSW)的内容。在中断处理中，最重要的两个寄存器是PC和PSW。

9. 整数除以0会触发异常，会使得进程从用户态转向核心态

10. 外部中断处理过程，PC值由中断隐指令自动保存，而通用寄存器内容由操作系统保存。

11. 从用户态到内核态，系统调用、中断、异常

12. **执行系统调用的过程**如下：正在运行的进程先传递系统调用参数，然后由焰入(trap)指令负责将用户态转换为内核态，并将返回地址压入堆栈以备后用，接下来CPU执行相应的内核态服务程序，最后返回用户态。

13. 当CPU检测到中断信号后会做些什么？由**硬件**自动保存被中断程序的断点(即程序计数器PC)。之后，硬件找到该中断信号对应的中断向量，**中断向量指明中断服务程序入口地址**(各中断向量统一存放在**中断向量表**中，该表**由操作系统初始化**)。接下来开始**执行中断服务程序**，包括保存PSW、保存中断屏蔽字、保存各通用寄存器的值，并提供与中断信号对应的中断服务，中断服务程序属于操作系统内核。
