---
title: "算法学习"
date: 2023-02-25
tags: ["算法", "数据结构"]
showDate: true
draft: true
---

## 树

### 基本概念

1. 结点、叶子、树的度

   - **结点的度**：结点拥有的子树的数目。

   - **叶子**：度为零的结点。

   - **树的度**：树中结点的最大的度。

2. 孩子、双亲、兄弟、子孙、祖先

3. 无序树、有序树、森林

   - **无序树**：如果树中结点的各子树之间的次序是无次序的，**可以交换位置**。
   - **有序树**：如果树中结点的各子树之间的次序是有次序的, **不可以交换位置**。
   - **森林**：0个或多个不相交的树组成。对森林加上一个根，森林即成为树；删去根，树即成为森林。

4. 层次、高度

   - **层次**：根结点的层次为1，其余结点的层次等于该结点的双亲结点的层次加1。
   - **树的深度和高度**：二叉树中节点的最大层次称为二叉树的深度或高度。

5. 满二叉树、完全二叉树和二叉排序树

   1. 满二叉树

      ![img](https://raw.githubusercontent.com/mykaneki/picgo/master/img/202304121626133.png)

   2. 完全二叉树

      - 叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。

      - 一棵满二叉树**必定是**一棵完全二叉树，而完全二叉树未必是满二叉树。

      ![img](https://raw.githubusercontent.com/mykaneki/picgo/master/img/202304121626921.png)

   3. 二叉排序树（二叉查找树）

      -  没有键值相等的节点

      ![折半查找的过程可以用一颗二叉树来描述](https://raw.githubusercontent.com/mykaneki/picgo/master/img/202304121629583.png)

6. 二叉判定树

   **顺序存储的序列{1,2,3,4,5,6,7,8,9,10} 来构建二叉判定树，计算其ASL** 

   ![](https://raw.githubusercontent.com/mykaneki/picgo/master/img/202304121634926.png)

   **ASL成功 = 每层结点所在高度×每层结点数 之和 除以 总结点数**

   ASL=(1×1+2×2+3×4+4×3)/10=29/10;

   **ASL失败 = （每层【补上的】结点所在高度-1）×每层【补上的】结点数 之和 除以 【补上的】总结点数**

   ASL=(3×5+4×6)/11=39/11;

7. 二叉搜索（排序、查找）树的构造过程

   构造二叉排序树的过程，就是从空二叉树开始，逐个向树中插入节点的过程。

   设记录的关键码序列为：63,90,70,55,67,42,98,83,10,45,58

   ![二叉搜索（排序、查找）树的构造过程](https://raw.githubusercontent.com/mykaneki/picgo/master/img/202304121724734.png) 

8. 二叉树的遍历

   以根为基准

   先序：根左右

   必须有**中序**遍历才可以还原二叉树

9. 树、森林与二叉树的转换

   1. 树转换成二叉树

      ![树转换成二叉树的步骤](https://raw.githubusercontent.com/mykaneki/picgo/master/img/202304121734166.png)

   2. 森林转换为二叉树

      ![森林转换为二叉树](https://raw.githubusercontent.com/mykaneki/picgo/master/img/202304121734034.png)

   3. 二叉树转换为树

      ![二叉树转换为树](https://raw.githubusercontent.com/mykaneki/picgo/master/img/202304121736542.png)

   4. 二叉树转换为森林

   5. 转换以后的特点

      | 树   | 二叉树 |
      | ---- | ------ |
      | 先序 | 先序   |
      | 后序 | 中序   |
      | 层序 | 后序   |

      森林的先序遍历和中序遍历与所转换得到的二叉树的先序遍历和中序遍历的结果序列相同

10. 线索二叉树

    1. 概念

       - **前驱与后继**：在二叉树的`先序、中序或后序遍历序列`中的两个`相邻的结点`；
       - **线索**：指向前驱或后继的`结点的指针`；
       - **线索二叉树**：`加上线索`的`二叉链表`的`二叉树`；
       - **线索化**：对二叉树按`某个遍历次序`使其`变为线索二叉树`的过程。(**左前右后，0孩1前后**)

    2. 线索二叉树存储结构

       ```c
       typedef struct ThreadNode{
       	char data;
       	struct ThreadNode *lchild, *rchild;	// 左右孩子指针
       	int ltag, rtag;	// 左右线索标志
       }ThreadNode, *ThreadTree;
       ```

    3. 遍历线索化二叉树

11. 哈夫曼树（最优二叉树）

    1. 带权路径长度WPL

       ![带权路径长度WPL计算](https://raw.githubusercontent.com/mykaneki/picgo/master/img/202304121759832.png)

    2. 哈夫曼树的构造

       每次找最小的两个作为叶子

       两个叶子的和作为父节点

    3. 哈夫曼树的性质

       权值越大离根节点越近

       没有节点的度为1

       n个叶子节点的哈夫曼树的结点总数为 2n-1 

       度为2的结点数为 n-1 

    4. 哈夫曼编码

12. 

13. 

14. 

15. 
