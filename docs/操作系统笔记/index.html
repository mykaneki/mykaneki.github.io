<!doctype html><html lang=zh-cn dir=ltr class=scroll-smooth data-default-appearance=dark data-auto-appearance=true><head><meta charset=utf-8><meta http-equiv=content-language content="zh-cn"><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><title>操作系统学习笔记 &#183; mykaneki's blog</title><meta name=title content="操作系统学习笔记 &#183; mykaneki's blog"><meta name=description content="My awesome website"><link rel=canonical href=https://mykaneki.github.io/docs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/><link type=text/css rel=stylesheet href=/css/main.bundle.min.b9ea6ac1de9e040e17a3a3e7bbe17d49f4f29c24060418953590fa329ba8420aae6994d37a142bf60fdba7fd747c9e01ed54a547790b87172d9ccd7c4074b5ca.css integrity="sha512-uepqwd6eBA4Xo6Pnu+F9SfTynCQGBBiVNZD6MpuoQgquaZTTehQr9g/bp/10fJ4B7VSlR3kLhxctnM18QHS1yg=="><script type=text/javascript src=/js/main.min.cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e.js integrity="sha512-z4PhNX7vuL3xVChQ1m2AB9Yg5AULVxXcg/SpIdNs6c5H0NE8XYXysP+DGNKHfuwvY7kxvUdBeoGlODJ6+SfaPg=="></script>
<script type=text/javascript src=/js/appearance.min.f94f4c4636d9e3ec8f5ee53cdc8ffa3d01bf87cd92ac85e6797550b1e2b80dc9118d838f3eb24c55109352455e72ff082dfe560283154e5a8f87fd75107b59c4.js integrity="sha512-+U9MRjbZ4+yPXuU83I/6PQG/h82SrIXmeXVQseK4DckRjYOPPrJMVRCTUkVecv8ILf5WAoMVTlqPh/11EHtZxA=="></script>
<script defer type=text/javascript id=script-bundle src=/js/main.bundle.min.3ddcf04f5b0d4c32f72e726d3c12eebccd8c3c9f9daa9a13414808895de0ae1e1cdddda6849680d5bd96dbb60d0b1e0b24c29f5c83e5631e55e7e6bc02015490.js integrity="sha512-PdzwT1sNTDL3LnJtPBLuvM2MPJ+dqpoTQUgIiV3grh4c3d2mhJaA1b2W27YNCx4LJMKfXIPlYx5V5+a8AgFUkA==" data-copy data-copied></script>
<script src=/js/zoom.min.js></script>
<link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta property="og:title" content="操作系统学习笔记"><meta property="og:description" content="1. 绪论> 1. 绪论 # 1.1 操作系统概述> 1.1 操作系统概述 # 1.1.1 操作系统的定义> 1.1.1 操作系统的定义 # Operating System 是指控制和管理整个计算机系统的硬件与软件资源，合理地组织和调度计算机的工作和资源的分配，进而为用户和其他软件提供方便接口与环境的程序集合。
操作系统是计算机系统中最基本的系统软件。
1.1.2 操作系统的功能> 1.1.2 操作系统的功能 # 操作系统是用户和计算机硬件之间的接口。
命令接口
联机命令接口（交互式命令接口）
适用于分时和实时操作系统
脱机命令接口（批处理命令接口）
适用于批处理系统"><meta property="og:type" content="article"><meta property="og:url" content="https://mykaneki.github.io/docs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"><meta property="og:image" content="https://mykaneki.github.io/docs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/featured.jpg"><meta property="article:section" content="docs"><meta property="article:published_time" content="2022-01-07T00:00:00+00:00"><meta property="article:modified_time" content="2022-01-07T00:00:00+00:00"><meta property="og:site_name" content="mykaneki's blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://mykaneki.github.io/docs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/featured.jpg"><meta name=twitter:title content="操作系统学习笔记"><meta name=twitter:description content="1. 绪论> 1. 绪论 # 1.1 操作系统概述> 1.1 操作系统概述 # 1.1.1 操作系统的定义> 1.1.1 操作系统的定义 # Operating System 是指控制和管理整个计算机系统的硬件与软件资源，合理地组织和调度计算机的工作和资源的分配，进而为用户和其他软件提供方便接口与环境的程序集合。
操作系统是计算机系统中最基本的系统软件。
1.1.2 操作系统的功能> 1.1.2 操作系统的功能 # 操作系统是用户和计算机硬件之间的接口。
命令接口
联机命令接口（交互式命令接口）
适用于分时和实时操作系统
脱机命令接口（批处理命令接口）
适用于批处理系统"><script type=application/ld+json>[{"@context":"https://schema.org","@type":"Article","articleSection":"Docs","name":"操作系统学习笔记","headline":"操作系统学习笔记","abstract":"1. 绪论\u003e 1. 绪论 # 1.1 操作系统概述\u003e 1.1 操作系统概述 # 1.1.1 操作系统的定义\u003e 1.1.1 操作系统的定义 # Operating System 是指控制和管理整个计算机系统的硬件与软件资源，合理地组织和调度计算机的工作和资源的分配，进而为用户和其他软件提供方便接口与环境的程序集合。\n操作系统是计算机系统中最基本的系统软件。\n1.1.2 操作系统的功能\u003e 1.1.2 操作系统的功能 # 操作系统是用户和计算机硬件之间的接口。\n命令接口\n联机命令接口（交互式命令接口）\n适用于分时和实时操作系统\n脱机命令接口（批处理命令接口）\n适用于批处理系统","inLanguage":"zh-cn","url":"https:\/\/mykaneki.github.io\/docs\/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0\/","author":{"@type":"Person","name":"mykaneki"},"copyrightYear":"2022","dateCreated":"2022-01-07T00:00:00\u002b00:00","datePublished":"2022-01-07T00:00:00\u002b00:00","dateModified":"2022-01-07T00:00:00\u002b00:00","keywords":["操作系统"],"mainEntityOfPage":"true","wordCount":"2681"}]</script><meta name=author content="mykaneki"><link href=cmy_kaneki@qq.com rel=me><link href=https://github.com/mykaneki rel=me><script async src="https://www.googletagmanager.com/gtag/js?id=G-5MM4NB6CC9"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-5MM4NB6CC9",{anonymize_ip:!1})}</script><script src=https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js></script>
<script src=https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js></script>
<script src=https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js></script>
<script>const firebaseConfig={apiKey:"AIzaSyC5UrDhesjW3q1GpRz06wXtA8mFaJzCORk",authDomain:"AIzaSyC5UrDhesjW3q1GpRz06wXtA8mFaJzCORk",projectId:"mykaneki-github-page",storageBucket:"mykaneki-github-page.appspot.com",messagingSenderId:"615146370767",appId:"1:615146370767:web:ffa28dccc2b7017e77a9ba",measurementId:"G-5MM4NB6CC9"};var app=firebase.initializeApp(firebaseConfig),db=firebase.firestore(),auth=firebase.auth()</script></head><body class="flex flex-col h-screen px-6 m-auto text-lg leading-7 max-w-7xl bg-neutral text-neutral-900 dark:bg-neutral-800 dark:text-neutral sm:px-14 md:px-24 lg:px-32"><div id=the-top class="absolute flex self-center"><a class="px-3 py-1 text-sm -translate-y-8 rounded-b-lg bg-primary-200 focus:translate-y-0 dark:bg-neutral-600" href=#main-content><span class="font-bold text-primary-600 ltr:pr-2 rtl:pl-2 dark:text-primary-400">&darr;</span>Skip to main content</a></div><div style=padding-left:0;padding-right:0 class="flex items-center justify-between px-4 py-6 sm:px-6 md:justify-start space-x-3"><div class="flex flex-1 items-center justify-between"><nav class="flex space-x-3"><a href=/ class="text-base font-medium text-gray-500 hover:text-gray-900">mykaneki&rsquo;s blog</a></nav><div class="hidden md:flex items-center space-x-5 md:ml-12"><a href=/docs/ class="text-base font-medium text-gray-500 hover:text-gray-900" title=Docs>文档</a>
<a href=/posts/ class="text-base font-medium text-gray-500 hover:text-gray-900" title=文章列表>文章</a>
<a href=/series/ class="text-base font-medium text-gray-500 hover:text-gray-900" title=Series>系列</a>
<button id=search-button class="text-base hover:text-primary-600 dark:hover:text-primary-400" title>
<span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></button><div class="ltr:mr-14 rtl:ml-14 cursor-pointer text-sm text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400"><button id=appearance-switcher type=button><div class="flex items-center justify-center h-12 dark:hidden"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="items-center justify-center hidden h-12 dark:flex"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button></div></div><div class="flex md:hidden items-center space-x-5 md:ml-12"><span></span>
<button id=search-button-mobile class="text-base hover:text-primary-600 dark:hover:text-primary-400" title>
<span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></button>
<button id=appearance-switcher-mobile type=button style=margin-right:5px><div class="flex items-center justify-center h-12 dark:hidden"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="items-center justify-center hidden h-12 dark:flex"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button></div></div><div class="-my-2 -mr-2 md:hidden"><label id=menu-button for=menu-controller class=block><input type=checkbox id=menu-controller class=hidden><div class="cursor-pointer hover:text-primary-600 dark:hover:text-primary-400"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentcolor" d="M0 96C0 78.33 14.33 64 32 64H416c17.7.0 32 14.33 32 32 0 17.7-14.3 32-32 32H32C14.33 128 0 113.7.0 96zM0 256c0-17.7 14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32H32c-17.67.0-32-14.3-32-32zM416 448H32c-17.67.0-32-14.3-32-32s14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32z"/></svg></span></div><div id=menu-wrapper style=padding-top:25px class="fixed inset-0 z-30 invisible w-screen h-screen m-auto overflow-auto transition-opacity opacity-0 cursor-default bg-neutral-100/50 backdrop-blur-sm dark:bg-neutral-900/50"><ul class="flex movedown flex-col w-full px-6 py-6 mx-auto overflow-visible list-none ltr:text-right rtl:text-left max-w-7xl sm:px-14 md:px-24 lg:px-32 sm:py-10 sm:pt-10"><li class=mb-1><span class="cursor-pointer hover:text-primary-600 dark:hover:text-primary-400"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentcolor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></span></li><li class=mb-1><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2" href=/docs/ title=Docs><span class="inline-block align-text-bottom"></span>文档</a></li><li class=mb-1><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2" href=/posts/ title=文章列表><span class="inline-block align-text-bottom"></span>文章</a></li><li class=mb-1><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2" href=/series/ title=Series><span class="inline-block align-text-bottom"></span>系列</a></li></ul></div></label></div></div><div class="relative flex flex-col grow"><main id=main-content class=grow><article><div id=hero class="h-[150px] md:h-[200px]"></div><div class="fixed inset-x-0 top-0 h-[800px] single_hero_background nozoom" style=background-image:url(/docs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/featured_huaa23d04321a23466965c7033a875e4f1_3191547_1200x0_resize_q75_box.jpg)><div class="absolute inset-0 bg-gradient-to-t from-neutral dark:from-neutral-800 to-transparent mix-blend-normal"></div><div class="absolute inset-0 opacity-30 dark:opacity-60 bg-gradient-to-t from-neutral dark:from-neutral-800 to-neutral dark:to-neutral-800 mix-blend-normal"></div></div><div id=background-blur class="fixed opacity-0 inset-x-0 top-0 h-full single_hero_background nozoom backdrop-blur-2xl"></div><script>window.addEventListener("scroll",function(){var t=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,n=document.getElementById("background-blur");n.style.opacity=t/300})</script><header id=single_header class="mt-5 max-w-prose"><ol class="text-sm text-neutral-500 dark:text-neutral-400 print:hidden"><li class="inline hidden"><a class="hover:underline decoration-neutral-300 dark:underline-neutral-600" href=/>Documentation</a><span class="px-1 text-primary-500">/</span></li><li class=inline><a class="hover:underline decoration-neutral-300 dark:underline-neutral-600" href=/docs/>Docs</a><span class="px-1 text-primary-500">/</span></li><li class="inline hidden"><a class="hover:underline decoration-neutral-300 dark:underline-neutral-600" href=/docs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/>操作系统学习笔记</a><span class="px-1 text-primary-500">/</span></li></ol><h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">操作系统学习笔记</h1><div class="mt-1 mb-6 text-base text-neutral-500 dark:text-neutral-400 print:hidden"><div class="flex flex-row flex-wrap items-center"><span>2681 字</span><span class="px-2 text-primary-500">&#183;</span><span>
<span id=views_docs/操作系统笔记/index.md title=views>0</span>
<span class="inline-block align-text-bottom"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path fill="currentcolor" d="M288 32c-80.8.0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7.0 24.6C17.3 304 48.6 356 95.4 399.4 142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1 3.3-7.9 3.3-16.7.0-24.6-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144 64.5-144 144-144 144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64-11.5.0-22.3-3-31.6-8.4-.2 2.8-.4 5.5-.4 8.4.0 53 43 96 96 96s96-43 96-96-43-96-96-96c-2.8.0-5.6.1-8.4.4 5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></span></span><span class="px-2 text-primary-500">&#183;</span><span>
<span id=likes_docs/操作系统笔记/index.md title=likes>0</span>
<span class="inline-block align-text-bottom"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M47.6 300.4 228.3 469.1c7.5 7 17.4 10.9 27.7 10.9s20.2-3.9 27.7-10.9L464.4 300.4c30.4-28.3 47.6-68 47.6-109.5v-5.8c0-69.9-50.5-129.5-119.4-141C347 36.5 300.6 51.4 268 84L256 96 244 84c-32.6-32.6-79-47.5-124.6-39.9C50.5 55.6.0 115.2.0 185.1v5.8c0 41.5 17.2 81.2 47.6 109.5z"/></svg></span></span></span><span class="px-2 text-primary-500">&#183;</span><span>
<button id=likes_button class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400" onclick=process_article()>
<span id=likes_button_heart style=display:none class="inline-block align-text-bottom"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M47.6 300.4 228.3 469.1c7.5 7 17.4 10.9 27.7 10.9s20.2-3.9 27.7-10.9L464.4 300.4c30.4-28.3 47.6-68 47.6-109.5v-5.8c0-69.9-50.5-129.5-119.4-141C347 36.5 300.6 51.4 268 84L256 96 244 84c-32.6-32.6-79-47.5-124.6-39.9C50.5 55.6.0 115.2.0 185.1v5.8c0 41.5 17.2 81.2 47.6 109.5z"/></svg></span></span><span id=likes_button_emtpty_heart class="inline-block align-text-bottom"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M244 84l11.1 12 12-11.98C300.6 51.37 347 36.51 392.6 44.1 461.5 55.58 512 115.2 512 185.1V190.9c0 41.5-17.2 81.2-47.6 109.5L283.7 469.1c-7.5 7-17.4 10.9-27.7 10.9S235.8 476.1 228.3 469.1L47.59 300.4C17.23 272.1.0 232.4.0 190.9V185.1c0-69.9 50.52-129.52 119.4-141 44.7-7.59 92 7.27 124.6 39.9C243.1 84 244 84.01 244 84zm11.1 79.9-45-46.8c-21.7-20.82-52.5-30.7-82.8-25.66C81.55 99.07 48 138.7 48 185.1V190.9c0 28.2 11.71 55.2 32.34 74.4L256 429.3l175.7-164c20.6-19.2 32.3-46.2 32.3-74.4V185.1c0-46.4-33.6-86.03-79.3-93.66C354.4 86.4 323.6 96.28 301.9 117.1l-46.8 46.8z"/></svg></span></span><span id=likes_button_text>&nbsp;Like</span></button></span></div><div class="flex flex-row flex-wrap items-center"></div><div class="flex flex-row flex-wrap items-center"><span style=margin-top:.5rem class=mr-2 onclick='window.open("/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/")'><span class=flex><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">操作系统</span></span></span></div></div></header><section class="flex flex-col max-w-full mt-0 prose dark:prose-invert lg:flex-row"><div class="order-first sm:max-w-prose lg:ml-auto px-0 lg:order-last lg:max-w-xs ltr:lg:pl-8 rtl:lg:pr-8"><div class="toc ltr:pl-5 rtl:pr-5 print:hidden lg:sticky lg:top-10"><details open class="mt-0 overflow-hidden rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 hidden lg:block"><summary class="block py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">Table of Contents</summary><div class="min-w-[220px] py-2 border-dotted border-neutral-300 ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#11-操作系统概述>1.1 操作系统概述</a><ul><li><a href=#111-操作系统的定义>1.1.1 操作系统的定义</a></li><li><a href=#112-操作系统的功能>1.1.2 操作系统的功能</a></li><li><a href=#113-操作系统的目的>1.1.3 操作系统的目的</a></li></ul></li><li><a href=#12-操作系统的发展过程>1.2 操作系统的发展过程</a></li><li><a href=#13-操作系统的结构>1.3 操作系统的结构</a><ul><li><a href=#131-整体>1.3.1 整体</a></li><li><a href=#132-分层>1.3.2 分层</a></li><li><a href=#133-微内核>1.3.3 微内核</a></li></ul></li><li><a href=#14-操作系统的特征>1.4 操作系统的特征</a><ul><li><a href=#141-并发性concurrency>1.4.1 并发性（Concurrency）</a></li><li><a href=#142-共享性sharing>1.4.2 共享性（Sharing）</a></li><li><a href=#143-异步性asynchronism>1.4.3 异步性（Asynchronism）</a></li><li><a href=#144-虚拟性virtuality>1.4.4 虚拟性（virtuality）</a></li></ul></li><li><a href=#题目>题目</a></li><li><a href=#15-unix-系统简介>1.5 UNIX 系统简介</a><ul><li><a href=#151-unix综述>1.5.1 UNIX综述</a></li><li><a href=#152-unix内核功能>1.5.2 UNIX内核功能</a></li></ul></li></ul><ul><li><a href=#21-多道程序设计>2.1 多道程序设计</a><ul><li><a href=#211-单道程序的顺序执行>2.1.1 单道程序的顺序执行</a></li><li><a href=#212-多道程序的并发执行>2.1.2 多道程序的并发执行</a></li></ul></li><li><a href=#22-进程的基本概念>2.2 进程的基本概念</a><ul><li><a href=#221-进程的定义>2.2.1 进程的定义</a></li><li><a href=#222-进程的属性>2.2.2 进程的属性</a></li><li><a href=#223进程与程序的关系>2.2.3进程与程序的关系</a></li></ul></li><li><a href=#23-进程的状态及转换>2.3 进程的状态及转换</a><ul><li><a href=#231-进程的基本状态及转换>2.3.1 进程的基本状态及转换</a></li><li><a href=#232-具有挂起功能的进程状态及转换>2.3.2 具有挂起功能的进程状态及转换</a></li></ul></li><li><a href=#24-作业的基本概念>2.4 作业的基本概念</a><ul><li><a href=#241-作业的定义>2.4.1 作业的定义</a></li><li><a href=#242-作业与进程的关系>2.4.2 作业与进程的关系</a></li><li><a href=#243-作业的状态及转换>2.4.3 作业的状态及转换</a></li></ul></li><li><a href=#25-进程的描述与上下文>2.5 进程的描述与上下文</a><ul><li><a href=#251-进程控制块-pcb>2.5.1 进程控制块 PCB</a></li><li><a href=#252-进程上下文>2.5.2 进程上下文</a></li></ul></li><li><a href=#26-进程的控制>2.6 进程的控制</a><ul><li><a href=#261-进程控制机构>2.6.1 进程控制机构</a></li><li><a href=#262-进程控制原语>2.6.2 进程控制原语</a></li></ul></li><li><a href=#27-线程>2.7 线程</a><ul><li><a href=#271-线程的概念>2.7.1 线程的概念</a></li><li><a href=#272-线程与进程的关系>2.7.2 线程与进程的关系</a></li><li><a href=#273-线程的实现>2.7.3 线程的实现</a></li></ul></li><li><a href=#28-处理机调度原理>2.8 处理机调度原理</a><ul><li><a href=#281-处理机的四级调度>2.8.1 处理机的四级调度</a></li><li><a href=#282-处理机调度的目标>2.8.2 处理机调度的目标</a></li><li><a href=#283-处理机调度的方式>2.8.3 处理机调度的方式</a></li><li><a href=#284-处理机调度的时机>2.8.4 处理机调度的时机</a></li></ul></li><li><a href=#29-调度算法>2.9 调度算法</a><ul><li><a href=#290-调度算法的评价指标>2.9.0 调度算法的评价指标</a></li><li><a href=#291-先来先服务first-come-first-serve>2.9.1 先来先服务（First Come First Serve）</a></li><li><a href=#292-最短周期优先-shortest-jobprocess-first>2.9.2 最短周期优先 （Shortest Job/Process First）</a></li><li><a href=#293-最高优先级优先highest-priority-first>2.9.3 最高优先级优先（Highest Priority First）</a></li><li><a href=#294-时间片轮转法round-robin>2.9.4 时间片轮转法（Round Robin）</a></li><li><a href=#295--多级反馈队列>2.9.5 多级反馈队列</a></li><li><a href=#296-实时调度>2.9.6 实时调度</a></li><li><a href=#297-高响应比优先hrrn>2.9.7 高响应比优先（HRRN）</a></li></ul></li><li><a href=#210-unix-系统进程的结构>2.10 UNIX 系统进程的结构</a><ul><li><a href=#2101-进程控制块-pcb>2.10.1 进程控制块 PCB</a></li><li><a href=#2102-进程的上下文>2.10.2 进程的上下文</a></li><li><a href=#2103-进程的状态及转换>2.10.3 进程的状态及转换</a></li></ul></li></ul><ul><li><a href=#31-进程的并发执行>3.1 进程的并发执行</a><ul><li><a href=#311-与时间有关的错误>3.1.1 与时间有关的错误</a></li><li><a href=#312-bernstein条件>3.1.2 Bernstein条件</a></li><li><a href=#313-临界资源与临界区>3.1.3 临界资源与临界区</a></li></ul></li><li><a href=#32-进程的互斥>3.2 进程的互斥</a><ul><li><a href=#321-软件实现方法>3.2.1 软件实现方法</a></li><li><a href=#322-硬件实现方法>3.2.2 硬件实现方法</a></li></ul></li><li><a href=#33-进程的同步>3.3 进程的同步</a><ul><li><a href=#331-同步的概念>3.3.1 同步的概念</a></li><li><a href=#332-同步的实现方法>3.3.2 同步的实现方法</a></li><li><a href=#333-生产者-消费者问题>3.3.3 生产者-消费者问题</a></li></ul></li><li><a href=#34-信号量>3.4 信号量</a><ul><li><a href=#341-信号量的原理>3.4.1 信号量的原理</a></li><li><a href=#342-用信号量实现进程互斥>3.4.2 用信号量实现进程互斥</a></li><li><a href=#343-用信号量实现进程的同步>3.4.3 用信号量实现进程的同步</a></li><li><a href=#344-用信号量解决生产者消费者问题>3.4.4 用信号量解决生产者—消费者问题</a></li><li><a href=#345-信号量小结及其不足>3.4.5 信号量小结及其不足</a></li><li><a href=#346-分析步骤>3.4.6 分析步骤</a></li></ul></li><li><a href=#35-管程monitor>3.5 管程(Monitor)</a><ul><li><a href=#351-管程的定义结构和原理>3.5.1 管程的定义、结构和原理</a></li><li><a href=#352-用管程解决生产者消费者问题>3.5.2 用管程解决生产者—消费者问题</a></li><li><a href=#353-管程的不足>3.5.3 管程的不足</a></li></ul></li><li><a href=#36-进程的高级通信>3.6 进程的高级通信</a><ul><li><a href=#361-消息缓冲机制>3.6.1 消息缓冲机制</a></li><li><a href=#362-邮箱机制>3.6.2 邮箱机制</a></li><li><a href=#363-共享存储区>3.6.3 共享存储区</a></li><li><a href=#364-管道>3.6.4 管道</a></li></ul></li><li><a href=#37-死锁>3.7 死锁</a><ul><li><a href=#371-什么是死锁>3.7.1 什么是死锁</a></li><li><a href=#372-死锁的表示>3.7.2 死锁的表示</a></li><li><a href=#373-死锁的检测和清除>3.7.3 死锁的检测和清除</a></li><li><a href=#374-死锁的预防>3.7.4 死锁的预防</a></li><li><a href=#375-死锁的避免>3.7.5 死锁的避免</a></li></ul></li></ul><ul><li><a href=#41-存储管理的基本功能>4.1 存储管理的基本功能</a><ul><li><a href=#411-转换>4.1.1 转换</a></li><li><a href=#412-存储保护和共享>4.1.2 存储保护和共享</a></li><li><a href=#413-内存分配回收>4.1.3 内存分配回收</a></li><li><a href=#414-内存扩充>4.1.4 内存扩充</a></li></ul></li><li><a href=#42-分区存储管理>4.2 分区存储管理</a><ul><li><a href=#421-固定分区>4.2.1 固定分区</a></li><li><a href=#422-动态分区>4.2.2 动态分区</a></li><li><a href=#423-地址转换和存储保护>4.2.3 地址转换和存储保护</a></li><li><a href=#424-存储共享>4.2.4 存储共享</a></li><li><a href=#425-分配和回收算法>4.2.5 分配和回收算法</a></li><li><a href=#426-覆盖和交换>4.2.6 覆盖和交换</a></li><li><a href=#427-分区存储管理的优缺点>4.2.7 分区存储管理的优缺点</a></li></ul></li><li><a href=#43-分页式存储管理>4.3 分页式存储管理</a><ul><li><a href=#431-基本原理>4.3.1 基本原理</a></li><li><a href=#432-数据结构>4.3.2 数据结构</a></li><li><a href=#433-地址转换和存储保护>4.3.3 地址转换和存储保护</a></li><li><a href=#434-存储共享>4.3.4 存储共享</a></li><li><a href=#435-分配算法>4.3.5 分配算法</a></li><li><a href=#436-分页式存储管理的优缺点>4.3.6 分页式存储管理的优缺点</a></li></ul></li><li><a href=#44-分段式存储管理>4.4 分段式存储管理</a><ul><li><a href=#441-基本原理>4.4.1 基本原理</a></li><li><a href=#442-地址转换和存储保护>4.4.2 地址转换和存储保护</a></li><li><a href=#443-存储共享>4.4.3 存储共享</a></li><li><a href=#444-分段式存储管理的优缺点>4.4.4 分段式存储管理的优缺点</a></li></ul></li><li><a href=#45-段页式存储管理>4.5 段页式存储管理</a><ul><li><a href=#451-基本原理>4.5.1 基本原理</a></li><li><a href=#452-地址转换>4.5.2 地址转换</a></li><li><a href=#453-段页式存储管理的优缺点>4.5.3 段页式存储管理的优缺点</a></li></ul></li><li><a href=#46-虚拟存储管理>4.6 虚拟存储管理</a><ul><li><a href=#461-虚拟存储器的概念>4.6.1 虚拟存储器的概念</a></li><li><a href=#462-请求分页式虚拟存储管理>4.6.2 请求分页式虚拟存储管理</a></li><li><a href=#463-请求分段式虚拟存储管理>4.6.3 请求分段式虚拟存储管理</a></li><li><a href=#464-请求段页式虚拟存储管理>4.6.4 请求段页式虚拟存储管理</a></li></ul></li><li><a href=#47-页面置换算法>4.7 页面置换算法</a><ul><li><a href=#471-最佳置换算法opt>4.7.1 最佳置换算法（OPT）</a></li><li><a href=#472-先进先出置换算法fifo>4.7.2 先进先出置换算法（FIFO）</a></li><li><a href=#473-最近最久未使用置换算法lru>4.7.3 最近最久未使用置换算法（LRU）</a></li><li><a href=#474-最少使用lfu>4.7.4 最少使用（LFU）</a></li></ul></li><li><a href=#48-页面分配策略>4.8 页面分配策略</a><ul><li><a href=#481-驻留集>4.8.1 驻留集</a></li><li><a href=#482-调入策略>4.8.2 调入策略</a></li><li><a href=#483-抖动颠簸>4.8.3 抖动、颠簸</a></li><li><a href=#484-工作集>4.8.4 工作集</a></li></ul></li></ul><ul><li><a href=#51-文件和文件系统>5.1 文件和文件系统</a><ul><li><a href=#511-文件概念>5.1.1 文件概念</a></li><li><a href=#512-文件命名>5.1.2 文件命名</a></li><li><a href=#513-文件类型>5.1.3 文件类型</a></li><li><a href=#514-文件属性>5.1.4 文件属性</a></li><li><a href=#515-文件系统的概念>5.1.5 文件系统的概念</a></li></ul></li><li><a href=#52-文件组织存取方法和存取设备>5.2 文件组织、存取方法和存取设备</a><ul><li><a href=#521-文件的逻辑结构>5.2.1 文件的逻辑结构</a></li><li><a href=#522-文件的物理结构>5.2.2 文件的物理结构</a></li><li><a href=#523-文件的存取方法>5.2.3 文件的存取方法</a></li><li><a href=#524-文件的存储设备>5.2.4 文件的存储设备</a></li></ul></li><li><a href=#53-文件目录>5.3 文件目录</a><ul><li><a href=#530-文件控制块fcb>5.3.0 文件控制块（FCB）</a></li><li><a href=#531-一级目录结构>5.3.1 一级目录结构</a></li><li><a href=#532-二级目录结构>5.3.2 二级目录结构</a></li><li><a href=#533-树形目录结构>5.3.3 树形目录结构</a></li><li><a href=#534-无环图目录结构>5.3.4 无环图目录结构</a></li><li><a href=#535-索引结点fcb的改进>5.3.5 索引结点（FCB的改进）</a></li></ul></li><li><a href=#54-文件共享与保护>5.4 文件共享与保护</a><ul><li><a href=#541-文件共享>5.4.1 文件共享</a></li><li><a href=#542-文件保护>5.4.2 文件保护</a></li></ul></li><li><a href=#55-文件系统其他功能的实现>5.5 文件系统其他功能的实现</a><ul><li><a href=#551-文件操作>5.5.1 文件操作</a></li><li><a href=#552-文件系统的层次结构>5.5.2 文件系统的层次结构</a></li><li><a href=#553-外存空间管理>5.5.3 外存空间管理</a></li><li><a href=#554-虚拟文件系统>5.5.4 虚拟文件系统</a></li></ul></li></ul></nav></div></details><details class="mt-0 overflow-hidden rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 lg:hidden"><summary class="py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">Table of Contents</summary><div class="py-2 border-dotted border-neutral-300 ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#11-操作系统概述>1.1 操作系统概述</a><ul><li><a href=#111-操作系统的定义>1.1.1 操作系统的定义</a></li><li><a href=#112-操作系统的功能>1.1.2 操作系统的功能</a></li><li><a href=#113-操作系统的目的>1.1.3 操作系统的目的</a></li></ul></li><li><a href=#12-操作系统的发展过程>1.2 操作系统的发展过程</a></li><li><a href=#13-操作系统的结构>1.3 操作系统的结构</a><ul><li><a href=#131-整体>1.3.1 整体</a></li><li><a href=#132-分层>1.3.2 分层</a></li><li><a href=#133-微内核>1.3.3 微内核</a></li></ul></li><li><a href=#14-操作系统的特征>1.4 操作系统的特征</a><ul><li><a href=#141-并发性concurrency>1.4.1 并发性（Concurrency）</a></li><li><a href=#142-共享性sharing>1.4.2 共享性（Sharing）</a></li><li><a href=#143-异步性asynchronism>1.4.3 异步性（Asynchronism）</a></li><li><a href=#144-虚拟性virtuality>1.4.4 虚拟性（virtuality）</a></li></ul></li><li><a href=#题目>题目</a></li><li><a href=#15-unix-系统简介>1.5 UNIX 系统简介</a><ul><li><a href=#151-unix综述>1.5.1 UNIX综述</a></li><li><a href=#152-unix内核功能>1.5.2 UNIX内核功能</a></li></ul></li></ul><ul><li><a href=#21-多道程序设计>2.1 多道程序设计</a><ul><li><a href=#211-单道程序的顺序执行>2.1.1 单道程序的顺序执行</a></li><li><a href=#212-多道程序的并发执行>2.1.2 多道程序的并发执行</a></li></ul></li><li><a href=#22-进程的基本概念>2.2 进程的基本概念</a><ul><li><a href=#221-进程的定义>2.2.1 进程的定义</a></li><li><a href=#222-进程的属性>2.2.2 进程的属性</a></li><li><a href=#223进程与程序的关系>2.2.3进程与程序的关系</a></li></ul></li><li><a href=#23-进程的状态及转换>2.3 进程的状态及转换</a><ul><li><a href=#231-进程的基本状态及转换>2.3.1 进程的基本状态及转换</a></li><li><a href=#232-具有挂起功能的进程状态及转换>2.3.2 具有挂起功能的进程状态及转换</a></li></ul></li><li><a href=#24-作业的基本概念>2.4 作业的基本概念</a><ul><li><a href=#241-作业的定义>2.4.1 作业的定义</a></li><li><a href=#242-作业与进程的关系>2.4.2 作业与进程的关系</a></li><li><a href=#243-作业的状态及转换>2.4.3 作业的状态及转换</a></li></ul></li><li><a href=#25-进程的描述与上下文>2.5 进程的描述与上下文</a><ul><li><a href=#251-进程控制块-pcb>2.5.1 进程控制块 PCB</a></li><li><a href=#252-进程上下文>2.5.2 进程上下文</a></li></ul></li><li><a href=#26-进程的控制>2.6 进程的控制</a><ul><li><a href=#261-进程控制机构>2.6.1 进程控制机构</a></li><li><a href=#262-进程控制原语>2.6.2 进程控制原语</a></li></ul></li><li><a href=#27-线程>2.7 线程</a><ul><li><a href=#271-线程的概念>2.7.1 线程的概念</a></li><li><a href=#272-线程与进程的关系>2.7.2 线程与进程的关系</a></li><li><a href=#273-线程的实现>2.7.3 线程的实现</a></li></ul></li><li><a href=#28-处理机调度原理>2.8 处理机调度原理</a><ul><li><a href=#281-处理机的四级调度>2.8.1 处理机的四级调度</a></li><li><a href=#282-处理机调度的目标>2.8.2 处理机调度的目标</a></li><li><a href=#283-处理机调度的方式>2.8.3 处理机调度的方式</a></li><li><a href=#284-处理机调度的时机>2.8.4 处理机调度的时机</a></li></ul></li><li><a href=#29-调度算法>2.9 调度算法</a><ul><li><a href=#290-调度算法的评价指标>2.9.0 调度算法的评价指标</a></li><li><a href=#291-先来先服务first-come-first-serve>2.9.1 先来先服务（First Come First Serve）</a></li><li><a href=#292-最短周期优先-shortest-jobprocess-first>2.9.2 最短周期优先 （Shortest Job/Process First）</a></li><li><a href=#293-最高优先级优先highest-priority-first>2.9.3 最高优先级优先（Highest Priority First）</a></li><li><a href=#294-时间片轮转法round-robin>2.9.4 时间片轮转法（Round Robin）</a></li><li><a href=#295--多级反馈队列>2.9.5 多级反馈队列</a></li><li><a href=#296-实时调度>2.9.6 实时调度</a></li><li><a href=#297-高响应比优先hrrn>2.9.7 高响应比优先（HRRN）</a></li></ul></li><li><a href=#210-unix-系统进程的结构>2.10 UNIX 系统进程的结构</a><ul><li><a href=#2101-进程控制块-pcb>2.10.1 进程控制块 PCB</a></li><li><a href=#2102-进程的上下文>2.10.2 进程的上下文</a></li><li><a href=#2103-进程的状态及转换>2.10.3 进程的状态及转换</a></li></ul></li></ul><ul><li><a href=#31-进程的并发执行>3.1 进程的并发执行</a><ul><li><a href=#311-与时间有关的错误>3.1.1 与时间有关的错误</a></li><li><a href=#312-bernstein条件>3.1.2 Bernstein条件</a></li><li><a href=#313-临界资源与临界区>3.1.3 临界资源与临界区</a></li></ul></li><li><a href=#32-进程的互斥>3.2 进程的互斥</a><ul><li><a href=#321-软件实现方法>3.2.1 软件实现方法</a></li><li><a href=#322-硬件实现方法>3.2.2 硬件实现方法</a></li></ul></li><li><a href=#33-进程的同步>3.3 进程的同步</a><ul><li><a href=#331-同步的概念>3.3.1 同步的概念</a></li><li><a href=#332-同步的实现方法>3.3.2 同步的实现方法</a></li><li><a href=#333-生产者-消费者问题>3.3.3 生产者-消费者问题</a></li></ul></li><li><a href=#34-信号量>3.4 信号量</a><ul><li><a href=#341-信号量的原理>3.4.1 信号量的原理</a></li><li><a href=#342-用信号量实现进程互斥>3.4.2 用信号量实现进程互斥</a></li><li><a href=#343-用信号量实现进程的同步>3.4.3 用信号量实现进程的同步</a></li><li><a href=#344-用信号量解决生产者消费者问题>3.4.4 用信号量解决生产者—消费者问题</a></li><li><a href=#345-信号量小结及其不足>3.4.5 信号量小结及其不足</a></li><li><a href=#346-分析步骤>3.4.6 分析步骤</a></li></ul></li><li><a href=#35-管程monitor>3.5 管程(Monitor)</a><ul><li><a href=#351-管程的定义结构和原理>3.5.1 管程的定义、结构和原理</a></li><li><a href=#352-用管程解决生产者消费者问题>3.5.2 用管程解决生产者—消费者问题</a></li><li><a href=#353-管程的不足>3.5.3 管程的不足</a></li></ul></li><li><a href=#36-进程的高级通信>3.6 进程的高级通信</a><ul><li><a href=#361-消息缓冲机制>3.6.1 消息缓冲机制</a></li><li><a href=#362-邮箱机制>3.6.2 邮箱机制</a></li><li><a href=#363-共享存储区>3.6.3 共享存储区</a></li><li><a href=#364-管道>3.6.4 管道</a></li></ul></li><li><a href=#37-死锁>3.7 死锁</a><ul><li><a href=#371-什么是死锁>3.7.1 什么是死锁</a></li><li><a href=#372-死锁的表示>3.7.2 死锁的表示</a></li><li><a href=#373-死锁的检测和清除>3.7.3 死锁的检测和清除</a></li><li><a href=#374-死锁的预防>3.7.4 死锁的预防</a></li><li><a href=#375-死锁的避免>3.7.5 死锁的避免</a></li></ul></li></ul><ul><li><a href=#41-存储管理的基本功能>4.1 存储管理的基本功能</a><ul><li><a href=#411-转换>4.1.1 转换</a></li><li><a href=#412-存储保护和共享>4.1.2 存储保护和共享</a></li><li><a href=#413-内存分配回收>4.1.3 内存分配回收</a></li><li><a href=#414-内存扩充>4.1.4 内存扩充</a></li></ul></li><li><a href=#42-分区存储管理>4.2 分区存储管理</a><ul><li><a href=#421-固定分区>4.2.1 固定分区</a></li><li><a href=#422-动态分区>4.2.2 动态分区</a></li><li><a href=#423-地址转换和存储保护>4.2.3 地址转换和存储保护</a></li><li><a href=#424-存储共享>4.2.4 存储共享</a></li><li><a href=#425-分配和回收算法>4.2.5 分配和回收算法</a></li><li><a href=#426-覆盖和交换>4.2.6 覆盖和交换</a></li><li><a href=#427-分区存储管理的优缺点>4.2.7 分区存储管理的优缺点</a></li></ul></li><li><a href=#43-分页式存储管理>4.3 分页式存储管理</a><ul><li><a href=#431-基本原理>4.3.1 基本原理</a></li><li><a href=#432-数据结构>4.3.2 数据结构</a></li><li><a href=#433-地址转换和存储保护>4.3.3 地址转换和存储保护</a></li><li><a href=#434-存储共享>4.3.4 存储共享</a></li><li><a href=#435-分配算法>4.3.5 分配算法</a></li><li><a href=#436-分页式存储管理的优缺点>4.3.6 分页式存储管理的优缺点</a></li></ul></li><li><a href=#44-分段式存储管理>4.4 分段式存储管理</a><ul><li><a href=#441-基本原理>4.4.1 基本原理</a></li><li><a href=#442-地址转换和存储保护>4.4.2 地址转换和存储保护</a></li><li><a href=#443-存储共享>4.4.3 存储共享</a></li><li><a href=#444-分段式存储管理的优缺点>4.4.4 分段式存储管理的优缺点</a></li></ul></li><li><a href=#45-段页式存储管理>4.5 段页式存储管理</a><ul><li><a href=#451-基本原理>4.5.1 基本原理</a></li><li><a href=#452-地址转换>4.5.2 地址转换</a></li><li><a href=#453-段页式存储管理的优缺点>4.5.3 段页式存储管理的优缺点</a></li></ul></li><li><a href=#46-虚拟存储管理>4.6 虚拟存储管理</a><ul><li><a href=#461-虚拟存储器的概念>4.6.1 虚拟存储器的概念</a></li><li><a href=#462-请求分页式虚拟存储管理>4.6.2 请求分页式虚拟存储管理</a></li><li><a href=#463-请求分段式虚拟存储管理>4.6.3 请求分段式虚拟存储管理</a></li><li><a href=#464-请求段页式虚拟存储管理>4.6.4 请求段页式虚拟存储管理</a></li></ul></li><li><a href=#47-页面置换算法>4.7 页面置换算法</a><ul><li><a href=#471-最佳置换算法opt>4.7.1 最佳置换算法（OPT）</a></li><li><a href=#472-先进先出置换算法fifo>4.7.2 先进先出置换算法（FIFO）</a></li><li><a href=#473-最近最久未使用置换算法lru>4.7.3 最近最久未使用置换算法（LRU）</a></li><li><a href=#474-最少使用lfu>4.7.4 最少使用（LFU）</a></li></ul></li><li><a href=#48-页面分配策略>4.8 页面分配策略</a><ul><li><a href=#481-驻留集>4.8.1 驻留集</a></li><li><a href=#482-调入策略>4.8.2 调入策略</a></li><li><a href=#483-抖动颠簸>4.8.3 抖动、颠簸</a></li><li><a href=#484-工作集>4.8.4 工作集</a></li></ul></li></ul><ul><li><a href=#51-文件和文件系统>5.1 文件和文件系统</a><ul><li><a href=#511-文件概念>5.1.1 文件概念</a></li><li><a href=#512-文件命名>5.1.2 文件命名</a></li><li><a href=#513-文件类型>5.1.3 文件类型</a></li><li><a href=#514-文件属性>5.1.4 文件属性</a></li><li><a href=#515-文件系统的概念>5.1.5 文件系统的概念</a></li></ul></li><li><a href=#52-文件组织存取方法和存取设备>5.2 文件组织、存取方法和存取设备</a><ul><li><a href=#521-文件的逻辑结构>5.2.1 文件的逻辑结构</a></li><li><a href=#522-文件的物理结构>5.2.2 文件的物理结构</a></li><li><a href=#523-文件的存取方法>5.2.3 文件的存取方法</a></li><li><a href=#524-文件的存储设备>5.2.4 文件的存储设备</a></li></ul></li><li><a href=#53-文件目录>5.3 文件目录</a><ul><li><a href=#530-文件控制块fcb>5.3.0 文件控制块（FCB）</a></li><li><a href=#531-一级目录结构>5.3.1 一级目录结构</a></li><li><a href=#532-二级目录结构>5.3.2 二级目录结构</a></li><li><a href=#533-树形目录结构>5.3.3 树形目录结构</a></li><li><a href=#534-无环图目录结构>5.3.4 无环图目录结构</a></li><li><a href=#535-索引结点fcb的改进>5.3.5 索引结点（FCB的改进）</a></li></ul></li><li><a href=#54-文件共享与保护>5.4 文件共享与保护</a><ul><li><a href=#541-文件共享>5.4.1 文件共享</a></li><li><a href=#542-文件保护>5.4.2 文件保护</a></li></ul></li><li><a href=#55-文件系统其他功能的实现>5.5 文件系统其他功能的实现</a><ul><li><a href=#551-文件操作>5.5.1 文件操作</a></li><li><a href=#552-文件系统的层次结构>5.5.2 文件系统的层次结构</a></li><li><a href=#553-外存空间管理>5.5.3 外存空间管理</a></li><li><a href=#554-虚拟文件系统>5.5.4 虚拟文件系统</a></li></ul></li></ul></nav></div></details></div></div><div class="min-w-0 min-h-0 max-w-prose"><div id=1--绪论 class=anchor>1. 绪论></div><h1 class="relative group">1. 绪论
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#1--%e7%bb%aa%e8%ae%ba aria-label=锚点>#</a></span></h1><div id=11-操作系统概述 class=anchor>1.1 操作系统概述></div><h2 class="relative group">1.1 操作系统概述
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#11-%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e6%a6%82%e8%bf%b0 aria-label=锚点>#</a></span></h2><div id=111-操作系统的定义 class=anchor>1.1.1 操作系统的定义></div><h3 class="relative group">1.1.1 操作系统的定义
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#111-%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%9a%84%e5%ae%9a%e4%b9%89 aria-label=锚点>#</a></span></h3><ul><li><p>Operating System 是指控制和管理整个计算机系统的硬件与软件资源，合理地组织和调度计算机的工作和资源的分配，进而为用户和其他软件提供方便接口与环境的程序集合。</p></li><li><p>操作系统是计算机系统中最基本的<strong>系统软件</strong>。</p></li></ul><div id=112-操作系统的功能 class=anchor>1.1.2 操作系统的功能></div><h3 class="relative group">1.1.2 操作系统的功能
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#112-%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%9a%84%e5%8a%9f%e8%83%bd aria-label=锚点>#</a></span></h3><ul><li><p>操作系统是用户和计算机硬件之间的接口。</p><ul><li><p>命令接口</p><ul><li><p>联机命令接口（交互式命令接口）</p><blockquote><p>适用于分时和实时操作系统</p></blockquote></li><li><p>脱机命令接口（批处理命令接口）</p><blockquote><p>适用于批处理系统</p></blockquote></li></ul></li><li><p>程序接口（系统调用、广义指令）</p><blockquote><p>用户通过在程序中使用这些系统调用来请求操作系统的服务</p><p>如：使用各种外部设备、申请分配和回收内存等</p><p>例：图形接口不是操作系统的一部分，但图形接口所调用的系统命令是操作系统的一部分</p></blockquote></li></ul></li><li><p>操作系统是计算机系统资源的管理者。</p><ul><li><p>处理机管理（进程管理）</p></li><li><p>存储器管理</p></li><li><p>文件管理</p></li><li><p>设备管理</p></li></ul></li><li><p>操作系统用作扩充机器</p><ul><li>操作系统使得裸机功能更强、更方便使用</li><li>因此，覆盖了软件的机器称为<strong>扩充机器</strong>或<strong>虚拟机</strong></li></ul></li></ul><div id=113-操作系统的目的 class=anchor>1.1.3 操作系统的目的></div><h3 class="relative group">1.1.3 操作系统的目的
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#113-%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%9a%84%e7%9b%ae%e7%9a%84 aria-label=锚点>#</a></span></h3><ol><li>方便性：使计算机更易于用户使用。</li><li>有效性：以有效的方式管理计算机系统的资源，合理地组织计算机的工作流程， 以防止对计算机资源的不当或错误使用。这是操作系统可用的关键因素。</li><li>可扩展性：为用户的的开发搭建一个平台，允许修改、并引进新的功能。 操作系统为计算机上所有软件的性能提高提供了平台，另外，操作系统提供了一系列功能用以支持用户程序的运行。</li></ol><div id=12-操作系统的发展过程 class=anchor>1.2 操作系统的发展过程></div><h2 class="relative group">1.2 操作系统的发展过程
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#12-%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%9a%84%e5%8f%91%e5%b1%95%e8%bf%87%e7%a8%8b aria-label=锚点>#</a></span></h2><ul><li><p>手工操作（无操作系统）</p></li><li><p>批处理阶段（开始出现操作系统）</p><ul><li><p>单道批</p></li><li><p>多道批</p></li></ul></li><li><p>分时操作系统（交互性强）</p></li><li><p>实时操作系统（及时性、可靠性、交互性不如分时）</p></li><li><p>网络操作系统（服务于计算机网络，集中式控制）</p></li><li><p>分布式操作系统（建立在网络操作系统上，分布控制）</p></li><li><p>个人计算机</p></li></ul><div id=13-操作系统的结构 class=anchor>1.3 操作系统的结构></div><h2 class="relative group">1.3 操作系统的结构
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#13-%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%9a%84%e7%bb%93%e6%9e%84 aria-label=锚点>#</a></span></h2><div id=131-整体 class=anchor>1.3.1 整体></div><h3 class="relative group">1.3.1 整体
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#131-%e6%95%b4%e4%bd%93 aria-label=锚点>#</a></span></h3><blockquote><p>例如 CP/M 和 MS-DOS，以及原始的 UNIX 操作系统。MS-DOS 系统设计的目标是利用最小的空间提供最多的功能</p></blockquote><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/202301071507148.png alt=image-20230107150738940></figure></p><ul><li>优点<ul><li>由于整体结构的操作系统的应用程序和底层硬件之间没有太多接口，所以这种类型的 操作系统结构紧密，接口简单直接，<strong>系统效率较高，具有良好的性能</strong>。</li></ul></li><li>缺点<ul><li>这种结构 的模块独立性差，易形成复杂的调用关系，使得<strong>增强或维护这样的操作系统很困难</strong>，修改 其中的一个模块将会影响到其他模块。</li></ul></li></ul><div id=132-分层 class=anchor>1.3.2 分层></div><h3 class="relative group">1.3.2 分层
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#132-%e5%88%86%e5%b1%82 aria-label=锚点>#</a></span></h3><blockquote><p>分层操作系统的例子有 VAX/VMS 和 UNIX 等。</p><p>由于增强或维护整体结构的操作系统所遇到的问题，导致了分层操作系统的出现。</p><p>层次结构正是从这点出发，力求使模块间调用的无序性变为有序性。</p></blockquote><ul><li><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/202301071508317.png alt=image-20230107150819169></figure></li><li>优点<ul><li>增加了系统的可读性和可适应性，简化了系统的设计和实现。</li><li><strong>易于调试、修改、扩充、维护和保证正确性</strong>。</li></ul></li><li>缺点<ul><li><strong>操作系统的效率不高</strong>。由于所有请求在到达硬件之前要经过很多层，每一层所 产生的系统开销会使得操作系统的效率较低。</li><li><strong>层的定义较为困难</strong>。在设计层次结构时，各系统对划分层次的数目有不同的看法，有时很难决定特定层中应该包含的内容。</li></ul></li></ul><div id=133-微内核 class=anchor>1.3.3 微内核></div><h3 class="relative group">1.3.3 微内核
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#133-%e5%be%ae%e5%86%85%e6%a0%b8 aria-label=锚点>#</a></span></h3><blockquote><p>采用微内核的思想开发的操作系统有：Minix、Tru64 UNIX、L4、QNX 等。</p><p>在分层操作系统中，设计者要确定内核—用户的边界，所有的层都在内核中。然而， 随着操作系统的开发人员开始给系统添加越来越多的特性，使得内核变得越来越大且难于管理。</p><p>微内核（micro-kernel）设计的思想是：将操作系统划分成小的、定义良好的模块。</p><p>微内核通常只提供了<strong>最基本的操作系统功能</strong>，如进程管理、通信原语和低级内存管理。</p><p>在内核外部实现的系统程序或用户级程序提供了其余的操作系统服务，这些程序被称为服务器。应用程序和不同的服务器通过传递给微内核的消息进行通信，微内核验证消息，然后在操作系统的不同模块之间传送消息，并允许对硬件进行访问。例如：如果客户程序希望访问一个文件，那么它必须与文件服务器进行交互。客户程序和服务器不会直接交互，而是通过微内核的消息传递来进行通信。</p></blockquote><ul><li><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/202301071509147.png alt></figure><figure><img class="my-0 rounded-md" src=#ZgotmplZ alt=image-20230107150843348></figure></p></li><li><p>优点</p><ul><li>良好的扩充性：通过添加服务器就可以简单地增加新的服务种类而不需要修改 内核。</li><li>可靠性好：如果某个特定的服务器出现问题，那么可以重新配置和启动该服务 器，而不必重新启动整个操作系统。</li><li>高灵活性：由于内核和服务器之间是分隔的，所以使用单个微内核就可以构造 出满足各种特定环境的不同的操作系统。例如：Mac OS X、Tru64 UNIX 以及某些变种的 Linux 都可以在 Mach 微内核上实现。</li><li>可移植性强：由于微内核可以直接和底层硬件进行交互，所以可以很方便地将 操作系统移植到各个不同的平台上。</li></ul></li></ul><div id=14-操作系统的特征 class=anchor>1.4 操作系统的特征></div><h2 class="relative group">1.4 操作系统的特征
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#14-%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%9a%84%e7%89%b9%e5%be%81 aria-label=锚点>#</a></span></h2><div id=141-并发性concurrency class=anchor>1.4.1 并发性（Concurrency）></div><h3 class="relative group">1.4.1 并发性（Concurrency）
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#141-%e5%b9%b6%e5%8f%91%e6%80%a7concurrency aria-label=锚点>#</a></span></h3><p>宏观多道程序同时执行，微观交替执行，对有限物理资源进行多用户共享以提高效率。</p><div id=142-共享性sharing class=anchor>1.4.2 共享性（Sharing）></div><h3 class="relative group">1.4.2 共享性（Sharing）
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#142-%e5%85%b1%e4%ba%ab%e6%80%a7sharing aria-label=锚点>#</a></span></h3><p>互斥访问，同时访问</p><blockquote><p>并发和共享相互依存</p></blockquote><div id=143-异步性asynchronism class=anchor>1.4.3 异步性（Asynchronism）></div><h3 class="relative group">1.4.3 异步性（Asynchronism）
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#143-%e5%bc%82%e6%ad%a5%e6%80%a7asynchronism aria-label=锚点>#</a></span></h3><p>在操作系统控制下多个进程的<strong>执行次序</strong>和每个进程的<strong>执行时间</strong>是不确定的。</p><div id=144-虚拟性virtuality class=anchor>1.4.4 虚拟性（virtuality）></div><h3 class="relative group">1.4.4 虚拟性（virtuality）
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#144-%e8%99%9a%e6%8b%9f%e6%80%a7virtuality aria-label=锚点>#</a></span></h3><p>虚拟指把一个物理上的实体变为若干逻辑上的对应物。</p><p>虚拟技术可分为：时分复用和空分复用。</p><p>如：虚拟处理器、虚拟存储器、虚拟内存、虚拟外部设备。</p><blockquote><p>假脱机技术 **SPOOLing ** (Simultaneous Peripheral Operations On-Line) 技术可把物理上的一台独占设备变成逻辑上的多台虚拟设备；</p><p>若有进程要求对它打印输出时，SPOOLing系统并不是将这台打印机直接分配给进程，而是在共享设备（磁盘或磁鼓）上的输出SPOOLing存储区中为其分配一块存储空间，进程的输出数据以文件形式存放于此。在SPOOLing 系统中，实际上并没有为任何进程分配，而只是在输入井和输出井中，为进程分配一存储区和建立一张I/O请求表。这样，便把独占设备改造为共享设备。</p></blockquote><div id=题目 class=anchor>题目></div><h2 class="relative group">题目
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e9%a2%98%e7%9b%ae aria-label=锚点>#</a></span></h2><ul><li>计算机开机后，操作系统最终会被加载到 RAM</li></ul><blockquote><p>BIOS（Basic Input Output System）：它是一组固化到计算机内主板上一个<strong>ROM</strong>芯片上的程序，它保存着计算机最重要的基本输入输出的程序、开机后自检程序和系统自启动程序，它可从CMOS中读写系统设置的具体信息。</p><p>ROM（Read-Only Memory）：只读存储器ROM，所存数据通常是装入整机前写入的，整机工作过程中只能读出。</p><p>EPROM：可擦除可编程只读存储器，一旦编程完成后，EPROM只能用强紫外线照射来擦除。</p><p>RAM （Random Access Memory）：随机存取存储器，也叫主存，是与<a href=https://baike.baidu.com/item/CPU target=_blank>
CPU</a>直接交换数据的内部存储器。RAM在计算机和数字系统中用来暂时存储程序、数据和中间结果。</p></blockquote><div id=15-unix-系统简介 class=anchor>1.5 UNIX 系统简介></div><h2 class="relative group">1.5 UNIX 系统简介
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#15-unix-%e7%b3%bb%e7%bb%9f%e7%ae%80%e4%bb%8b aria-label=锚点>#</a></span></h2><blockquote><p>UNIX 操作系统是一个多用户分时操作系统。</p><p>由于它的绝大部分代码是用 C 语言编制 的，故可移植性极好。</p></blockquote><div id=151-unix综述 class=anchor>1.5.1 UNIX综述></div><h3 class="relative group">1.5.1 UNIX综述
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#151-unix%e7%bb%bc%e8%bf%b0 aria-label=锚点>#</a></span></h3><ul><li><p>UNIX特点</p><ol><li><p>内核简洁，可常驻内存，保证系统高效运行，同时可以开发大量核外程序为用户服务。</p></li><li><p>用C语言编写，具有良好的可移植性。</p></li><li><p>树形结构文件系统</p><blockquote><p>搜索速度快、安全性、保密性、可维护性；</p><p>文件系统可装卸，用户可以同时使用多个文件系统；</p></blockquote></li><li><p>外设和文件统一看成文件，在用户面前，操作方式相同。</p></li><li><p>I/O重定向和管道，灵活性高</p><blockquote><p>通过 <strong>I/O 重定向</strong>，可以指定命令或程序从何处得到输入和将结果送到何处去，从而改变了默认的输入源位置和输出目标位置。</p><p><strong>管道</strong>让一个命令或程序的输出成为另一个命令或程序的输入。</p></blockquote></li><li><p>良好的用户接口，提供shell和系统调用</p></li><li><p>开放式的操作系统</p><blockquote><p>允许用户自己编写工具和程序</p><p>提供TCP/IP协议，可实现网络互联</p></blockquote></li><li><p>开发环境优良</p><blockquote><p>提供有大量的软件开发工具，如源代码控 制系统（SCCS）、词法分析器自动生成器（Lex）、优化 C 编译器和源代码调试工具等。</p></blockquote></li><li><p>丰富的使用程序，软件厂商支持</p></li></ol></li><li><p>UNIX的分层体系结构</p><ul><li><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/202301071514722.png alt=image-20230107151437547></figure></li></ul></li></ul><div id=152-unix内核功能 class=anchor>1.5.2 UNIX内核功能></div><h3 class="relative group">1.5.2 UNIX内核功能
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#152-unix%e5%86%85%e6%a0%b8%e5%8a%9f%e8%83%bd aria-label=锚点>#</a></span></h3><ul><li><p>UNIX内核结构</p><p>分为三级：用户级、核心级、硬件级</p><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/202301071514355.png alt=image-20230107151450180></figure></p></li><li><p>UNIX内核功能简述</p><ol><li><p>文件子系统</p><blockquote><p>(1) 空闲文件存储空间的管理；</p><p>(2) 为文件分配文件存储空间；</p><p>(3) 回收文件释放的文件存储空间；</p><p>(4) 文件存取控制；</p><p>(5) 搜索文件；</p><p>(6) 为用户提供系统调用服务。</p></blockquote><p>UNIX 文件分为四类：正规文件、目录文件、设备文件和管道文件。</p><blockquote><p>正规文件：存放程序、数据等（无格式的字符流文件，可按照自己的格式来解释文件）</p><p>目录文件：存放文件系统中各个目录信息的文件（字符流式文件，系统将其解释为文件目录，所有的目录文件构成整个 UNIX 文件系统的树状结构）</p><p>设备文件：代表一个物理设备，用户可以按处理正规文件的方式对其进行处理，但设备文件除了有关文件管理的信息外，并不占据实际的物理存储块</p><p>管道文件：用来存放管道数据。</p></blockquote></li><li><p>进程控制子系统</p><blockquote><p>进程是一个具有独立功能的程序对其所处理的数据在处理机上的执行过程。</p><p>(1) 进程的创建；</p><p>(2) 进程的调度；</p><p>(3) 进程间的通信；</p><p>(4) 进程间的同步控制。</p></blockquote></li><li><p>设备管理子系统</p><blockquote><p>完成进程和外设间数据交换的功能</p></blockquote></li><li><p>存储管理子系统</p><blockquote><p>(1) 管理内存的空闲空间；</p><p>(2) 对交换区空间（一般在磁盘上）进行管理；</p><p>(3) 对虚拟存储空间进行管理。</p><blockquote><p>物理内存空间是十分有限的。为了充分提高宝贵的内存的使用效率，UNIX 后期版本 只把进程的一小部分程序和数据放在内存中，而把剩余的程序和数据放在外存，然后采用 交换和请求调页的存储管理策略实现对内存的管理，提供用户比物理内存大得多的虚拟地 址空间。UNIX 的早期版本仅采用交换技术进行内存管理。</p></blockquote><blockquote><p><strong>交换技术</strong>：就是指当内存满了以后，就将一个程序从内存换出，将另一个程序放入内存，换出的内存数据保存在硬盘上，当该程序再次被换入的时候，就将硬盘上的数据拷贝到内存。</p></blockquote></blockquote></li></ol></li></ul><div id=2处理机管理 class=anchor>2.处理机管理></div><h1 class="relative group">2.处理机管理
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#2%e5%a4%84%e7%90%86%e6%9c%ba%e7%ae%a1%e7%90%86 aria-label=锚点>#</a></span></h1><blockquote><p>对处理机的管理就是对进程的管理，处理机分配和调度的对象大都是以进程为单位</p><p>传统的进程也可以看成是只有一个线程的进程</p></blockquote><div id=21-多道程序设计 class=anchor>2.1 多道程序设计></div><h2 class="relative group">2.1 多道程序设计
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#21-%e5%a4%9a%e9%81%93%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1 aria-label=锚点>#</a></span></h2><blockquote><p>所谓多道程序设计是指允许让多个计算问题同时装入一个计算机系统的主存储器，并允许它们共享资源、并发执行的程序设计技术。</p></blockquote><div id=211-单道程序的顺序执行 class=anchor>2.1.1 单道程序的顺序执行></div><h3 class="relative group">2.1.1 单道程序的顺序执行
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#211-%e5%8d%95%e9%81%93%e7%a8%8b%e5%ba%8f%e7%9a%84%e9%a1%ba%e5%ba%8f%e6%89%a7%e8%a1%8c aria-label=锚点>#</a></span></h3><p>程序的顺序执行有两个特点：</p><ol><li>封闭性：程序在运行时独占资源</li><li>可再现性：初始条件相同，则在何时执行结果都相同</li></ol><div id=212-多道程序的并发执行 class=anchor>2.1.2 多道程序的并发执行></div><h3 class="relative group">2.1.2 多道程序的并发执行
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#212-%e5%a4%9a%e9%81%93%e7%a8%8b%e5%ba%8f%e7%9a%84%e5%b9%b6%e5%8f%91%e6%89%a7%e8%a1%8c aria-label=锚点>#</a></span></h3><p>多道程序的特点：</p><ol><li>并发性：宏观上同时运行，微观上顺序执行</li><li>资源共享性</li><li>并发的程序相互制约</li><li>不确定性</li></ol><div id=22-进程的基本概念 class=anchor>2.2 进程的基本概念></div><h2 class="relative group">2.2 进程的基本概念
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#22-%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5 aria-label=锚点>#</a></span></h2><blockquote><p>程序是完成某一特定功能的指令序列，是一个静态的概念；而处理机的执行活动是程序的执行过程，是一个动态的概念。同一个程序，在一段时间内，可以多次被执行，而且是并发执行，这样这些并发执行的动态过程也无法简单地用程序加以区别。可见，<strong>程序这个静态的概念无法正确描述程序的动态执行情况，但是进程能很好地描述程序的并发执行</strong>， 这些是引入进程这个概念最重要的原因。</p></blockquote><div id=221-进程的定义 class=anchor>2.2.1 进程的定义></div><h3 class="relative group">2.2.1 进程的定义
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#221-%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%ae%9a%e4%b9%89 aria-label=锚点>#</a></span></h3><p>进程=程序+数据+执行</p><p>进程实体=程序段+相关的数据段+PCB</p><p>进程控制块（Process Control Block，简称 PCB），用于记录有关该进程的资料</p><p>进程分为<strong>系统进程</strong>和<strong>用户进程</strong>两类</p><blockquote><p>Windows 操作系统在初始化后，将自动产生诸如SMSS（对话管理）、LSASS（安全管理）、WINLOGON（登陆管理）、 explore（Windows 壳）等系统进程，之后用户可以创建新的用户进程。</p></blockquote><div id=222-进程的属性 class=anchor>2.2.2 进程的属性></div><h3 class="relative group">2.2.2 进程的属性
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#222-%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%b1%9e%e6%80%a7 aria-label=锚点>#</a></span></h3><ol><li>动态性。</li></ol><blockquote><ul><li><p>进程动态产生，动态执行，动态消亡；</p></li><li><p>进程有生命周期，而且在其生命周期内，进程的状态是动态变化的。</p></li></ul></blockquote><ol start=2><li>并发性。</li></ol><blockquote><p>这是指多个<strong>进程实体</strong>可<strong>同存于主存</strong>之中，且能在一个<strong>时间段</strong>内宏观上同时运行。</p></blockquote><ol start=3><li>独立性。</li></ol><blockquote><p>这是指进程实体是一个能够独立运行、独立分配资源和独立接收调度的基本单位，而且它有自己的程序计数器和内部状态。</p></blockquote><ol start=4><li>异步性。</li></ol><blockquote><p>这是指每个进程按各自独立的、不可预知的速度向前推进。</p></blockquote><ol start=5><li>交往性。</li></ol><blockquote><p>这是指一个进程在运行过程中可能会与其他进程发生直接的或者间接的相互作用。</p><p>进程之间可能要互斥地使用某些资源，相关进程之间可能需要必要的同步和通信等。</p></blockquote><div id=223进程与程序的关系 class=anchor>2.2.3进程与程序的关系></div><h3 class="relative group">2.2.3进程与程序的关系
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#223%e8%bf%9b%e7%a8%8b%e4%b8%8e%e7%a8%8b%e5%ba%8f%e7%9a%84%e5%85%b3%e7%b3%bb aria-label=锚点>#</a></span></h3><ol><li>考虑动态性</li></ol><blockquote><p>进程是程序的一次执行过程，进程是一个动态概念；</p><p>而程序是完成某个特定功能的指令的有序序列，即程序是一个静态概念。</p><p><strong>程序是代码的集合，而进程是程序的执行。</strong></p><p>程序可以作为一种软件资源长期保存，可以被复制，可以在不同的计算机上运行；</p><p>而进程，是有生命周期的，它动态地被创建，并被调度执行后消亡。</p></blockquote><ol start=2><li>考虑并发性</li></ol><blockquote><p>进程具有并发特征，而程序没有。由于一个进程可以与其他进程并发执行，即进程具有并发性；而程序并不反映执行过程，所以不具有并发特征。</p></blockquote><ol start=3><li>考虑资源</li></ol><blockquote><p>进程是系统进行资源分配和调度的一个独立单位，即资源分配是以进程为单位的，而不是以程序为单位的。</p></blockquote><ol start=4><li>考虑结构</li></ol><blockquote><p>程序的组成是代码，而进程实体的组成包括：程序、数据和 PCB。</p></blockquote><ol start=5><li>考虑生成性</li></ol><blockquote><p>进程可以生成其他进程，而程序则无法生成新的程序。</p></blockquote><ol start=6><li>考虑对应关系</li></ol><blockquote><p>一个程序多次执行可以对应多个进程；通过调用关系，一个进程也可以包括多个程序。</p></blockquote><div id=23-进程的状态及转换 class=anchor>2.3 进程的状态及转换></div><h2 class="relative group">2.3 进程的状态及转换
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#23-%e8%bf%9b%e7%a8%8b%e7%9a%84%e7%8a%b6%e6%80%81%e5%8f%8a%e8%bd%ac%e6%8d%a2 aria-label=锚点>#</a></span></h2><div id=231-进程的基本状态及转换 class=anchor>2.3.1 进程的基本状态及转换></div><h3 class="relative group">2.3.1 进程的基本状态及转换
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#231-%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%9f%ba%e6%9c%ac%e7%8a%b6%e6%80%81%e5%8f%8a%e8%bd%ac%e6%8d%a2 aria-label=锚点>#</a></span></h3><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/202301071515523.png alt=image-20230107151538117></figure></p><ul><li>共五种状态（三个基本状态）</li></ul><ol><li>初始态：进程刚被创建时，由于还没正式提交给操作系统的处理机调度程序对其进行管理，因此只能处于一个特殊的初始状态；</li><li>终止态：进程在执行结束后，将退出执行而被终止，此时也不受处理机调度程序的管理，即进程处于另一个特殊的状态——终止状态；</li><li><strong>执行态</strong>：进程在处理机上执行，即处于执行状态；</li><li><strong>就绪态</strong>：已经具备执行所需的所有必要条件，只要占用 CPU 就可以执行，但由于该进程使用CPU的时间太长，为了公平，把CPU让给别的进程使用；</li><li><strong>阻塞态</strong>：由于进程在运行过程中执行了某种阻塞操作（如读写），此时该进程用不到CPU，便将CPU交给别的进程使用，即进入了阻塞态。</li></ol><ul><li><p>每个进程在执行过程中（不包含初始状态和终止状态），任何时刻必须处在三个基本状态之一，而且只能处在三个基本状态之一（不能同时处于两个状态）。</p></li><li><p>进程的状态是如何转换的呢？</p></li></ul><ol><li>初始态变为就绪态：当操作系统完成对进程创建的必要操作后，相应的系统进程将进程的状态转换为就绪状态。</li><li>就绪态变为执行态：进程被处理机调度选中而<strong>获得处理机时</strong>，进程由就绪状态变为执行状态。</li><li>执行态变为阻塞态：这是由于执行进程自己的原因造成的，执行进程等待某个事件发生或者等待使用某种资源，此时进程无法继续执行直到等待的条件满足，这种情况下， 进程由执行态变为阻塞态。</li><li>阻塞态变为就绪态：事件完成，即资源得到满足或者等待的事件已经发生，此时进程由阻塞态变为就绪态，等待再次被处理机调度选中执行。</li><li>执行态变为就绪态：处于执行态的进程被剥夺处理机时引起的，通常与调度策略有关，比如运行时间片已到或者出现更高优先级的进程等，此时，进程由执行态变为就绪态。</li><li>执行态变为终止态：当一个进程完成任务自然结束，或是出现了无法克服的错误， 或是被操作系统或其他进程所终结时，进程由执行态变为终止态。</li></ol><div id=232-具有挂起功能的进程状态及转换 class=anchor>2.3.2 具有挂起功能的进程状态及转换></div><h3 class="relative group">2.3.2 具有挂起功能的进程状态及转换
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#232-%e5%85%b7%e6%9c%89%e6%8c%82%e8%b5%b7%e5%8a%9f%e8%83%bd%e7%9a%84%e8%bf%9b%e7%a8%8b%e7%8a%b6%e6%80%81%e5%8f%8a%e8%bd%ac%e6%8d%a2 aria-label=锚点>#</a></span></h3><blockquote><p>随着系统的运行，更多的进程被不断创建，当系统资源不能满足进程运行的需求时， 系统须把某些进程对换到磁盘中，暂时不让其参与进程调度，以达到平滑系统负荷的目的， 这个过程称为“<strong>挂起</strong>”。</p></blockquote><ul><li>引起进程挂起的原因：</li></ul><ol><li>运行需要：<strong>内存中的进程均处于阻塞态，而处理机空闲</strong>，此时需要把一些阻塞进程挂起（即<strong>对换</strong>出去），以腾出内存空间装入就绪进程，使之运行；</li><li>调节负荷的需要：由于进程竞争资源而导致系统的资源不足或负荷过重，此时，需要挂起部分不太重要的进程，以调节系统负荷，以保证系统的正常运行（需要说明的是： 系统也可能把一些<strong>定期执行</strong>的进程，如监控程序、审计程序、记账程序等对换出去，以减轻系统的负荷）；</li><li>用户请求：用户请求挂起自己的进程，以便分析其执行情况，或根据中间执行情况 进行其他处理；</li><li>父进程要求：父进程可以要求挂起自己的某个子进程，以便对该子进程进行考察、 分析或修改，或者协调各个子进程的运行；</li><li>操作系统需要：第一，当系统出现故障或某些功能受到破坏时，系统需要挂起某些进程以检测和排除故障；第二，有时系统因需要检查运行过程中的资源使用情况而挂起某些进程。</li></ol><ul><li>新增的两个状态：</li></ul><ol><li>静止就绪态：表明进程具备运行条件，但目前<strong>进程不在主存</strong>中而是处于被挂起状态，只有当它被对换到主存中才能被调度执行；</li><li>静止阻塞态：表明进程在等待某一事件，且<strong>进程不在主存中</strong>。</li></ol><ul><li>具有挂起功能的进程状态转换图</li></ul><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/202301071521734.png alt=image-20230107152116537></figure></p><p>状态转换详解</p><ol><li>活跃阻塞态挂起变为静止阻塞态：</li></ol><blockquote><ul><li>若当前不存在活跃就绪进程，则至少有一个活跃阻塞进程将被对换出去成为静止阻塞进程;</li><li>操作系统依据当前的资源状况和性能要求，可以将某些活跃阻塞进程对换出去成为静止阻塞进程；</li></ul></blockquote><ol start=2><li>静止阻塞态激活变为活跃阻塞态：</li></ol><blockquote><ul><li>操作系统已经得知导致进程阻塞的事件即将结束；</li><li>内存中已经有了一大块自由空间；</li></ul></blockquote><ol start=3><li>静止阻塞态变为静止就绪态：</li></ol><blockquote><ul><li>事件完成，即资源得到满足或者等待的事件已经发生；</li></ul></blockquote><ol start=4><li>静止就绪态激活变为活跃就绪态：</li></ol><blockquote><ul><li>当静止就绪态进程具有比活跃就绪态进程更高的优先级；</li><li>内存中已经有了一大块自由空间；</li><li>当内存中没有活跃就绪态进程；</li></ul></blockquote><ol start=5><li>活跃就绪态挂起变为静止就绪态：</li></ol><blockquote><ul><li>这种状态变化主要是由于系统调节负荷的需要， 或者是系统优化性能的需求。</li></ul></blockquote><blockquote><p>可见，只有处于活跃就绪态的进程在得到 CPU 后才能立即投入执行，而处于静止就绪态的进程只有先成为活跃就绪态后，才可能被选中调度执行。这种方式虽然提高了内存的利用效率，但同时也使得管理更加复杂且增加了系统开销。</p></blockquote><div id=24-作业的基本概念 class=anchor>2.4 作业的基本概念></div><h2 class="relative group">2.4 作业的基本概念
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#24-%e4%bd%9c%e4%b8%9a%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5 aria-label=锚点>#</a></span></h2><div id=241-作业的定义 class=anchor>2.4.1 作业的定义></div><h3 class="relative group">2.4.1 作业的定义
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#241-%e4%bd%9c%e4%b8%9a%e7%9a%84%e5%ae%9a%e4%b9%89 aria-label=锚点>#</a></span></h3><blockquote><p>把一次计算（或事务处理）过程中，从输入开始到输出结束，用户要求计算机所做的关于该次计算（或事务处理）的全部工作，称为一个作业。</p><p>在批处理系统中，作业是抢占内存的基本单位。</p><p>作业是否成功建立要看是否加入了作业表表项</p></blockquote><ul><li><p>从用户的角度</p><blockquote><ul><li><p>作业=程序+数据+作业说明书</p><blockquote><p><strong>作业说明书</strong>：表达用户对作业的控制意图，一般由用户使用某种作业控制语言来书写</p><p>包含三个方面的内容：</p><ol><li>作业的基本描述</li><li>作业的控制描述</li><li>作业的资源需求描述。</li></ol></blockquote></li><li><p><strong>作业步</strong>：用户把要求计算机系统做的每一项相对独立的工作称为一个作业步。</p><blockquote><p>作业步之间相互独立却又有联系。</p></blockquote></li></ul></blockquote></li><li><p>从系统的角度</p><blockquote><ul><li><p>作业=多个程序+多份数据+作业控制块 JCB（Job Control Block）</p><blockquote><ul><li><p><strong>JCB</strong>：操作系统通过 JCB 来控制程序和数据，为其分配资源，使之执行并对其进行操作。</p></li><li><p>JCB 包括的主要内容有：</p><ol><li>作业名</li><li>作业状态</li><li>资源需求</li><li>作业类型</li><li>作业控制方式</li><li>作业优先权</li></ol></li><li><p><strong>作业表</strong>：为了对作业进行管理，操作系统将所有作业的 JCB 构成一张表，称为作业表。</p><blockquote><p>作业表一般存放在外存的固定区域中，而且其<strong>长度是固定的</strong>，即系统能同时容纳的作业数量是有限的。</p></blockquote></li><li><p>**输入作业流 **：当有若干个作业被成功创建，进入系统，被依次存放在外存上，这就形成了输入的作业流；</p></li><li><p><strong>处理作业流</strong>：当输入作业流在操作系统的控制下，逐个作业进行处理，这称为处理作业流。</p></li></ul></blockquote></li></ul></blockquote></li></ul><div id=242-作业与进程的关系 class=anchor>2.4.2 作业与进程的关系></div><h3 class="relative group">2.4.2 作业与进程的关系
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#242-%e4%bd%9c%e4%b8%9a%e4%b8%8e%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%85%b3%e7%b3%bb aria-label=锚点>#</a></span></h3><blockquote><p>作业的处理依赖于进程：计算机为了处理一个作业，首先，操作系统为该作业创建一个根进程；然后，在执行作业控制语句时，根据作业说明书的要求， 由系统或根进程为该作业创建相应的子进程；之后，系统为各个子进程分配资源，并调度各子进程执行以完成作业的要求。</p></blockquote><ul><li><p>作业与进程之间的区别</p><ol><li><p>本质</p><blockquote><p>作业就是用户要求计算机完成的一项任务；</p><p>进程是系统为了完成作业而设置的动态执行体。</p></blockquote></li><li><p>资源</p><blockquote><p>作业中的作业说明书事先说好了资源的分配关系，这是静态的；</p><p>进程是操作系统分配资源的基本单位，这是动态的。</p></blockquote></li><li><p>作业和进程的对应关系</p><blockquote><p>一个进程对应一个作业</p><p>一个作业需要多个进程</p></blockquote></li></ol></li></ul><div id=243-作业的状态及转换 class=anchor>2.4.3 作业的状态及转换></div><h3 class="relative group">2.4.3 作业的状态及转换
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#243-%e4%bd%9c%e4%b8%9a%e7%9a%84%e7%8a%b6%e6%80%81%e5%8f%8a%e8%bd%ac%e6%8d%a2 aria-label=锚点>#</a></span></h3><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/202301071521040.png alt=image-20230107152144842></figure></p><ul><li><p>共四种状态</p><ol><li><p>提交态：作业由输入设备进入外存储器（也称输入井）的过程称为提交态。处于提交态的作业，其信息<strong>正在进入</strong>系统。</p><blockquote><p>可以有两种输入方式：</p><ol><li>作业由用户直接通过<strong>终端</strong>键盘向计算机中输入其作业；</li><li>将作业提交给操作员，并由操作员利用<strong>输入设备</strong>进行输入。</li></ol></blockquote></li><li><p>后备态：作业的<strong>全部信息</strong>都已进入输入井，并且<strong>作业控制块 JCB</strong>已经创建，此时称作业处于后备状态。</p><blockquote><p>其中，系统为该作业建立 JCB， 并把它加入到后备作业队列的过程称为<strong>作业注册</strong>。</p></blockquote></li><li><p>运行态：一个处于后备态的作业，一旦被作业调度程序选中而被<strong>送入内存</strong>中，并<strong>分配相应的资源</strong>而一组与该作业对应的<strong>进程建立</strong>后，该作业就进入了运行态。</p><blockquote><p>与作业相对应的进程，刚被创建时处于就绪状态（并非初始态），等待进程调度，参与处理机竞争，并按进程的状态转换方式转换状态。</p></blockquote></li><li><p>完成态：当作业终止，但作业所占用的资源尚未全部被系统回收时的状态称为完成态。</p><blockquote><p>作业终止可能有两种方式：</p><ol><li>正常运行结束；</li><li>因发生错误而终止。资源需要回收，等待系统收拾烂摊子。</li></ol></blockquote></li></ol></li></ul><div id=25-进程的描述与上下文 class=anchor>2.5 进程的描述与上下文></div><h2 class="relative group">2.5 进程的描述与上下文
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#25-%e8%bf%9b%e7%a8%8b%e7%9a%84%e6%8f%8f%e8%bf%b0%e4%b8%8e%e4%b8%8a%e4%b8%8b%e6%96%87 aria-label=锚点>#</a></span></h2><blockquote><p>进程实体=程序段+相关的数据段+PCB</p><p>进程控制块（PCB）是进程实体的一部分，是操作系统为了描述和控制动态的进程及其运行而为进程定义的一种<strong>数据结构</strong>。它是<strong>进程存在的惟一标志</strong>，进程的 PCB 都是全部或部分<strong>常驻内存</strong>的，<strong>程序和数据</strong>集放在外存中，直到该进程执行时再调入内存。</p></blockquote><div id=251-进程控制块-pcb class=anchor>2.5.1 进程控制块 PCB></div><h3 class="relative group">2.5.1 进程控制块 PCB
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#251-%e8%bf%9b%e7%a8%8b%e6%8e%a7%e5%88%b6%e5%9d%97-pcb aria-label=锚点>#</a></span></h3><ul><li><p>PCB 的作用</p><ol><li><p>提供了进程的描述信息、控制信息和资源信息等（几乎是管理进程的所有信息）</p></li><li><p>标识进程的存亡。</p><blockquote><p>进程创建时，操作系统为其创建PCB，当进程消亡时，操作系统回收其PCB</p></blockquote></li><li><p>操作系统是根据 PCB 来对并发执行的进程进行管理和控制的。</p><blockquote><p>正是由于 PCB 的存在，才使得进程成为一个能独立运行的基本单位，才使得进程能与其他进程并发执行。</p></blockquote></li></ol></li><li><p>PCB 中的信息</p><ol><li><p>进程标识符。</p></li><li><p>进程的当前状态。</p><blockquote><p>仅当进程处于就绪状态时，才可能被调度执行。</p><p>若进程处于阻塞状态，还需要在 PCB 中<strong>记录阻塞的原因</strong>，以供<strong>唤醒原语</strong>唤醒进程时用。</p></blockquote></li><li><p>进程相应的程序和数据地址。</p><blockquote><p>将 PCB 与其程序和数据联系起来。</p></blockquote></li><li><p>进程资源清单。</p><blockquote><p>列出进程所拥有的除了处理机之外的资源记录，如打开的文件列 表，拥有的 I/O 设备等。</p></blockquote></li><li><p>进程优先级。</p><blockquote><p>通常是一个表示进程使用 CPU 的优先级别的整数。</p></blockquote></li><li><p>CPU 现场保护区。</p><blockquote><p>当进程因某种原因不能继续占用 CPU 时，需要将 CPU 的各种状态信息保护起来。</p><p>被保护的 CPU 现场信息通常有：程序状态字 PSW、程序计数器的内容、 通用寄存器的内容和用户栈的指针等。</p></blockquote></li><li><p>进程同步和通信机制。</p><blockquote><p>用于实现进程之间的互斥、同步和通信所需的信号量、信箱或消息队列的指针等。</p></blockquote></li><li><p>进程所在队列的 PCB 的连接字。</p><blockquote><p>进程 PCB 根据进程的当前状态，插入到不同的队列中。PCB 连接字指出该进程所在队列中下一个进程 PCB 的首地址。</p></blockquote></li><li><p>与进程相关的其他信息。</p><blockquote><p>如进程的家族信息、进程所属的用户、进程占用 CPU 的时间、进程记账信息等。</p></blockquote></li></ol></li></ul><div id=252-进程上下文 class=anchor>2.5.2 进程上下文></div><h3 class="relative group">2.5.2 进程上下文
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#252-%e8%bf%9b%e7%a8%8b%e4%b8%8a%e4%b8%8b%e6%96%87 aria-label=锚点>#</a></span></h3><ol><li><p>进程上下文</p><blockquote><ul><li>操作系统中把<strong>进程实体</strong>和<strong>支持进程运行的环境</strong>合称为进程上下文（process context）。</li><li>一个进程的上下文的结构一般由以下几个部分构成：<ul><li>PCB</li><li>正文段（即程序段经过编译后形成的机器指令代码集）和数据段</li><li>与该进程有关的各种寄存器和堆栈的值</li></ul></li><li><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/202203290847564.png alt=进程上下文结构></figure></li></ul></blockquote></li><li><p>进程上下文切换</p><blockquote><p>步骤：</p><ol><li>状态保存（state save）</li><li>选取新进程</li><li>状态恢复（state restore）</li></ol></blockquote></li></ol><div id=26-进程的控制 class=anchor>2.6 进程的控制></div><h2 class="relative group">2.6 进程的控制
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#26-%e8%bf%9b%e7%a8%8b%e7%9a%84%e6%8e%a7%e5%88%b6 aria-label=锚点>#</a></span></h2><blockquote><p>创建、删除进程；进程状态转换；进程通信</p><p>达到在多个进程之间同步和高效并发执行的同时，也实现资源的共享和协调。</p></blockquote><div id=261-进程控制机构 class=anchor>2.6.1 进程控制机构></div><h3 class="relative group">2.6.1 进程控制机构
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#261-%e8%bf%9b%e7%a8%8b%e6%8e%a7%e5%88%b6%e6%9c%ba%e6%9e%84 aria-label=锚点>#</a></span></h3><blockquote><p>进程的控制由操作系统的内核完成</p></blockquote><ol><li><p>什么是操作系统的内核</p><blockquote><ul><li><p>操作系统的内核由一些与硬件密切相关的模块，以及共用的基本操作构成；</p></li><li><p>内核常驻内存，并给予特殊保护（核心态）；</p></li><li><p>内核包含支撑功能（中断处理、时钟处理、原语操作）和资源管理功能（括进程管理、存储器管理、文件管理和设备管理）；</p></li></ul></blockquote></li><li><p>.内核中与进程控制紧密相关的机构</p><blockquote><ul><li><p>进程管理</p><blockquote><p>将进程管理放在内核的原因</p><ol><li>进程管理的相关模块的运行频率较高</li><li>它们被多种功能模块所调用</li></ol></blockquote></li><li><p>原语操作</p><blockquote><ul><li><p>操作系统使用系统原语实现对进程状态改变的控制。</p></li><li><p>原语是不可分割的，是机器指令的延伸</p></li><li><p>对用户透明，但可以当做一类特殊的系统调用</p></li></ul></blockquote></li></ul></blockquote></li></ol><div id=262-进程控制原语 class=anchor>2.6.2 进程控制原语></div><h3 class="relative group">2.6.2 进程控制原语
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#262-%e8%bf%9b%e7%a8%8b%e6%8e%a7%e5%88%b6%e5%8e%9f%e8%af%ad aria-label=锚点>#</a></span></h3><blockquote><p>创建原语、撤销原语、阻塞原语和唤醒原语。</p></blockquote><ol><li><p>进程创建原语</p><blockquote><ul><li><p>进程可以通过调用进程创建原语来创建子进程，子子孙孙创建下去就构成了<strong>家族关系</strong></p></li><li><p>进程创建原语的主要操作步骤：</p><blockquote><ol><li>向系统申请一个空闲的 PCB：扫描空闲PCB表项，获得该PCB的内部名称作为新进程的标识号PID；</li><li>为新进程分配各种资源；</li><li>初始化新进程 PCB 的内容：PCB 中填入进程名、家族信息、数据和程序地址、进程优先级、资源清单以及进程状态（就绪态）等信息；</li><li>将新进程的 PCB 插入到就绪队列。</li></ol></blockquote></li></ul></blockquote></li><li><p>进程撤销原语</p><blockquote><ul><li><p>进程撤销的原因</p><blockquote><ol><li>进程完成任务而正常撤销</li><li>进程由于出现某些故障或错误而被迫撤销。</li></ol></blockquote></li><li><p>两种撤销策略</p><blockquote><ol><li>只撤销指定进程</li><li>撤销指定进程及其子孙进程</li></ol></blockquote></li><li><p>撤销指定进程及其子孙进程的操作步骤</p><blockquote><ol><li>从系统的 PCB 表中检索出被撤销进程的 PCB，并从中读出该进程的状态，设置重新调度标志，以便在该进程撤销后将 CPU 分配给其他的进程；；</li><li>如果正处在执行态，则立即终止，设置重新调度标志；</li><li>检查子孙进程，递归终止；</li><li>递归回收被终止进程的全部资源：把属于父进程的资源归还给父进程，属于自己申请的资源则归还系统，注销其资源描述清单；</li><li>递归释放被终止进程的PCB</li><li>如果重新调度标志为真，则转到进程调度程序。</li></ol></blockquote></li></ul></blockquote></li><li><p>进程阻塞原语</p><blockquote><ul><li><p>调用该原语的进程由执行态变为阻塞态。</p></li><li><p>什么时候要将进程的执行态转变为阻塞态？</p><blockquote><ol><li>当进程请求某事件尚未发生，主动放弃处理机</li></ol></blockquote></li><li><p>操作步骤</p><blockquote><ol><li>停止调用者自身执行</li><li>保存断点信息</li><li>设置自己的状态为阻塞态</li><li>将自己的PCB插入相应事件的等待队列</li><li>转进程调度程序，从就绪队列中选择新的进程投入运行</li></ol></blockquote></li></ul></blockquote></li><li><p>进程唤醒原语</p><blockquote><ul><li><p>发现者将一个被唤醒的进程的状态由阻塞态变为就绪态。</p></li><li><p>什么时候要将进程的阻塞态转变为就绪态？</p><blockquote><ol><li>等待的资源得到满足</li></ol></blockquote></li><li><p>操作步骤</p><blockquote><ol><li><p>找出标识</p></li><li><p>从阻塞队列移出</p></li><li><p>设置为就绪态</p></li><li><p>插入就绪队列</p></li><li><p>考虑被唤醒进程和当前运行进程的优先级</p><blockquote><p>若被唤醒进程优先级更高则需要设置调度标志，并转进程调度程序。</p></blockquote></li></ol></blockquote></li></ul></blockquote></li></ol><div id=27-线程 class=anchor>2.7 线程></div><h2 class="relative group">2.7 线程
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#27-%e7%ba%bf%e7%a8%8b aria-label=锚点>#</a></span></h2><blockquote><p>比进程更小的能独立运行的基本单位</p></blockquote><div id=271-线程的概念 class=anchor>2.7.1 线程的概念></div><h3 class="relative group">2.7.1 线程的概念
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#271-%e7%ba%bf%e7%a8%8b%e7%9a%84%e6%a6%82%e5%bf%b5 aria-label=锚点>#</a></span></h3><blockquote><ul><li><p>什么是线程？</p><ol><li>是由进程进一步派生出来的一组代码的执行过程;</li><li>是进程中相对独立的一个执行流；</li><li>是系统独立调度的基本单位。</li></ol></li><li><p>为什么系统引入线程可以提高效率和并发性？</p><ol><li>线程继承共享所属进程的一切资源；</li><li>线程本身运行只需要很少一部分资源；</li><li>所以线程切换的开销比进程小得多。</li></ol></li><li><p>什么时候线程不应该引入？</p><ol><li>实时系统（进程调度少）</li><li>个人数字助理系统</li><li>任务单一的系统</li></ol></li><li><p>传统进程 和 多线程环境中的进程的区别</p><ol><li><p>传统的进程管理资源和指令的执行，多线程环境中的进程只负责资源分配和保护，线程负责执行任务；</p></li><li><p>每个线程都有独立的系统堆栈和用户堆栈</p><blockquote><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/202204041953735.png alt=image-20220404195338628></figure></p></blockquote></li><li><p>线程控制块（Thread Control Block，简称 TCB）是标志一个线程存在的数据结构，与 PCB 相比，TCB 中的内容较少，因为PCB还需要记录资源分配信息。</p></li></ol></li></ul></blockquote><div id=272-线程与进程的关系 class=anchor>2.7.2 线程与进程的关系></div><h3 class="relative group">2.7.2 线程与进程的关系
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#272-%e7%ba%bf%e7%a8%8b%e4%b8%8e%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%85%b3%e7%b3%bb aria-label=锚点>#</a></span></h3><p>线程和进程的比较</p><blockquote><ul><li><p>资源</p><blockquote><p>进程可以拥有自己的资源</p><p>线程可以访问进程的资源</p></blockquote></li><li><p>调度</p><blockquote><p>线程是调度的基本单位</p></blockquote></li><li><p>并发性</p><blockquote><p>两者都可以并发执行</p></blockquote></li><li><p>系统开销</p><blockquote><p>进程大于线程</p></blockquote></li><li><p>安全性</p><blockquote><p>进程比线程安全</p><p>因为，同一个进程下的多个线程可以共享进程的资源，会发生数据篡改并导致错误</p></blockquote></li></ul></blockquote><div id=273-线程的实现 class=anchor>2.7.3 线程的实现></div><h3 class="relative group">2.7.3 线程的实现
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#273-%e7%ba%bf%e7%a8%8b%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label=锚点>#</a></span></h3><blockquote><ol><li><p>用户级线程（User-Level Thread，简称 ULT）</p><blockquote><ul><li><p>在用户空间，由应用程序在<strong>线程库</strong>（的支持下完成，系统内核不知道线程的存在；</p></li><li><p>线程库是一组可供所有的应用程序共享的应用级软件包，它可以创建线程、销毁线程、支持线程通信、支持线程调度、保存和恢复线程上下文。（相当于用户级的操作系统）</p></li><li><p>线程的 TCB 保存在用户空间，并由线程库维护，线程的建立也需由线程库在同一个进程内创建一个新线程。</p></li><li><p>优点：</p><ul><li>灵活。不依赖于操作系统，可以采取与应用程序相适应的线程调度策略。</li><li>效率高。不用陷入操作系统内核。</li></ul></li><li><p>缺点：</p><ul><li>无法并行。内核一次最多只给一个进程分配处理机，而所有线程均依赖于这个处理机。</li><li>会导致进程堵塞。一个线程未满足，则整个进程受阻。</li></ul></li></ul></blockquote></li><li><p>内核级线程（Kernel-Level Thread，简称 KLT）</p><blockquote><ul><li>与线程有关的工作通过系统调用交给操作系统内核处理</li><li>TCB存于操作系统空间</li><li>KLT是处理机调度的基本单位</li><li>优点：<ul><li>并发性好。</li><li>通常不会导致进程堵塞</li></ul></li><li>缺点：<ul><li>系统开销大。因为要在内核和用户两种模式切换。</li><li>系统内核空间容易被迅速耗尽。因为线程的数量远远大于进程的，因此操作系统会限制一个应用所创建的进程。</li></ul></li></ul></blockquote></li><li><p>组合线程或混合线程（hybrid thread）</p><blockquote><ul><li><p>组合线程通常还需要一个用户和系统都可见的中间实体，用于在用户级线程和内核级线程之间<strong>建立联系</strong>。 在 <strong>Solaris 系统</strong>中称该中间实体为<strong>轻进程</strong>。</p></li><li><p>每一个中间实体都与一个内核级线程相对应</p></li><li><table><thead><tr><th style=text-align:center></th><th style=text-align:center>线程0</th><th style=text-align:center>轻进程0</th><th style=text-align:center>内核线程0</th></tr></thead><tbody><tr><td style=text-align:center>进程66</td><td style=text-align:center>线程1</td><td style=text-align:center>轻进程1</td><td style=text-align:center>内核线程1</td></tr><tr><td style=text-align:center></td><td style=text-align:center>线程2</td><td style=text-align:center>轻进程2</td><td style=text-align:center>内核线程2</td></tr></tbody></table></li><li><p>如果设计合理的话，组合线程机制能结合前两类线程的优点，并克服其缺点。</p></li></ul></blockquote></li></ol></blockquote><div id=28-处理机调度原理 class=anchor>2.8 处理机调度原理></div><h2 class="relative group">2.8 处理机调度原理
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#28-%e5%a4%84%e7%90%86%e6%9c%ba%e8%b0%83%e5%ba%a6%e5%8e%9f%e7%90%86 aria-label=锚点>#</a></span></h2><blockquote><p>处理机调度就是指CPU资源在可运行实体之间的分配</p><p>调度的实质：资源分配</p></blockquote><div id=281-处理机的四级调度 class=anchor>2.8.1 处理机的四级调度></div><h3 class="relative group">2.8.1 处理机的四级调度
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#281-%e5%a4%84%e7%90%86%e6%9c%ba%e7%9a%84%e5%9b%9b%e7%ba%a7%e8%b0%83%e5%ba%a6 aria-label=锚点>#</a></span></h3><blockquote><ol><li><p>作业调度</p><blockquote><ul><li>对象：作业</li><li>输入井 &ndash;> 内存</li><li>后备态 &ndash;> 运行态 &ndash;> 完成态</li><li>作业调度程序只负责控制，实际的存储和设备管理由相应的管理程序完成</li></ul></blockquote></li><li><p>交换调度、中级调度</p><blockquote><ul><li><p>对象：进程</p></li><li><p>功能：短期平滑和调整系统负荷</p></li><li><p>外存 &lt;&ndash;> 内存</p></li><li><p>激活：静止就绪态/静止阻塞态 &ndash;> 活跃就绪态/活跃阻塞态</p></li><li><p>挂起：活跃就绪态/活跃阻塞态 &ndash;> 静止就绪态/静止阻塞态</p></li><li><p>实质：存储管理中的对换功能，涉及内存的管理和扩充</p></li><li><p>问：并发的程度是不是越高越好？不是</p><blockquote><ol><li>切换进程和线程，系统开销大；</li><li>主存有限</li><li>资源竞争激烈，导致死锁</li></ol></blockquote></li></ul></blockquote></li><li><p>进程调度、低级调度</p><blockquote><ul><li>对象：进程</li><li>内存 &lt;&ndash;> 内存</li><li>活跃就绪态 &ndash;> 执行态</li><li>与前两种最大不同：被选中的进程能够实际获得CPU</li><li>运行频率很高并且需要常驻内存，因此算法时间复杂度不能太高</li></ul></blockquote></li><li><p>线程调度</p><blockquote><ol><li><p>内核级线程调度</p><blockquote><ul><li>内核级线程调度和进程调度的主要区别：在同一个进程内的内核级线程切换不会引起资源的切换</li></ul></blockquote></li><li><p>用户级线程调度</p><blockquote><ul><li>操作系统在设计时不需要考虑用户级线程</li></ul></blockquote></li></ol></blockquote></li></ol></blockquote><div id=282-处理机调度的目标 class=anchor>2.8.2 处理机调度的目标></div><h3 class="relative group">2.8.2 处理机调度的目标
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#282-%e5%a4%84%e7%90%86%e6%9c%ba%e8%b0%83%e5%ba%a6%e7%9a%84%e7%9b%ae%e6%a0%87 aria-label=锚点>#</a></span></h3><ol><li><p>提高系统资源利用率</p><blockquote><p>使各个部件均忙碌</p></blockquote></li><li><p>提高系统吞吐量，降低平均周转时间</p></li><li><p>降低平均响应时间</p></li><li><p>提供相对的公平机制</p></li><li><p>其他</p><blockquote><ul><li>考虑优先级</li><li>使系统重要参数有可预测性</li></ul></blockquote></li></ol><div id=283-处理机调度的方式 class=anchor>2.8.3 处理机调度的方式></div><h3 class="relative group">2.8.3 处理机调度的方式
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#283-%e5%a4%84%e7%90%86%e6%9c%ba%e8%b0%83%e5%ba%a6%e7%9a%84%e6%96%b9%e5%bc%8f aria-label=锚点>#</a></span></h3><ol><li><p>非抢占（non preemptive scheduling mode）</p><blockquote><ul><li>优点：<ol><li>简单</li><li>系统开销小</li></ol></li><li>缺点：<ol><li>不考虑优先级，会延误时机；</li><li>导致短作业的周转时间增加；</li></ol></li></ul></blockquote></li><li><p>抢占</p><blockquote><ul><li>常见剥夺原则：<ol><li>时间片原则</li><li>优先级原则</li><li>短作业优先原则</li></ol></li><li>优点：<ol><li>保证并发性</li><li>保证响应及时性</li></ol></li><li>缺点：<ol><li>实现复杂</li><li>系统开销大，影响性能</li></ol></li></ul></blockquote></li></ol><div id=284-处理机调度的时机 class=anchor>2.8.4 处理机调度的时机></div><h3 class="relative group">2.8.4 处理机调度的时机
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#284-%e5%a4%84%e7%90%86%e6%9c%ba%e8%b0%83%e5%ba%a6%e7%9a%84%e6%97%b6%e6%9c%ba aria-label=锚点>#</a></span></h3><p>什么时候会引起调度程序工作？</p><blockquote><p>中断是调度的前提，但不是发生中断就一定会调度。</p><ol><li>发生请求，并等待（如：IO）</li><li>进程执行结束</li><li>发生错误</li><li>执行原语</li><li>优先级更高抢占处理机</li><li>时间片用完</li></ol></blockquote><div id=29-调度算法 class=anchor>2.9 调度算法></div><h2 class="relative group">2.9 调度算法
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#29-%e8%b0%83%e5%ba%a6%e7%ae%97%e6%b3%95 aria-label=锚点>#</a></span></h2><blockquote><p>资源分配算法</p><p>批处理系统目标：提高吞吐量</p><p>分时系统：响应时间和公平性</p><p>实时系统：及时响应</p></blockquote><div id=290-调度算法的评价指标 class=anchor>2.9.0 调度算法的评价指标></div><h3 class="relative group">2.9.0 调度算法的评价指标
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#290-%e8%b0%83%e5%ba%a6%e7%ae%97%e6%b3%95%e7%9a%84%e8%af%84%e4%bb%b7%e6%8c%87%e6%a0%87 aria-label=锚点>#</a></span></h3><p>CPU\IO设备利用率=忙碌时间\总时间</p><p>系统吞吐量=总共完成的作业数\总共使用的时间</p><p>周转时间=作业完成时间-作业提交时间</p><p>平均周转时间=各作业周转时间之和\作业数</p><p>带权周转时间=作业周转时间\作业实际运行的时间 >=1 越小越好</p><p>平均带权周转时间=各作业的带权周转时间之和\作业数</p><p>等待时间=等待处理机状态时间之和（正在等待IO设备完成的期间其实进程也是在被服务的，所以不计入等待时间）</p><p>响应时间=从用户首次提交请求到首次产生响应所用的时间</p><p>响应比=（等待时间+要求服务时间）\ 要求服务时间</p><div id=291-先来先服务first-come-first-serve class=anchor>2.9.1 先来先服务（First Come First Serve）></div><h3 class="relative group">2.9.1 先来先服务（First Come First Serve）
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#291-%e5%85%88%e6%9d%a5%e5%85%88%e6%9c%8d%e5%8a%a1first-come-first-serve aria-label=锚点>#</a></span></h3><blockquote><ul><li>优点：
1. 简单
2. 公平
3. 不会饥饿</li><li>缺点：<ol><li>容易使短作业感到不满</li></ol></li></ul></blockquote><div id=292-最短周期优先-shortest-jobprocess-first class=anchor>2.9.2 最短周期优先 （Shortest Job/Process First）></div><h3 class="relative group">2.9.2 最短周期优先 （Shortest Job/Process First）
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#292-%e6%9c%80%e7%9f%ad%e5%91%a8%e6%9c%9f%e4%bc%98%e5%85%88-shortest-jobprocess-first aria-label=锚点>#</a></span></h3><blockquote><ul><li><p>优点：</p><ol><li>简单</li><li>平均周转时间最短</li></ol></li><li><p>缺点：</p><ol><li>作业或进程的执行时间无法预知</li><li>对长作业不利，可能饥饿</li></ol></li><li><p>改进：最短剩余时间优先算法SRTN</p><blockquote><p>比较进程所需要的剩余时间，更少时间的抢占处理机。</p></blockquote></li></ul></blockquote><div id=293-最高优先级优先highest-priority-first class=anchor>2.9.3 最高优先级优先（Highest Priority First）></div><h3 class="relative group">2.9.3 最高优先级优先（Highest Priority First）
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#293-%e6%9c%80%e9%ab%98%e4%bc%98%e5%85%88%e7%ba%a7%e4%bc%98%e5%85%88highest-priority-first aria-label=锚点>#</a></span></h3><ol><li><p>静态优先级</p><blockquote><ul><li>调度对象在进入系统时便被赋予一个固定的优先级</li><li>优点：<ol><li>简单</li><li>系统开销小</li></ol></li><li>缺点：<ol><li>不公平</li><li>不灵活</li></ol></li></ul></blockquote></li><li><p>动态优先级</p><blockquote><ul><li>优先级动态调整<ul><li>当进程获得某种资源时，其优先级被动态提高，以便能更快获得处理机投入执行，以避免资源的浪费；</li><li>当进程处于就绪状态时，其优先级随着等待处理器的时间的增长而提高，而占有处理机的进程的优先级则随着它使用处理机的时间的增长而降低，以保证公平性等。</li><li>IO繁忙型进程可以适当提高优先级，这样可以尽早地让IO设备投入工作</li></ul></li><li>优点：<ol><li>公平</li><li>灵活</li><li>资源利用率高</li><li>防止饥饿</li></ol></li><li>缺点：
1. 复杂
1. 系统开销大</li></ul></blockquote></li></ol><div id=294-时间片轮转法round-robin class=anchor>2.9.4 时间片轮转法（Round Robin）></div><h3 class="relative group">2.9.4 时间片轮转法（Round Robin）
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#294-%e6%97%b6%e9%97%b4%e7%89%87%e8%bd%ae%e8%bd%ac%e6%b3%95round-robin aria-label=锚点>#</a></span></h3><ol><li><p>固定时间片轮转</p><blockquote><p>需要定时时钟，时间片使用完后发生中断，进入调度程序，选择下一个进程占有处理机</p></blockquote></li><li><p>可变时间片轮转</p><blockquote><p>需要定时时钟，但是时钟中断处理程序每次需要设置新的时钟常量，然后才转入处理机调度程序，选择下一个进程占有处理机。</p><ul><li>优点：<ol><li>公平</li><li>灵活</li><li>响应及时</li></ol></li><li>缺点：
1. 复杂
2. 系统开销大
3. 对偏重 I/O 的进程处理不太公平。</li></ul></blockquote></li></ol><div id=295--多级反馈队列 class=anchor>2.9.5 多级反馈队列></div><h3 class="relative group">2.9.5 多级反馈队列
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#295--%e5%a4%9a%e7%ba%a7%e5%8f%8d%e9%a6%88%e9%98%9f%e5%88%97 aria-label=锚点>#</a></span></h3><p>设计原则</p><blockquote><ol><li><p>多级队列，Q1优先级最高</p></li><li><p>时间片和优先级等级成反比，Q1时间片最小</p></li><li><p>新进程进入Q1队尾，队内按先来先服务执行</p></li><li><p>若在Q1所分配的时间片内完成作业，则撤离系统；否则，进入下一级队列Q2，直到Qmax</p></li><li><p>前一队列空了才能轮到下一队列执行</p></li><li><p>若被抢占，则被抢占的进程回到<strong>当前列</strong>的队尾</p><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/202204052133986.png alt=多级反馈队列调度></figure></p></li></ol></blockquote><blockquote><ul><li><p>优点</p><ol><li><p>短周期优先处理</p><blockquote><p>因为短周期进程一般在优先级较高的几个队列之中即被执行完毕</p></blockquote></li><li><p>系统开销小</p><blockquote><p>因为运行时间长的进程后面将进入优先级较低的队列，而这些队列的时间片较长，因而进程调度引起的进程切换的开销也比较小。</p></blockquote></li></ol></li><li><p>缺点</p><ol><li><p>可能发生饥饿</p><blockquote><p>如果优先级较高的队列一直不为空，则优先级 较低的队列中的进程可能长时间无法得到执行。</p></blockquote></li></ol></li></ul></blockquote><div id=296-实时调度 class=anchor>2.9.6 实时调度></div><h3 class="relative group">2.9.6 实时调度
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#296-%e5%ae%9e%e6%97%b6%e8%b0%83%e5%ba%a6 aria-label=锚点>#</a></span></h3><blockquote><p>实时系统无需考虑吞吐量、平均需要时间等</p><p>只需要做到：对时间要求最紧迫的任务先占用处理机</p><p>如：最早截止任务优先（earliest deadline first）算法，也称动态优先级调度算法。</p></blockquote><div id=297-高响应比优先hrrn class=anchor>2.9.7 高响应比优先（HRRN）></div><h3 class="relative group">2.9.7 高响应比优先（HRRN）
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#297-%e9%ab%98%e5%93%8d%e5%ba%94%e6%af%94%e4%bc%98%e5%85%88hrrn aria-label=锚点>#</a></span></h3><p>响应比=（等待时间+要求服务时间）\ 要求服务时间 >=1</p><p>综合了FCFS（等待时间）和SPF（要求服务时间），是非抢占算法，不会导致饥饿</p><div id=210-unix-系统进程的结构 class=anchor>2.10 UNIX 系统进程的结构></div><h2 class="relative group">2.10 UNIX 系统进程的结构
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#210-unix-%e7%b3%bb%e7%bb%9f%e8%bf%9b%e7%a8%8b%e7%9a%84%e7%bb%93%e6%9e%84 aria-label=锚点>#</a></span></h2><div id=2101-进程控制块-pcb class=anchor>2.10.1 进程控制块 PCB></div><h3 class="relative group">2.10.1 进程控制块 PCB
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#2101-%e8%bf%9b%e7%a8%8b%e6%8e%a7%e5%88%b6%e5%9d%97-pcb aria-label=锚点>#</a></span></h3><ul><li><p>UNIX 进程控制块（也称进程登记表）分为二个部分：proc 结构和 user 结构。</p></li><li><p>proc 结构常驻内存，user 结构不常驻内存。</p></li><li><p>把 UNIX 进程控制块分成二部分的原因是为了<strong>节省内存空间</strong></p></li></ul><blockquote><ol><li><p>proc结构</p><blockquote><ul><li><p>每个进程占用数组中的一个元素。</p><blockquote><p>例如 0 号进程（又称系统进程）的 proc 结构则占用 proc[0]。</p></blockquote></li><li><p>内容</p><blockquote><ol><li>进程状态<ol><li>p_stat 进程状态</li><li>p_flag 进程标志</li><li>p_pri 进程优先数</li></ol></li><li>用户标识符</li><li>进程标识符</li><li>存储区位置和长度</li><li>软中断信号：记录其他进程发来的软中断信号</li><li>计时项</li><li>调度参数：进程调度时用到的参数</li><li>指向user结构的指针：通过该指针使 proc 结构和 user 结构成为一个整体，构成 完整的进程控制块 PCB。</li><li>指向虚拟存储空间管理表格的指针：用于实现虚实地址变换。</li></ol></blockquote></li></ul></blockquote></li><li><p>user 结构</p><blockquote><ul><li>不常驻内存，只有进程执行时才需存取的控制信息</li><li>进程的私有数据结构，只能自己存取</li></ul></blockquote></li></ol></blockquote><div id=2102-进程的上下文 class=anchor>2.10.2 进程的上下文></div><h3 class="relative group">2.10.2 进程的上下文
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#2102-%e8%bf%9b%e7%a8%8b%e7%9a%84%e4%b8%8a%e4%b8%8b%e6%96%87 aria-label=锚点>#</a></span></h3><ol><li><p>用户级上下文</p></li><li><p>寄存器上下文</p></li><li><p>系统级上下文</p><blockquote><p>静态部分：</p><ul><li>proc结构</li><li>user结构</li><li>用于虚实地址映射的虚拟存储空间管理表格</li></ul><p>动态部分：</p><ul><li><p>核心栈</p><blockquote><p>核心栈（kernal stack）是进程执行核心程序时使用的栈，栈中装有进程调用核心函数时用到的有关参数和返回地址。</p></blockquote></li><li><p>若干层寄存器</p><blockquote><p>层的数目是变化的，满足后进先出的规则</p></blockquote></li></ul></blockquote></li></ol><div id=2103-进程的状态及转换 class=anchor>2.10.3 进程的状态及转换></div><h3 class="relative group">2.10.3 进程的状态及转换
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#2103-%e8%bf%9b%e7%a8%8b%e7%9a%84%e7%8a%b6%e6%80%81%e5%8f%8a%e8%bd%ac%e6%8d%a2 aria-label=锚点>#</a></span></h3><p>进程的状态</p><blockquote><p>正在执行的进程是处于核心态还是用户态由当前进程的 PSW 状态字中相应位来决定。</p><ol><li>用户态执行</li><li>核心态执行</li><li>内存就绪态</li><li>内存睡眠态</li><li>外存就绪态</li><li>外存睡眠态</li><li>被剥夺态（相当于<strong>内存就绪态</strong>）：当运行的进程要从核心态返回到用户态时</li><li>创建态：创建态是除进程 0 之外的所有进程的<strong>初始状态</strong></li><li>僵死态：执行了exit，此时进程已经不存在。但它留下了一个包含状态码和计时统计信息供其父进程来收集。僵死态是进程的<strong>终态</strong></li></ol></blockquote><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/202204052212093.png alt="UNIX 进程的状态转换"></figure></p><p>转换过程</p><div id=3-进程同步与通信 class=anchor>3. 进程同步与通信></div><h1 class="relative group">3. 进程同步与通信
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#3-%e8%bf%9b%e7%a8%8b%e5%90%8c%e6%ad%a5%e4%b8%8e%e9%80%9a%e4%bf%a1 aria-label=锚点>#</a></span></h1><blockquote><p>进程的通信机制可以协调进程之间的关系</p><p>低级通信：传送的信息量少，包括进程的互斥与同步</p><p>高级通信：传送大量数据，目的是信息交换</p></blockquote><div id=31-进程的并发执行 class=anchor>3.1 进程的并发执行></div><h2 class="relative group">3.1 进程的并发执行
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#31-%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%b9%b6%e5%8f%91%e6%89%a7%e8%a1%8c aria-label=锚点>#</a></span></h2><blockquote><p>会产生进程间互斥和同步，对临界资源的访问如果不合理，会产生死锁的问题</p></blockquote><div id=311-与时间有关的错误 class=anchor>3.1.1 与时间有关的错误></div><h3 class="relative group">3.1.1 与时间有关的错误
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#311-%e4%b8%8e%e6%97%b6%e9%97%b4%e6%9c%89%e5%85%b3%e7%9a%84%e9%94%99%e8%af%af aria-label=锚点>#</a></span></h3><p><strong>并发的进程中共享了公共变量，使得程序的执行与并发进程执行的速度有关</strong>，这种错误的结果往往与时间有关，因此被称为“与时间有关的错误”。</p><div id=312-bernstein条件 class=anchor>3.1.2 Bernstein条件></div><h3 class="relative group">3.1.2 Bernstein条件
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#312-bernstein%e6%9d%a1%e4%bb%b6 aria-label=锚点>#</a></span></h3><p>我们希望程序能够同时具有封闭性、可再现性、并发性。</p><p>若Bernstein条件被满足，则并发执行不会对执行结果的封闭性和可再现性产生影响</p><div id=313-临界资源与临界区 class=anchor>3.1.3 临界资源与临界区></div><h3 class="relative group">3.1.3 临界资源与临界区
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#313-%e4%b8%b4%e7%95%8c%e8%b5%84%e6%ba%90%e4%b8%8e%e4%b8%b4%e7%95%8c%e5%8c%ba aria-label=锚点>#</a></span></h3><p>临界资源：系统中一次只允许被一个进程使用的一类资源</p><p>临界区：就是在进程中访问临界资源的那一段程序</p><p>进入区：进入临界区前的检测区</p><p>退出区：将被访问的临界资源标志恢复为未访问状态</p><p>剩余区：其余的代码</p><div id=32-进程的互斥 class=anchor>3.2 进程的互斥></div><h2 class="relative group">3.2 进程的互斥
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#32-%e8%bf%9b%e7%a8%8b%e7%9a%84%e4%ba%92%e6%96%a5 aria-label=锚点>#</a></span></h2><div id=321-软件实现方法 class=anchor>3.2.1 软件实现方法></div><h3 class="relative group">3.2.1 软件实现方法
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#321-%e8%bd%af%e4%bb%b6%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%b3%95 aria-label=锚点>#</a></span></h3><ol><li><p>严格轮换</p><blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> turn<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>; <span style=color:#75715e>/*设置一个公共整型变量，用来标识允许进入临界区的进程。*/</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>	进程强制以交替的次序严格轮流进入临界区
</span></span></span><span style=display:flex><span><span style=color:#75715e>	缺点：忙等待、资源利用不充分
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>进程</span> <span style=color:#ae81ff>1</span><span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (TRUE) 
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (turn <span style=color:#f92672>!=</span> <span style=color:#ae81ff>1</span>); <span style=color:#75715e>/*进入区*/</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Critial_region1</span>(); <span style=color:#75715e>/*临界区*/</span>
</span></span><span style=display:flex><span>        turn <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; <span style=color:#75715e>/*退出区*/</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>other_region1</span>(); <span style=color:#75715e>/*剩余区*/</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>进程</span> <span style=color:#ae81ff>2</span><span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (TRUE) 
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (turn <span style=color:#f92672>!=</span> <span style=color:#ae81ff>2</span>); <span style=color:#75715e>/*进入区*/</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Critial_region2</span>(); <span style=color:#75715e>/*临界区*/</span>
</span></span><span style=display:flex><span>        turn <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>/*退出区*/</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>other_region2</span>(); <span style=color:#75715e>/*剩余区*/</span>
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div></blockquote></li><li><p>Dekker算法</p><blockquote><p>算法复杂，被取代</p></blockquote></li><li><p>Peterson算法</p><blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>enum</span> boolean {false, true};
</span></span><span style=display:flex><span><span style=color:#75715e>/*标识数组，标识每个进程，true为表示该进程想进入临界区*/</span>
</span></span><span style=display:flex><span>Boolean flag[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> {false, false}; 
</span></span><span style=display:flex><span> <span style=color:#75715e>/*公共变量，turn=i的时候，i可以进入临界区*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> turn;
</span></span><span style=display:flex><span><span style=color:#75715e>/*缺点：依旧忙等待，但可以使得进程可以在有限的时间内进入临界区*/</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>进程</span> <span style=color:#ae81ff>1</span><span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (TRUE) 
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        flag[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> true; <span style=color:#75715e>/*进入区*/</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*进入区2，通过turn值的设置和其后的while语句来保证任何时候最多只有一个进程可以进入临界区*/</span>
</span></span><span style=display:flex><span>        turn <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; 
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*进入区3，当对方不在临界区并且不想进入临界区时才允许自己进入临界区*/</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (flag[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>&amp;&amp;</span> turn <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span>); 
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Critial_region1</span>(); <span style=color:#75715e>/*临界区*/</span>
</span></span><span style=display:flex><span>        flag[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> false; <span style=color:#75715e>/*退出区*/</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>other_region1</span>(); <span style=color:#75715e>/*剩余区*/</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>进程</span> <span style=color:#ae81ff>2</span><span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (TRUE) 
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        flag[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> true; <span style=color:#75715e>/*进入区*/</span>
</span></span><span style=display:flex><span>        turn <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>/*进入区*/</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (flag[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&amp;&amp;</span> turn <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>); <span style=color:#75715e>/*进入区*/</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Critial_region2</span>(); <span style=color:#75715e>/*临界区*/</span>
</span></span><span style=display:flex><span>        flag[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> false; <span style=color:#75715e>/*退出区*/</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>other_region2</span>(); <span style=color:#75715e>/*剩余区*/</span>
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div></blockquote></li></ol><div id=322-硬件实现方法 class=anchor>3.2.2 硬件实现方法></div><h3 class="relative group">3.2.2 硬件实现方法
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#322-%e7%a1%ac%e4%bb%b6%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%b3%95 aria-label=锚点>#</a></span></h3><ol><li><p>关中断</p><blockquote><p>每个进程在刚进入临界区之后就立即关闭所有中断，直到进程离开临界区再打开中断</p><p>优点：简单</p><p>缺点：</p><ol><li>不适用与多CPU系统，因为中断只对执行该命令的那个CPU有效</li><li>使用不当，后果严重</li><li>限制处理器交叉执行程序的能力，会影响系统效率</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>{
</span></span><span style=display:flex><span>    disable<span style=color:#960050;background-color:#1e0010>；</span> <span style=color:#75715e>/*关中断，进入区*/</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Critial_region</span>();<span style=color:#75715e>/*临界区*/</span>
</span></span><span style=display:flex><span>    enable<span style=color:#960050;background-color:#1e0010>；</span> <span style=color:#75715e>/*开中断，退出区*/</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>other_region</span>(); <span style=color:#75715e>/*剩余区*/</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></blockquote></li><li><p>使用测试和设置指令（testandset）</p><blockquote><p>会忙等待</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/*use=0的时候说明资源未被占用，
</span></span></span><span style=display:flex><span><span style=color:#75715e>若进程在访问临界区时的use=1，则会一直测试use，直到它等于0*/</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>TestAndSet</span>(use)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (use <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    use <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/*用测试与设置指令实现进程互斥的描述如下*/</span>
</span></span><span style=display:flex><span>boolean use <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>/*初始资源空闲*/</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>进程</span> i<span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>TestAndSet</span>(use); <span style=color:#75715e>/*进入区*/</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Critial_region</span>(); <span style=color:#75715e>/*临界区*/</span>
</span></span><span style=display:flex><span>use <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>/*退出区*/</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>other_region</span>(); <span style=color:#75715e>/*剩余区*/</span>
</span></span></code></pre></div></blockquote></li><li><p>使用对换指令（swap）</p><blockquote><p>会忙等待</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/*。在进入临界区之前，
</span></span></span><span style=display:flex><span><span style=color:#75715e>先交换 use 与 k，若交换后 k=0，说明资源未被占用，则进入临界区；若交换后 k=1，说明资
</span></span></span><span style=display:flex><span><span style=color:#75715e>源被占用，继续交换 use 与 k 直到 k=0。*/</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Swap</span>( boolean <span style=color:#f92672>*</span>a, boolean <span style=color:#f92672>*</span>b)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    boolean temp;
</span></span><span style=display:flex><span>    temp <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>a;
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>a <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>b;
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>b <span style=color:#f92672>=</span> temp;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//用交换指令实现进程互斥的描述如下：
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>boolean k <span style=color:#f92672>=</span> true; <span style=color:#75715e>/*初始化为 1*/</span>
</span></span><span style=display:flex><span>boolean use <span style=color:#f92672>=</span>false; <span style=color:#75715e>/*初始资源空闲*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> ( k <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>Swap</span>(<span style=color:#f92672>&amp;</span>use, <span style=color:#f92672>&amp;</span>k); <span style=color:#75715e>/*进入区*/</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Critial_region</span>(); <span style=color:#75715e>/*临界区*/</span>
</span></span><span style=display:flex><span>use <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>/*退出区*/</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>other_region</span>(); <span style=color:#75715e>/*剩余区*/</span>
</span></span></code></pre></div></blockquote></li></ol><div id=33-进程的同步 class=anchor>3.3 进程的同步></div><h2 class="relative group">3.3 进程的同步
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#33-%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%90%8c%e6%ad%a5 aria-label=锚点>#</a></span></h2><div id=331-同步的概念 class=anchor>3.3.1 同步的概念></div><h3 class="relative group">3.3.1 同步的概念
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#331-%e5%90%8c%e6%ad%a5%e7%9a%84%e6%a6%82%e5%bf%b5 aria-label=锚点>#</a></span></h3><p>不同的进程之间具有先后的制约关系</p><div id=332-同步的实现方法 class=anchor>3.3.2 同步的实现方法></div><h3 class="relative group">3.3.2 同步的实现方法
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#332-%e5%90%8c%e6%ad%a5%e7%9a%84%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%b3%95 aria-label=锚点>#</a></span></h3><p>sleep和wakeup原语：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>进程</span> <span style=color:#ae81ff>1</span><span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>…</span> <span style=color:#75715e>/*其他代码*/</span>
</span></span><span style=display:flex><span>S1; <span style=color:#75715e>/*S1 语句，须在进程 2 的 S2 语句之前执行*/</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>wakeup</span>(<span style=color:#960050;background-color:#1e0010>进程</span> <span style=color:#ae81ff>2</span>);<span style=color:#75715e>/*唤醒进程 2*/</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>…</span> <span style=color:#75715e>/*其他代码*/</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>进程</span> <span style=color:#ae81ff>2</span><span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>…</span> <span style=color:#75715e>/*其他代码*/</span>
</span></span><span style=display:flex><span>sleep; <span style=color:#75715e>/*阻塞自己*/</span>
</span></span><span style=display:flex><span>S2; <span style=color:#75715e>/*S2 语句，须在进程 1 的 S1 语句之后执行*/</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>…</span> <span style=color:#75715e>/*其他代码*/</span>
</span></span></code></pre></div><p>这种方法会信号丢失</p><div id=333-生产者-消费者问题 class=anchor>3.3.3 生产者-消费者问题></div><h3 class="relative group">3.3.3 生产者-消费者问题
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#333-%e7%94%9f%e4%ba%a7%e8%80%85-%e6%b6%88%e8%b4%b9%e8%80%85%e9%97%ae%e9%a2%98 aria-label=锚点>#</a></span></h3><div id=34-信号量 class=anchor>3.4 信号量></div><h2 class="relative group">3.4 信号量
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#34-%e4%bf%a1%e5%8f%b7%e9%87%8f aria-label=锚点>#</a></span></h2><blockquote><p>P （Down）减少 使用资源</p><p>V（Up）增加 释放资源</p></blockquote><div id=341-信号量的原理 class=anchor>3.4.1 信号量的原理></div><h3 class="relative group">3.4.1 信号量的原理
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#341-%e4%bf%a1%e5%8f%b7%e9%87%8f%e7%9a%84%e5%8e%9f%e7%90%86 aria-label=锚点>#</a></span></h3><p>信号量只能被两个标准的原语wait（S）和signal（S）访问</p><ol><li><p>整型信号量</p><p>依旧未解决忙等待的问题</p></li><li><p>记录型信号量</p><p>解决了忙等待问题，需要一个代表资源数目的整型变量value和一个进程链表L，用于链接所有等待该资源的进程。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> value;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> process <span style=color:#f92672>*</span>L;
</span></span><span style=display:flex><span>}semaphore;
</span></span></code></pre></div><ul><li><p>wait操作</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>wait</span>(semaphore S){
</span></span><span style=display:flex><span>    S.value<span style=color:#f92672>--</span>;<span style=color:#75715e>//请求一个该类资源
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span>(S.value<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span>){<span style=color:#75715e>//表示资源已经分配完
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        add this process P from S.L;<span style=color:#75715e>//插入该类资源的等待队列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>wakeup</span>(P);<span style=color:#75715e>//自我阻塞
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>signal操作</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>signal</span>(semaphore S){
</span></span><span style=display:flex><span>    S.value<span style=color:#f92672>++</span>;<span style=color:#75715e>//释放一个资源
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span>(S.value<span style=color:#f92672>&lt;=</span><span style=color:#ae81ff>0</span>){<span style=color:#75715e>//如果＋1后仍然资源不足，则表示有进程在等待该资源
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        remove a process P from S.L;<span style=color:#75715e>//从等待队列中移出队首进程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>wakeup</span>(P);<span style=color:#75715e>//调用wakeup原语唤醒该进程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li></ol><div id=342-用信号量实现进程互斥 class=anchor>3.4.2 用信号量实现进程互斥></div><h3 class="relative group">3.4.2 用信号量实现进程互斥
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#342-%e7%94%a8%e4%bf%a1%e5%8f%b7%e9%87%8f%e5%ae%9e%e7%8e%b0%e8%bf%9b%e7%a8%8b%e4%ba%92%e6%96%a5 aria-label=锚点>#</a></span></h3><p>总的来说就是PV操作要夹紧使用互斥资源的那个行为（临界区），中间不能有其他的代码。</p><blockquote><p>若有三个并发进程，设 R 为互斥信号量，其初值为 1，则其取值范围为（-2，-1，0，1）。</p><p>其中 R=1 表示所有进程都未进入临界区；</p><p>R=0 表示有 1 个进程进入临界区；</p><p>R=-1 表示有 1 个进程进入临界区且有另一个进程等待进入临界区；</p><p>R=-2 表示有 1 个进程进入临界区且另两个进程等待进入临界区。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>进程</span> <span style=color:#ae81ff>1</span><span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Down</span>(R); <span style=color:#75715e>/*进入区*/</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Critial_region1</span>(); <span style=color:#75715e>/*临界区*/</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Up</span>(R); <span style=color:#75715e>/*退出区*/</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>other_region1</span>(); <span style=color:#75715e>/*剩余区*/</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>进程</span> <span style=color:#ae81ff>2</span><span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Down</span>(R); <span style=color:#75715e>/*进入区*/</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Critial_region2</span>(); <span style=color:#75715e>/*临界区*/</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Up</span>(R); <span style=color:#75715e>/*退出区*/</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>other_region2</span>(); <span style=color:#75715e>/*剩余区*/</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>进程</span> <span style=color:#ae81ff>3</span><span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Down</span>(R); <span style=color:#75715e>/*进入区*/</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Critial_region3</span>(); <span style=color:#75715e>/*临界区*/</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Up</span>(R); <span style=color:#75715e>/*退出区*/</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>other_region3</span>(); <span style=color:#75715e>/*剩余区*/</span>
</span></span></code></pre></div></blockquote><div id=343-用信号量实现进程的同步 class=anchor>3.4.3 用信号量实现进程的同步></div><h3 class="relative group">3.4.3 用信号量实现进程的同步
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#343-%e7%94%a8%e4%bf%a1%e5%8f%b7%e9%87%8f%e5%ae%9e%e7%8e%b0%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%90%8c%e6%ad%a5 aria-label=锚点>#</a></span></h3><p>可以根据进程关系前驱图来确定PV的顺序</p><p>与上一节用 sleep 和 wakeup 原语解决本问题相比，信号量使得信号可以累积而不会丢失。</p><blockquote><p>若进程1先上处理机，则顺利执行s1，然后V(S)操作会使得S=1，且唤醒进程2，进程2在执行s2语句之前会先检查S，执行P(S)操作，使得S-1，此时S-1=0，可以顺利执行s2语句。</p><p>若进程2先上处理机，则会使得S-1=-1，阻塞自己，直到进程1执行s1和V(S)，进程2才会继续运行。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>Semaphore S<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; <span style=color:#75715e>/*公共信号量初始化为 0*/</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>进程</span> <span style=color:#ae81ff>1</span><span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>…</span> <span style=color:#75715e>/*其他代码*/</span>
</span></span><span style=display:flex><span>S1; <span style=color:#75715e>/*S1 语句，须在进程 2 的 S2 语句之前执行*/</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Up</span>(S); <span style=color:#75715e>/*Up 原语*/</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>…</span> <span style=color:#75715e>/*其他代码*/</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>进程</span> <span style=color:#ae81ff>2</span><span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>…</span> <span style=color:#75715e>/*其他代码*/</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Down</span>(S); <span style=color:#75715e>/*Down 原语*/</span>
</span></span><span style=display:flex><span>S2; <span style=color:#75715e>/*S2 语句，须在进程 1 的 S1 语句之后执行*/</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>…</span> <span style=color:#75715e>/*其他代码*/</span>
</span></span></code></pre></div></blockquote><div id=344-用信号量解决生产者消费者问题 class=anchor>3.4.4 用信号量解决生产者—消费者问题></div><h3 class="relative group">3.4.4 用信号量解决生产者—消费者问题
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#344-%e7%94%a8%e4%bf%a1%e5%8f%b7%e9%87%8f%e8%a7%a3%e5%86%b3%e7%94%9f%e4%ba%a7%e8%80%85%e6%b6%88%e8%b4%b9%e8%80%85%e9%97%ae%e9%a2%98 aria-label=锚点>#</a></span></h3><ol><li><p>单生产者单消费者问题</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>semaphore mutex <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#75715e>//临界区互斥信号量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>semaphore empty <span style=color:#f92672>=</span> n;<span style=color:#75715e>//空闲缓冲区
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>semaphore full <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;<span style=color:#75715e>//缓冲区初始化为空
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>producer</span>(){
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>whlie</span>(<span style=color:#ae81ff>1</span>){
</span></span><span style=display:flex><span>        product an item in nextp;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>P</span>(empty);<span style=color:#75715e>//先同步，生产数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>P</span>(mutex);<span style=color:#75715e>//互斥夹紧
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        add nextp to buffer;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>V</span>(mutex)<span style=color:#960050;background-color:#1e0010>；</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>V</span>(full);  <span style=color:#75715e>//唤醒消费者进程     
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>comsumer</span>(){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(<span style=color:#ae81ff>1</span>){
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>P</span>(full);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>P</span>(mutex);
</span></span><span style=display:flex><span>        remove an item from buffer;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>V</span>(mutex);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>V</span>(empty);<span style=color:#75715e>//唤醒生产者进程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        comsume teh item;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>需要注意的是：生产者进程先执行 Down(empty)，然后执行 Down(mutex)，他们的顺序是不能颠倒的；消费者进程先执行 Down(full)，然后执行 Down(mutex)，他们的顺序也是不能颠倒的。否则可能出现错误。 我们假设把他们的顺序都颠倒，会出现什么情况呢？一种情况：当生产者进程把缓冲区放满了，调度程序继续让生产者进程运行，它先执行 Down(mutex)，进入临界区，接着执行 Down(empty)时将被阻塞；接着轮到消费者进程执行，它也先执行 Down(mutex)，然而生产者进程已进入缓冲区，因此消费者进程也会被阻塞。这样一来，生产者和消费者进程都将阻 塞，都指望对方唤醒自己，陷入了无休止的等待了。</p></blockquote></li><li><p>多生产者多消费者问题</p><blockquote><p>问题描述：桌子上有一个盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等吃盘子中的橘子，女儿专等吃盘子中的苹果。只有盘子为空时，爸爸或妈妈才可向盘子中放一个水果：仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出。</p><p>问题分析：
1)关系分析。这里的关系要稍复杂一些。由每次只能向其中放入一只水果可知，爸爸和妈妈是互斥关系。爸爸和女儿、妈妈和儿子是同步关系，而且这两对进程必须连起来，儿子和女儿之间没有互斥和同步关系，因为他们是选择条件执行，不可能并发。</p><p>2)整理思路。这里有4个进程，实际上可抽象为两个生产者和两个消费者被连接到大小为1的缓冲区上。</p><p>3)信号量设置。首先将信号量plate设置互斥信号量，表示是否允许向盘子放入水果，初值为1表示允许放入，且只允许放入一个。信号量apple表示盘子中是否有苹果，初值为0表示盘子为空，不许取，apple=1表示可以取。信号量orange表示盘子中是否有橘子，初值为0表示盘子为空，不许取，orange=1表示可以取。</p><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/202205062053845.png alt=image-20220506205301523></figure></p><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/202205062053143.png alt=image-20220506205327857></figure></p></blockquote></li></ol><div id=345-信号量小结及其不足 class=anchor>3.4.5 信号量小结及其不足></div><h3 class="relative group">3.4.5 信号量小结及其不足
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#345-%e4%bf%a1%e5%8f%b7%e9%87%8f%e5%b0%8f%e7%bb%93%e5%8f%8a%e5%85%b6%e4%b8%8d%e8%b6%b3 aria-label=锚点>#</a></span></h3><p>优点：</p><ol><li>可以解决忙等待的问题</li><li>可以解决所有互斥和同步问题</li><li>不会丢失信号</li></ol><p>缺点：</p><ol><li>维护复杂，容易产生错误</li></ol><p>使用要点：</p><ol><li>互斥夹紧，同步在前</li></ol><div id=346-分析步骤 class=anchor>3.4.6 分析步骤></div><h3 class="relative group">3.4.6 分析步骤
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#346-%e5%88%86%e6%9e%90%e6%ad%a5%e9%aa%a4 aria-label=锚点>#</a></span></h3><ol><li>分析活动，划定临界资源和临界区</li><li>设置互斥信号量<code>semaphore mutex = 1</code>不同临界资源需要不同的互斥信号量）</li><li>分析什么地方需要实现同步关系（一前一后）</li><li>前驱关系图，每一对前驱关系都要设置一个同步信号量，前V后P</li><li>互斥夹紧，同步在前（互斥时PV成对出现在同一个进程中，同步时PV出现在不同进程中）</li></ol><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/image-20220630110059255.png alt=image-20220630110059255></figure></p><div id=35-管程monitor class=anchor>3.5 管程(Monitor)></div><h2 class="relative group">3.5 管程(Monitor)
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#35-%e7%ae%a1%e7%a8%8bmonitor aria-label=锚点>#</a></span></h2><blockquote><p>为了解决信号量存在的分散编程带来的困难;</p><p>管程是一个程序语言级别的构造，其正确性由编译器负责保证。是有些高级语言带有管程，而有些高级语言则不支持管程。</p><p>管程是一个软件模块</p></blockquote><div id=351-管程的定义结构和原理 class=anchor>3.5.1 管程的定义、结构和原理></div><h3 class="relative group">3.5.1 管程的定义、结构和原理
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#351-%e7%ae%a1%e7%a8%8b%e7%9a%84%e5%ae%9a%e4%b9%89%e7%bb%93%e6%9e%84%e5%92%8c%e5%8e%9f%e7%90%86 aria-label=锚点>#</a></span></h3><ul><li><p>管程应该具备的性质</p><ul><li><p>要有数据，和对数据的操作</p></li><li><p>管程这种扩展了的抽象数据类型的描述对象是共享资源</p></li><li><p>能单独编译</p></li><li><p>满足信息掩蔽原则，即调用者不知道内部具体的实现细节</p></li><li><p><strong>具有互斥和同步的机制（核心）</strong></p><blockquote><p>同一时间只有一个进程或线程访问管程；</p><p>这一机制在Java中以关键字synchronized标识；</p></blockquote></li></ul></li><li><p>管程由4部分构成</p><ul><li><p>管程的名称</p></li><li><p>局部与管程内部的共享数据结构说明</p></li><li><p>操作过程（函数）</p></li><li><p>对共享数据赋初值的语句</p><blockquote><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/202205071207377.png alt=image-20220507120723091></figure></p></blockquote></li></ul></li><li><p>入口等待队列</p><blockquote><p>申请进程只能互斥地进入管程，进程1进入了管程后，编译器会给该管程加锁，此时进程2、进程3等必须加入等待队列，等待进程1使用完管程解锁。</p><p>这种入口等待队列可以很好的实现互斥，那么同步如何实现？</p></blockquote></li><li><p>条件变量和同步原语 wait 和 signal</p><blockquote><ul><li><p>一个进程被阻塞或挂起的原因 （或条件）可以有多个，而条件变量就是在管程中被用来描述这些原因（或条件）的一种抽象数据类型。因此为了描述多种原因，可以在管程中可以设置<strong>多个条件变量</strong>。</p></li><li><p><strong>条件变量只是一个特殊的链表或者队列</strong>，该链表或者队列只能在管程内<strong>被 wait 和 signal 原语操作</strong>。由于条件变量必须在管程内才能被操作，因此，<strong>对条件变量的访问也都是互斥的</strong>。</p></li><li><p>wait(x)：</p><ul><li>第一，调用者进程或线程离开管程（即把锁打开）；</li><li>第二，将调用者挂在条件变量 x 的等待队列上；</li><li>第三，调用者被挂起，等待被唤醒。</li></ul></li><li><p>signal(x)：</p><ul><li>把条件变量 x 的等待队列上的第一个等待者唤醒的作用。</li><li>如果该队列为空，则不产生任何效果。</li></ul></li><li><p>条件变量和信号量的比较：</p><ul><li>相似点：条件变量的wait/signal操作类似于信号量的PV操作，可以实现进程的阻塞/唤醒。</li><li>不同点：条件变量是“没有值”的，仅实现了“排队等待”功能；而信号量是“有值”的，信号量的值反映了剩余资源数，而在管程中，剩余资源数用共享数据结构记录。</li></ul></li></ul></blockquote></li></ul><div id=352-用管程解决生产者消费者问题 class=anchor>3.5.2 用管程解决生产者—消费者问题></div><h3 class="relative group">3.5.2 用管程解决生产者—消费者问题
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#352-%e7%94%a8%e7%ae%a1%e7%a8%8b%e8%a7%a3%e5%86%b3%e7%94%9f%e4%ba%a7%e8%80%85%e6%b6%88%e8%b4%b9%e8%80%85%e9%97%ae%e9%a2%98 aria-label=锚点>#</a></span></h3><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/202205071258083.png alt=image-20220507125739878></figure></p><div id=353-管程的不足 class=anchor>3.5.3 管程的不足></div><h3 class="relative group">3.5.3 管程的不足
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#353-%e7%ae%a1%e7%a8%8b%e7%9a%84%e4%b8%8d%e8%b6%b3 aria-label=锚点>#</a></span></h3><ol><li><strong>管程对编译器的依赖性</strong>。因为管程需要编译器把互斥原语加在管程的开始和结尾。 对于许多程序设计语言，并没有实现管程机制。</li><li><strong>管程只能在单台计算机上发挥效果</strong>。由于那些直接支持管程的原语并没有提供机器之间的信息交换方法，因此管程无法在多计算机环境下或者网络环境下发挥作用。</li></ol><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/202205071301650.png alt=image-20220507130129519></figure></p><div id=36-进程的高级通信 class=anchor>3.6 进程的高级通信></div><h2 class="relative group">3.6 进程的高级通信
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#36-%e8%bf%9b%e7%a8%8b%e7%9a%84%e9%ab%98%e7%ba%a7%e9%80%9a%e4%bf%a1 aria-label=锚点>#</a></span></h2><blockquote><p>高级通信机制可以归结为三大类：</p><ol><li>消息传递系统：在单机和网络环境都有广泛的应用</li><li>共享存储器系统：以通信的高效而著称，然而其不足也比较明显</li><li>共享文件系统：以管道通信最为典型，管道通信由 UNIX 首创，目前已被许多系统所支持，成为一种重要的通信方式。</li></ol><ul><li>直接通信：直接与目标进程进行通信<ul><li>消息缓冲机制</li></ul></li><li>间接通信：进程之间的通信要通过某种中间实体作为媒介<ul><li>邮箱机制</li></ul></li></ul></blockquote><div id=361-消息缓冲机制 class=anchor>3.6.1 消息缓冲机制></div><h3 class="relative group">3.6.1 消息缓冲机制
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#361-%e6%b6%88%e6%81%af%e7%bc%93%e5%86%b2%e6%9c%ba%e5%88%b6 aria-label=锚点>#</a></span></h3><blockquote><p>利用内存中共用消息缓冲区来实现任意两个进程之间的信息交换</p></blockquote><ul><li><p>单向通信：不等回答、不发送回答</p></li><li><p>双向通信：发送者发送完消息后阻塞自己，直到接收者回答才会继续前进；接收者接收到信息前也阻塞等待直到收到发送者发来的消息，并且给发送者发送一个回答信息</p></li><li><p>通信过程</p><ol><li>发送者在自己的内存空间设置一个发送区，填入消息</li><li>发送者申请一个消息缓冲区，将发送区的消息送到缓冲区，并挂在消息链上</li><li>接收者在自己的内存设置接收区</li><li>接收者摘下消息链第一个信息，将消息从缓冲区复制到接收区，并释放缓冲区</li></ol><blockquote><p>注意：</p><ol><li>消息链、缓冲区是临界资源（PV原语）</li><li>如何管理消息链？消息链有多条消息、接收者接收信息时消息链可能为空（信号量）</li></ol></blockquote></li></ul><div id=362-邮箱机制 class=anchor>3.6.2 邮箱机制></div><h3 class="relative group">3.6.2 邮箱机制
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#362-%e9%82%ae%e7%ae%b1%e6%9c%ba%e5%88%b6 aria-label=锚点>#</a></span></h3><blockquote><p>引入一种双方共享的数据结构——邮箱，并用邮箱的地址作为消息的间接地址。如：email</p></blockquote><ul><li><p>邮箱的创建（创建者是邮箱的拥有者）</p><ul><li><p>由操作系统创建</p><ul><li><p>公用邮箱</p><blockquote><p>给系统中的核准进程使用和读取， 且在系统运行期间始终存在</p></blockquote></li><li><p>提供邮箱创建和撤销原语</p></li></ul></li><li><p>由用户进程创建</p><ul><li><p>私用邮箱</p><blockquote><p>由接收者向系统提出创建申请，归接收者拥有，而发送者只是邮箱的使用者</p></blockquote></li><li><p>共享邮箱</p><blockquote><p>拥有者和共享者都能读取邮箱中的消息</p></blockquote></li><li><p>当邮箱的拥有者进程结束时，邮箱也随之消失</p></li></ul></li></ul></li></ul><div id=363-共享存储区 class=anchor>3.6.3 共享存储区></div><h3 class="relative group">3.6.3 共享存储区
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#363-%e5%85%b1%e4%ba%ab%e5%ad%98%e5%82%a8%e5%8c%ba aria-label=锚点>#</a></span></h3><p>互斥地访问共享空间</p><p>有基于数据结构（低级）和基于存储区（高级）的共享</p><div id=364-管道 class=anchor>3.6.4 管道></div><h3 class="relative group">3.6.4 管道
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#364-%e7%ae%a1%e9%81%93 aria-label=锚点>#</a></span></h3><p>半双工，如果想实现双向同时通信，需要设置两个管道</p><p>访问管道需要互斥</p><p>只有管道写满才可读，读完了才能写（没写满，不允许读，反之一样）</p><p>读出去的数据不可恢复，因此管道中的读进程最多只有一个</p><div id=37-死锁 class=anchor>3.7 死锁></div><h2 class="relative group">3.7 死锁
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#37-%e6%ad%bb%e9%94%81 aria-label=锚点>#</a></span></h2><div id=371-什么是死锁 class=anchor>3.7.1 什么是死锁></div><h3 class="relative group">3.7.1 什么是死锁
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#371-%e4%bb%80%e4%b9%88%e6%98%af%e6%ad%bb%e9%94%81 aria-label=锚点>#</a></span></h3><ul><li><p>各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象</p></li><li><p>死锁产生的条件</p></li></ul><ol><li>互斥</li><li>不剥夺</li><li>请求和保持</li><li>循环等待</li></ol><div id=372-死锁的表示 class=anchor>3.7.2 死锁的表示></div><h3 class="relative group">3.7.2 死锁的表示
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#372-%e6%ad%bb%e9%94%81%e7%9a%84%e8%a1%a8%e7%a4%ba aria-label=锚点>#</a></span></h3><p>资源分配图</p><div id=373-死锁的检测和清除 class=anchor>3.7.3 死锁的检测和清除></div><h3 class="relative group">3.7.3 死锁的检测和清除
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#373-%e6%ad%bb%e9%94%81%e7%9a%84%e6%a3%80%e6%b5%8b%e5%92%8c%e6%b8%85%e9%99%a4 aria-label=锚点>#</a></span></h3><ul><li><p>检测</p><ul><li>简化：最终能消除所有的边，一定没有发生死锁</li></ul></li><li><p>清除</p><ul><li><p>资源剥夺</p><blockquote><p>挂起死锁进程，剥夺其资源给其他进程用，需要注意避免饥饿</p></blockquote></li><li><p>终止进程</p><blockquote><p>代价大</p></blockquote></li><li><p>进程回退</p><blockquote><p>回退到足以避免死锁的地步，要求系统记录历史信息</p></blockquote></li></ul></li></ul><div id=374-死锁的预防 class=anchor>3.7.4 死锁的预防></div><h3 class="relative group">3.7.4 死锁的预防
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#374-%e6%ad%bb%e9%94%81%e7%9a%84%e9%a2%84%e9%98%b2 aria-label=锚点>#</a></span></h3><p>破坏死锁产生的条件</p><ol><li>互斥——把只能互斥使用的资源改造为允许共享使用的资源（SPOOLing）</li><li>不剥夺——申请不到便主动释放或剥夺其他进程的资源</li><li>请求和保持——运行前一次性申请所有需要的资源</li><li>循环等待——必须按编号递增的顺序请求资源</li></ol><div id=375-死锁的避免 class=anchor>3.7.5 死锁的避免></div><h3 class="relative group">3.7.5 死锁的避免
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#375-%e6%ad%bb%e9%94%81%e7%9a%84%e9%81%bf%e5%85%8d aria-label=锚点>#</a></span></h3><p>银行家算法</p><p>计算安全序列</p><div id=4-存储管理 class=anchor>4. 存储管理></div><h1 class="relative group">4. 存储管理
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#4-%e5%ad%98%e5%82%a8%e7%ae%a1%e7%90%86 aria-label=锚点>#</a></span></h1><div id=41-存储管理的基本功能 class=anchor>4.1 存储管理的基本功能></div><h2 class="relative group">4.1 存储管理的基本功能
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#41-%e5%ad%98%e5%82%a8%e7%ae%a1%e7%90%86%e7%9a%84%e5%9f%ba%e6%9c%ac%e5%8a%9f%e8%83%bd aria-label=锚点>#</a></span></h2><div id=411-转换 class=anchor>4.1.1 转换></div><h3 class="relative group">4.1.1 转换
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#411-%e8%bd%ac%e6%8d%a2 aria-label=锚点>#</a></span></h3><blockquote><p>用户通过汇编语言或高级语言编写的程序，称为源程序。源程序是不能被计算机直接执 行的，需要通过编译、连接、加载后，装入内存才能运行。</p></blockquote><ol><li><p><strong>连接和加载</strong></p><ul><li><p>连接</p><p>生成装入模块（可执行文件），里面的是逻辑地址</p><ul><li>静态连接（程序运行前就形成完整的装入模块，之后不再拆开）</li><li>动态连接<ul><li>装入时动态（边运行边连接）</li><li>运行时动态（用的时候才连接）</li></ul></li></ul></li><li><p>加载</p><p>将逻辑地址转为物理地址</p><ul><li>绝对加载（只适用于单道程序环境）</li><li>可重定位加载（地址变换是在装入时一次完成的，必须一次分配全部空间）</li><li>运行时动态加载（装入时依旧是逻辑地址，需要重定位寄存器的支持，重定位寄存器放装入模块的起始位置）</li></ul></li></ul></li><li><p><strong>地址转换</strong></p><ul><li>静态地址重定位</li><li>动态地址重定位</li></ul></li></ol><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/image-20220630131904284.png alt=image-20220630131904284></figure></p><div id=412-存储保护和共享 class=anchor>4.1.2 存储保护和共享></div><h3 class="relative group">4.1.2 存储保护和共享
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#412-%e5%ad%98%e5%82%a8%e4%bf%9d%e6%8a%a4%e5%92%8c%e5%85%b1%e4%ba%ab aria-label=锚点>#</a></span></h3><ul><li>内存信息保护方法</li></ul><ol><li><p>上下界寄存器</p></li><li><p>保护键法</p></li><li><p>界限寄存器</p><blockquote><p>重定位寄存器 物理起始地址</p><p>界地址寄存器 逻辑地址长度</p></blockquote></li></ol><ul><li>为了充分利用内存空间，应避免每个进程拥有单独的副本，而允 许它们访问该程序的同一个副本，这一工作称为<strong>存储共享</strong>。</li></ul><div id=413-内存分配回收 class=anchor>4.1.3 内存分配回收></div><h3 class="relative group">4.1.3 内存分配回收
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#413-%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%9b%9e%e6%94%b6 aria-label=锚点>#</a></span></h3><ol><li><p>连续分配方式</p><blockquote><p>一般无内存保护</p><p>只适用于单用户、单任务的操作系统</p><p>有内部碎片，存储器利用率很低</p></blockquote></li><li><p>离散分配方式</p><blockquote><p>分页存储管理方式，分段存储管理方式和段页式存储管理方式</p><p>当进程大小超出内存的可用空间时，这个进程是无法运行的</p></blockquote></li><li><p>虚拟存储管理方式</p><blockquote><p>请求分页式管理方式、请求分段式管理方式和请求段页式管理方式</p><p>通过实现<strong>部分装入</strong>和<strong>部分对换</strong>功能，形成了虚拟存储管理方式</p></blockquote></li></ol><div id=414-内存扩充 class=anchor>4.1.4 内存扩充></div><h3 class="relative group">4.1.4 内存扩充
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#414-%e5%86%85%e5%ad%98%e6%89%a9%e5%85%85 aria-label=锚点>#</a></span></h3><ol><li><p>由应用程序控制的：<strong>覆盖</strong>方式</p><blockquote><p>分为固定区和覆盖区</p><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/image-20220630181746920.png alt=image-20220630181746920></figure></p><p>对用户不透明，不能实现虚拟存储器</p></blockquote></li><li><p>操作系统控制的：<strong>交换</strong>方式、<strong>请求调入</strong>方式和<strong>预调入</strong> 方式</p><blockquote><p>交换技术：进程暂时换出外存，PCB留在内存</p><p>和覆盖的区别：覆盖在同一个进程之间，交换在不同进程之间</p></blockquote></li></ol><div id=42-分区存储管理 class=anchor>4.2 分区存储管理></div><h2 class="relative group">4.2 分区存储管理
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#42-%e5%88%86%e5%8c%ba%e5%ad%98%e5%82%a8%e7%ae%a1%e7%90%86 aria-label=锚点>#</a></span></h2><div id=421-固定分区 class=anchor>4.2.1 固定分区></div><h3 class="relative group">4.2.1 固定分区
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#421-%e5%9b%ba%e5%ae%9a%e5%88%86%e5%8c%ba aria-label=锚点>#</a></span></h3><ol><li>大小相等</li><li>可变大小</li></ol><div id=422-动态分区 class=anchor>4.2.2 动态分区></div><h3 class="relative group">4.2.2 动态分区
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#422-%e5%8a%a8%e6%80%81%e5%88%86%e5%8c%ba aria-label=锚点>#</a></span></h3><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/image-20220630183529299.png alt=image-20220630183529299></figure></p><p>克服固定分区中小进程占据大分区的现象，避免分区内部 出现碎片；</p><p>进程进入内存前并不建立分区，而是根据进程大小对内存进行划分，因此，内存中分区个数是可变的。</p><p>由于各个进程执行时，都会装入与之相符的分区中，并连 续存储，因而进程大小受限于内存空间的容量，无法实现虚拟存储。</p><p>紧凑技术：（两种策略）</p><ol><li>释放后立即进行紧凑</li><li>找不到足够大的分区再进行紧凑</li></ol><div id=423-地址转换和存储保护 class=anchor>4.2.3 地址转换和存储保护></div><h3 class="relative group">4.2.3 地址转换和存储保护
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#423-%e5%9c%b0%e5%9d%80%e8%bd%ac%e6%8d%a2%e5%92%8c%e5%ad%98%e5%82%a8%e4%bf%9d%e6%8a%a4 aria-label=锚点>#</a></span></h3><div id=424-存储共享 class=anchor>4.2.4 存储共享></div><h3 class="relative group">4.2.4 存储共享
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#424-%e5%ad%98%e5%82%a8%e5%85%b1%e4%ba%ab aria-label=锚点>#</a></span></h3><div id=425-分配和回收算法 class=anchor>4.2.5 分配和回收算法></div><h3 class="relative group">4.2.5 分配和回收算法
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#425-%e5%88%86%e9%85%8d%e5%92%8c%e5%9b%9e%e6%94%b6%e7%ae%97%e6%b3%95 aria-label=锚点>#</a></span></h3><ol><li><p>固定分区的分配算法</p></li><li><p>动态分区的分配算法</p><ol><li><p>首次适应</p><blockquote><p>每次都从低地址开始查找，找到第一个能满足大小的空闲分区</p></blockquote></li><li><p>最佳适应</p><blockquote><p>空闲分区按容量递增次序连接，因此第一个找到的满足要求的空闲分区，一定是刚刚好合适的</p><p>优先使用<strong>更小</strong>的空闲区，会产生很多外部碎片</p></blockquote></li><li><p>最坏适应</p><blockquote><p>空闲分区按容量递减次序连接</p><p>优先使用<strong>最大</strong>的空闲区，导致大进程到达很可能没空闲分区可用了</p></blockquote></li><li><p>邻近适应</p><blockquote><p>每次查找都从上一次结束的位置开始查找，减少查找开销</p></blockquote></li></ol><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/image-20220630185320587.png alt=image-20220630185320587></figure></p></li><li><p>动态分区的回收算法</p><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/image-20220630185705624.png alt=image-20220630185705624></figure></p></li><li><p>移动技术</p><p>紧凑</p></li></ol><div id=426-覆盖和交换 class=anchor>4.2.6 覆盖和交换></div><h3 class="relative group">4.2.6 覆盖和交换
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#426-%e8%a6%86%e7%9b%96%e5%92%8c%e4%ba%a4%e6%8d%a2 aria-label=锚点>#</a></span></h3><ol><li>覆盖</li><li>交换</li></ol><div id=427-分区存储管理的优缺点 class=anchor>4.2.7 分区存储管理的优缺点></div><h3 class="relative group">4.2.7 分区存储管理的优缺点
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#427-%e5%88%86%e5%8c%ba%e5%ad%98%e5%82%a8%e7%ae%a1%e7%90%86%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9 aria-label=锚点>#</a></span></h3><ul><li>优点<ol><li>支持多道程序设计，实现了多个进程对内存的共享。提高了内存和 CPU 的利用效率；</li><li>简单</li></ol></li><li>缺点<ol><li>要求进程在分区内连续存储，因而进程大小受内存空间容量的限制；</li><li>难以实现存储共享</li><li>固定分区分配算法会产生内部碎片，动态分区分配算法会产生外部碎片，因而， 内存利用率不高。</li></ol></li></ul><div id=43-分页式存储管理 class=anchor>4.3 分页式存储管理></div><h2 class="relative group">4.3 分页式存储管理
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#43-%e5%88%86%e9%a1%b5%e5%bc%8f%e5%ad%98%e5%82%a8%e7%ae%a1%e7%90%86 aria-label=锚点>#</a></span></h2><p>分区存储管理要求每个进程在分区内是连续存储的，致使不论是固定分区管理，还是 动态分区管理，在内存空间利用率上都是低效的，因为前者产生内部碎片，后者产生外部碎 片。在动态分区管理中，虽然紧凑是解决内存外部碎片的一种途径，但需要移动大量信息， 花去不少处理机时间，代价比较高。究其原因在于分区存储管理要求把进程必须放置在一块连续的存储区中，而分页式存储管理正是要<strong>避开这种连续性的要求</strong>。</p><div id=431-基本原理 class=anchor>4.3.1 基本原理></div><h3 class="relative group">4.3.1 基本原理
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#431-%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86 aria-label=锚点>#</a></span></h3><ul><li>分页式存储管理允许把一个进程分配到不相邻的分区中。</li><li>将进程的逻辑空间和内存空间划分为同样大小的块，分别称为页和页面（page frame）</li></ul><div id=432-数据结构 class=anchor>4.3.2 数据结构></div><h3 class="relative group">4.3.2 数据结构
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#432-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label=锚点>#</a></span></h3><ul><li>页表是操作系统为每个用户进程建立的，在内存中占有 一块固定的区域，用来记录程序页和内存页面的一一对应关系</li><li>作业表是操作系统为当前运行的所有作业建立的，用来记录每个作业的页表起址和页表 长度，以进行内存分配和地址变化。作业表是整个系统一张。</li></ul><div id=433-地址转换和存储保护 class=anchor>4.3.3 地址转换和存储保护></div><h3 class="relative group">4.3.3 地址转换和存储保护
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#433-%e5%9c%b0%e5%9d%80%e8%bd%ac%e6%8d%a2%e5%92%8c%e5%ad%98%e5%82%a8%e4%bf%9d%e6%8a%a4 aria-label=锚点>#</a></span></h3><ul><li>物理地址 = 页面号 × 页表长度 + 页内地址</li></ul><div id=434-存储共享 class=anchor>4.3.4 存储共享></div><h3 class="relative group">4.3.4 存储共享
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#434-%e5%ad%98%e5%82%a8%e5%85%b1%e4%ba%ab aria-label=锚点>#</a></span></h3><ul><li>数据共享和程序共享</li></ul><div id=435-分配算法 class=anchor>4.3.5 分配算法></div><h3 class="relative group">4.3.5 分配算法
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#435-%e5%88%86%e9%85%8d%e7%ae%97%e6%b3%95 aria-label=锚点>#</a></span></h3><div id=436-分页式存储管理的优缺点 class=anchor>4.3.6 分页式存储管理的优缺点></div><h3 class="relative group">4.3.6 分页式存储管理的优缺点
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#436-%e5%88%86%e9%a1%b5%e5%bc%8f%e5%ad%98%e5%82%a8%e7%ae%a1%e7%90%86%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9 aria-label=锚点>#</a></span></h3><ul><li><p>优点：实现了离散存储</p></li><li><p>缺点：</p><ol><li>消除了外部碎片，但内部碎片仍然存在</li><li>在进行地址转换和存储保护时，需要有相应的硬件支持，增加了机器成本。</li></ol></li></ul><div id=44-分段式存储管理 class=anchor>4.4 分段式存储管理></div><h2 class="relative group">4.4 分段式存储管理
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#44-%e5%88%86%e6%ae%b5%e5%bc%8f%e5%ad%98%e5%82%a8%e7%ae%a1%e7%90%86 aria-label=锚点>#</a></span></h2><p>在分区存储管理和分页式存储管理中，进程的逻辑地址空间是按线性排列的。虽然，分 区存储管理或分页式存储管理可以把程序划分成区或页，但这些区或页与源程序的公用子程 序和数据毫无逻辑关系，而公用子程序和数据的共享则要求信息在逻辑上是完全的，因而， 这两种方式<strong>难以将用户给定的程序名和数据块名与这些被共享进程的程序和数据的区或页对应起来</strong>。</p><div id=441-基本原理 class=anchor>4.4.1 基本原理></div><h3 class="relative group">4.4.1 基本原理
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#441-%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86 aria-label=锚点>#</a></span></h3><ul><li>根据逻辑划分段，每个段都有自己的名字</li><li>与分页式存储管理相比，分段式存储管理有两个 显著的特征：<ol><li>在<strong>分页式</strong>存储管理中，内存中的页面号递增排列，地址空间属于一维结 构，而在<strong>分段式</strong>存储管理中，段号在内存中的分区之间无任何顺序关系，地址空间属于二维结构；</li><li>在<strong>分页式</strong>存储管理中，每个页的长度固定，而在分段式存储管理中，为了确保信息在逻辑上是完整的，段的长度可变。<strong>分段式</strong>存储管理为进程的每一段分配一个连续的内存空间，而各个段之间并不要求一定连续。</li></ol></li></ul><div id=442-地址转换和存储保护 class=anchor>4.4.2 地址转换和存储保护></div><h3 class="relative group">4.4.2 地址转换和存储保护
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#442-%e5%9c%b0%e5%9d%80%e8%bd%ac%e6%8d%a2%e5%92%8c%e5%ad%98%e5%82%a8%e4%bf%9d%e6%8a%a4 aria-label=锚点>#</a></span></h3><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/image-20220630212539930.png alt=image-20220630212539930></figure></p><div id=443-存储共享 class=anchor>4.4.3 存储共享></div><h3 class="relative group">4.4.3 存储共享
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#443-%e5%ad%98%e5%82%a8%e5%85%b1%e4%ba%ab aria-label=锚点>#</a></span></h3><p><strong>段的共享</strong>是指在多道程序设计环境下，用户进程需要共享内存中的某段程序或数据时，只要使用相同的段名，在其段表中填入已存在于内存之中的段基址，便可实现逻辑上完整的信息共享</p><div id=444-分段式存储管理的优缺点 class=anchor>4.4.4 分段式存储管理的优缺点></div><h3 class="relative group">4.4.4 分段式存储管理的优缺点
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#444-%e5%88%86%e6%ae%b5%e5%bc%8f%e5%ad%98%e5%82%a8%e7%ae%a1%e7%90%86%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9 aria-label=锚点>#</a></span></h3><ul><li><p>优点</p><ol><li><p>信息共享</p><blockquote><p>在实现指令和数据的共享时，常常需要以信息的逻辑单位基础，而分页式存储管理中的每一页只是存放信息的物理单位，其本身没有完整的意义，因而不便于实 现信息的共享，而段却是信息的逻辑单位，有利于实现信息的共享；</p></blockquote></li><li><p>动态增长</p><blockquote><p>在实际的系统中，往往有些数据段会不断地增长，而事先却无法知道 数据段会增长到多大，分段式存储管理可以较好地解决这个问题。</p></blockquote></li><li><p>动态连接</p><blockquote><p>动态连接是指在进程运行之前，并不把几个目标程序段都连接起来， 而是先将主程序对应的目标程序装入内存并启动运行，当运行过程中又需要调用某段时，再将该段（目标程序）调入内存并连接起来。所以，**</p></blockquote></li><li><p>提供了内存和外存统一管理的虚存实现方式。</p></li></ol></li><li><p>缺点</p><ol><li>需要有更多的硬件支持，提高了机器成本；</li><li>消除外部碎片，存在内部碎片（同一个进程的最后一点点空间）</li><li>缺段中断处理以及允许段的动态增长会给系统增加难度和开销。</li></ol></li></ul><div id=45-段页式存储管理 class=anchor>4.5 段页式存储管理></div><h2 class="relative group">4.5 段页式存储管理
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#45-%e6%ae%b5%e9%a1%b5%e5%bc%8f%e5%ad%98%e5%82%a8%e7%ae%a1%e7%90%86 aria-label=锚点>#</a></span></h2><p>式既具有分页式存储管理有效 避免产生外部碎片的优点，又具有分段式存储管理能很好实现共享存储的长处</p><div id=451-基本原理 class=anchor>4.5.1 基本原理></div><h3 class="relative group">4.5.1 基本原理
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#451-%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86 aria-label=锚点>#</a></span></h3><ol><li>先将整个内存划分成大小相等的、位置固定的页面</li><li>再把进程按逻辑关系分为若干个段，并为每个段赋予一个段名</li><li>最后把每段的线性地址空间划分成与页面大小相等的页</li></ol><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/image-20220630213757616.png alt=image-20220630213757616></figure></p><p>作业表整个系统一张，用于记录系 统中所有作业的段表的起始地址；</p><p>段表每个作业一张，用于记录该作业的所有段以及每段的页表的起始地址；</p><p>页表每个段一张，用户记录该页是否在内存、所对应的内存页面号。</p><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/image-20220630213851597.png alt=image-20220630213851597></figure></p><div id=452-地址转换 class=anchor>4.5.2 地址转换></div><h3 class="relative group">4.5.2 地址转换
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#452-%e5%9c%b0%e5%9d%80%e8%bd%ac%e6%8d%a2 aria-label=锚点>#</a></span></h3><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/image-20220630214233889.png alt=段页式存储管理的地址变换></figure></p><div id=453-段页式存储管理的优缺点 class=anchor>4.5.3 段页式存储管理的优缺点></div><h3 class="relative group">4.5.3 段页式存储管理的优缺点
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#453-%e6%ae%b5%e9%a1%b5%e5%bc%8f%e5%ad%98%e5%82%a8%e7%ae%a1%e7%90%86%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9 aria-label=锚点>#</a></span></h3><p>段页式存储管理具有分页式存储管理和分段式存储管理的优点。但是，反过来说，所需的硬件支持、复杂性和系统开销也会随之增加。在地址转换过程中，如果不采用快 表提高地址转换速度，那么 CPU 的执行速度将大大下降。</p><div id=46-虚拟存储管理 class=anchor>4.6 虚拟存储管理></div><h2 class="relative group">4.6 虚拟存储管理
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#46-%e8%99%9a%e6%8b%9f%e5%ad%98%e5%82%a8%e7%ae%a1%e7%90%86 aria-label=锚点>#</a></span></h2><p>当一个进程在执行过程中，若需要访问的指令和数据在内存中，则继续执行；若不在内存中，则系统将把这部分信息自动调入内存，称为<strong>部分装入</strong>；若内存中没有足够多的空闲区，则系统需把内存中暂时不用的信息从内存中调出，称为<strong>部分对换</strong>。</p><div id=461-虚拟存储器的概念 class=anchor>4.6.1 虚拟存储器的概念></div><h3 class="relative group">4.6.1 虚拟存储器的概念
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#461-%e8%99%9a%e6%8b%9f%e5%ad%98%e5%82%a8%e5%99%a8%e7%9a%84%e6%a6%82%e5%bf%b5 aria-label=锚点>#</a></span></h3><ul><li><p>虚拟存储器是指：具有自动实现部分装入和部分对换功能，能只把进程的 一部分装入内存便可运行，从逻辑上，是对内存容量进行扩充的一种虚拟的存储器系统。</p></li><li><p>虚拟存储器的逻辑容量由内存和外存容量之和所决定</p></li><li><p>时两进程P1，P2通过两FIFO缓冲区队列连接（如图），每个缓冲区长度等于传送消息长度，进程P1，P2之间的通信满足如下条件：问。（连续存储）</p></li><li><p>抖动现象：增加内存分配也不能显著减少内存和外存之间的交换次数。或者是，页面在内存与外存之间频繁调度，以至于调度页面所需时间比进程实际运行时间还多，此时系统效率急剧下降，导致系统崩溃。</p></li></ul><div id=462-请求分页式虚拟存储管理 class=anchor>4.6.2 请求分页式虚拟存储管理></div><h3 class="relative group">4.6.2 请求分页式虚拟存储管理
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#462-%e8%af%b7%e6%b1%82%e5%88%86%e9%a1%b5%e5%bc%8f%e8%99%9a%e6%8b%9f%e5%ad%98%e5%82%a8%e7%ae%a1%e7%90%86 aria-label=锚点>#</a></span></h3><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/image-20220702095554331.png alt=请求分页存储管理页表></figure></p><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/image-20220702095339239.png alt=请求分页工作流程></figure></p><div id=463-请求分段式虚拟存储管理 class=anchor>4.6.3 请求分段式虚拟存储管理></div><h3 class="relative group">4.6.3 请求分段式虚拟存储管理
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#463-%e8%af%b7%e6%b1%82%e5%88%86%e6%ae%b5%e5%bc%8f%e8%99%9a%e6%8b%9f%e5%ad%98%e5%82%a8%e7%ae%a1%e7%90%86 aria-label=锚点>#</a></span></h3><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/image-20220702095918136.png alt=image-20220702095918136></figure></p><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/image-20220702100551982.png alt=缺段中断处理></figure><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/image-20220702100611500.png alt=请求分段式虚拟存储管理的地址变换过程></figure></p><div id=464-请求段页式虚拟存储管理 class=anchor>4.6.4 请求段页式虚拟存储管理></div><h3 class="relative group">4.6.4 请求段页式虚拟存储管理
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#464-%e8%af%b7%e6%b1%82%e6%ae%b5%e9%a1%b5%e5%bc%8f%e8%99%9a%e6%8b%9f%e5%ad%98%e5%82%a8%e7%ae%a1%e7%90%86 aria-label=锚点>#</a></span></h3><div id=47-页面置换算法 class=anchor>4.7 页面置换算法></div><h2 class="relative group">4.7 页面置换算法
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#47-%e9%a1%b5%e9%9d%a2%e7%bd%ae%e6%8d%a2%e7%ae%97%e6%b3%95 aria-label=锚点>#</a></span></h2><div id=471-最佳置换算法opt class=anchor>4.7.1 最佳置换算法（OPT）></div><h3 class="relative group">4.7.1 最佳置换算法（OPT）
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#471-%e6%9c%80%e4%bd%b3%e7%bd%ae%e6%8d%a2%e7%ae%97%e6%b3%95opt aria-label=锚点>#</a></span></h3><ul><li>每次选择以后永不使用，或者最长时间内不再被访问的页面</li><li>可以保证最低的缺页率，但是实际使用时是无法实现的，因为操作系统无法提前预判各个页面的访问序列</li></ul><div id=472-先进先出置换算法fifo class=anchor>4.7.2 先进先出置换算法（FIFO）></div><h3 class="relative group">4.7.2 先进先出置换算法（FIFO）
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#472-%e5%85%88%e8%bf%9b%e5%85%88%e5%87%ba%e7%bd%ae%e6%8d%a2%e7%ae%97%e6%b3%95fifo aria-label=锚点>#</a></span></h3><ul><li>淘汰最早进入内存的页面</li><li>会产生belady异常</li></ul><div id=473-最近最久未使用置换算法lru class=anchor>4.7.3 最近最久未使用置换算法（LRU）></div><h3 class="relative group">4.7.3 最近最久未使用置换算法（LRU）
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#473-%e6%9c%80%e8%bf%91%e6%9c%80%e4%b9%85%e6%9c%aa%e4%bd%bf%e7%94%a8%e7%bd%ae%e6%8d%a2%e7%ae%97%e6%b3%95lru aria-label=锚点>#</a></span></h3><ul><li>淘汰最近最久未使用的页面</li></ul><div id=474-最少使用lfu class=anchor>4.7.4 最少使用（LFU）></div><h3 class="relative group">4.7.4 最少使用（LFU）
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#474-%e6%9c%80%e5%b0%91%e4%bd%bf%e7%94%a8lfu aria-label=锚点>#</a></span></h3><ul><li>看前面使用次数</li></ul><div id=48-页面分配策略 class=anchor>4.8 页面分配策略></div><h2 class="relative group">4.8 页面分配策略
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#48-%e9%a1%b5%e9%9d%a2%e5%88%86%e9%85%8d%e7%ad%96%e7%95%a5 aria-label=锚点>#</a></span></h2><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/image-20220702111317440.png alt=image-20220702111317440></figure></p><div id=481-驻留集 class=anchor>4.8.1 驻留集></div><h3 class="relative group">4.8.1 驻留集
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#481-%e9%a9%bb%e7%95%99%e9%9b%86 aria-label=锚点>#</a></span></h3><ul><li><p>驻留集：请求分页存储管理中心给进程分配的物理块的集合</p><ul><li>太小：缺页频繁（极端情况：每次调页都会缺页中断）</li><li>太大：并发度下降（极端情况：全部页面都在内存中）</li></ul></li><li><p>分配策略</p><blockquote><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/image-20220702111936243.png alt=image-20220702111936243></figure></p></blockquote><ul><li>固定分配：驻留集大小<strong>不变</strong></li><li>可变分配：驻留集大小根据进程实际运行情况<strong>改变</strong></li><li>局部置换：发生缺页时只能选进程自己的物理块进行置换</li><li>全局置换：发生缺页时可以将操作系统保留的空闲物理块或者其他进程的物理块分配给缺页进程</li><li>可变分配全局置换：只要某进程发生缺页后，<strong>都将</strong>获得新的物理块，如果这个新的物理块来自其他的进程，则会导致这个被选中的进程的缺页率增加。</li><li>可变分配局部置换：操作系统<strong>根据该进程的缺页率</strong>，适当增减驻留集</li></ul></li></ul><div id=482-调入策略 class=anchor>4.8.2 调入策略></div><h3 class="relative group">4.8.2 调入策略
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#482-%e8%b0%83%e5%85%a5%e7%ad%96%e7%95%a5 aria-label=锚点>#</a></span></h3><ul><li><p>调入页面的时机</p><ol><li><p>预调页策略</p><blockquote><p>主要用于进程的首次调入，由程序员指出应该先调入哪些部分</p></blockquote></li><li><p>请求调页策略</p><blockquote><p>进程运行期间使用，每次只掉一页，IO开销大</p></blockquote></li></ol></li><li><p>从外存中的何处调入页面</p><ul><li>对换区（连续分配，速度快，容量小）<ul><li>进程运行前需要从文件区复制需要的数据到对换区</li></ul></li><li>文件区（离散分配，速度慢，容量大）<ul><li>不会被修改的数据</li></ul></li></ul></li></ul><div id=483-抖动颠簸 class=anchor>4.8.3 抖动、颠簸></div><h3 class="relative group">4.8.3 抖动、颠簸
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#483-%e6%8a%96%e5%8a%a8%e9%a2%a0%e7%b0%b8 aria-label=锚点>#</a></span></h3><ul><li><p>现象：刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存</p></li><li><p>原因：分配给进程的物理块不够</p></li></ul><div id=484-工作集 class=anchor>4.8.4 工作集></div><h3 class="relative group">4.8.4 工作集
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#484-%e5%b7%a5%e4%bd%9c%e9%9b%86 aria-label=锚点>#</a></span></h3><ul><li>指在某段时间间隔内，进程实际访问页面的集合</li><li>根据工作集的大小确定驻留集的大小</li></ul><div id=5-文件系统 class=anchor>5. 文件系统></div><h1 class="relative group">5. 文件系统
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#5-%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f aria-label=锚点>#</a></span></h1><blockquote><p>它由<strong>文件和目录</strong>两个部分组成，文件用于存储用户和系统的程序和数据； 目录用于组织系统内的文件，并提供有关文件的信息。对用户而言，文件系统最重要的功能之一就是 通过“<strong>按名存取</strong>”的方式来实现对文件信息的存储和检索，使得用户能透明地存储和访问文 件，只关心文件操作和逻辑结构，不涉及文件的存储结构。</p></blockquote><div id=51-文件和文件系统 class=anchor>5.1 文件和文件系统></div><h2 class="relative group">5.1 文件和文件系统
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#51-%e6%96%87%e4%bb%b6%e5%92%8c%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f aria-label=锚点>#</a></span></h2><div id=511-文件概念 class=anchor>5.1.1 文件概念></div><h3 class="relative group">5.1.1 文件概念
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#511-%e6%96%87%e4%bb%b6%e6%a6%82%e5%bf%b5 aria-label=锚点>#</a></span></h3><ul><li>逻辑结构：按名存取</li><li>物理结构：把用户对文件操作请求转换为对存储介质上信息所在的位置的各种操作</li><li>文件是在逻辑上具有完整意义的信息集合</li><li>文件是逻辑外存的最小分配单元。数据除非写入文件中，否则不能存储到外存</li><li>文件可存储多种不同类型的信息</li><li>数据项：描述对象的属性</li><li>记录：是一组相关域的集合，是在逻辑上具有独立含义的最小信息单位。</li><li>文件：一组相关记录的集合</li><li>数据库：相关数据的集合</li></ul><div id=512-文件命名 class=anchor>5.1.2 文件命名></div><h3 class="relative group">5.1.2 文件命名
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#512-%e6%96%87%e4%bb%b6%e5%91%bd%e5%90%8d aria-label=锚点>#</a></span></h3><ul><li>文件名.扩展名</li><li>通配符：？> 字符串 * > 字符</li></ul><div id=513-文件类型 class=anchor>5.1.3 文件类型></div><h3 class="relative group">5.1.3 文件类型
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#513-%e6%96%87%e4%bb%b6%e7%b1%bb%e5%9e%8b aria-label=锚点>#</a></span></h3><ul><li>在Windows系统中，扩展名表示文件类型</li><li>在Linux中，文件的内容决定文件类型</li></ul><div id=514-文件属性 class=anchor>5.1.4 文件属性></div><h3 class="relative group">5.1.4 文件属性
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#514-%e6%96%87%e4%bb%b6%e5%b1%9e%e6%80%a7 aria-label=锚点>#</a></span></h3><ul><li>所有文件的属性信息都保存在目录结构中，但由于目录和文件一样，是易失性的。因此，目录结构必须保存在外存上。</li></ul><div id=515-文件系统的概念 class=anchor>5.1.5 文件系统的概念></div><h3 class="relative group">5.1.5 文件系统的概念
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#515-%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e7%9a%84%e6%a6%82%e5%bf%b5 aria-label=锚点>#</a></span></h3><ul><li>早期的计算机系统没有文件系统，大容量直接存取的磁盘存储器的问世，导致了文件系统的出现，它是一组系统软件。</li><li>功能<ol><li>以统一的方式对磁盘等外存进行统一管理；</li><li>目录管理，实现文件的<strong>按名存取</strong>；</li><li>实现文件从逻辑结构到物理结构的转换；</li><li>实现文件信息的<strong>共享</strong>，并提供文件的<strong>保护</strong>和加密措施；</li><li>向用户提供接口，方便使用文件操作。</li></ol></li></ul><div id=52-文件组织存取方法和存取设备 class=anchor>5.2 文件组织、存取方法和存取设备></div><h2 class="relative group">5.2 文件组织、存取方法和存取设备
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#52-%e6%96%87%e4%bb%b6%e7%bb%84%e7%bb%87%e5%ad%98%e5%8f%96%e6%96%b9%e6%b3%95%e5%92%8c%e5%ad%98%e5%8f%96%e8%ae%be%e5%a4%87 aria-label=锚点>#</a></span></h2><div id=521-文件的逻辑结构 class=anchor>5.2.1 文件的逻辑结构></div><h3 class="relative group">5.2.1 文件的逻辑结构
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#521-%e6%96%87%e4%bb%b6%e7%9a%84%e9%80%bb%e8%be%91%e7%bb%93%e6%9e%84 aria-label=锚点>#</a></span></h3><ol><li><p>字符流式的无结构文件</p><blockquote><ul><li>如：.txt</li><li>通常按长度来读取所需信息，可以使用特殊字符作为分界</li></ul></blockquote></li><li><p>记录式的有结构文件</p><blockquote><ul><li>使用者的每次操作总是以一个逻辑记录为对象</li><li><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/image-20220702130120991.png alt=image-20220702130120991></figure></li><li>常见的记录式的有结构文件有：堆、顺序文件、索引顺序文件、索引文件和直接文件。</li></ul></blockquote></li></ol><div id=522-文件的物理结构 class=anchor>5.2.2 文件的物理结构></div><h3 class="relative group">5.2.2 文件的物理结构
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#522-%e6%96%87%e4%bb%b6%e7%9a%84%e7%89%a9%e7%90%86%e7%bb%93%e6%9e%84 aria-label=锚点>#</a></span></h3><ul><li><p>构造文件的物理地址</p><ul><li>计算法：根据键和映射函数，计算出物理地址</li><li>指针法：设置专门的指针，指明相应记录的物理地址或各记录之间的关联。</li></ul></li><li><p>文件物理结构和组织方法：顺序文件、连接文件、索引文件和直接文件</p><ol><li><p>顺序文件</p><blockquote><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/image-20220702131654210.png alt=image-20220702131654210></figure></p><ul><li>逻辑上连续的信息物理上也连续</li><li>优点<ol><li>存取速度快</li><li>当文件是定长记录文件时，还可以随机访问</li></ol></li><li>缺点<ol><li>事先确定文件长度，不利于文件动态增长</li><li>要求分配连续的存储空间</li><li>分配的物理块中会产生碎片</li><li>对文件进行增删比较困难</li></ol></li><li>综上，不适合存放用户文件、数据库文件等经常被修改的文件。</li></ul></blockquote></li><li><p>连接文件（串联文件）</p><blockquote><ul><li>文件放在用指针连接的离散的物理块中</li><li>优点<ol><li>文件长度可动态增长</li><li>增删容易</li></ol></li><li>缺点<ol><li>搜索效率低</li><li>不适合随机存取</li></ol></li></ul></blockquote></li><li><p>索引文件</p><blockquote><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/image-20220702131927046.png alt=image-20220702131927046></figure><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/image-20220702132243301.png alt=image-20220702132243301></figure></p><ul><li>优点：<ol><li>动态增长</li><li>增删容易</li><li>随机存取</li></ol></li><li>缺点<ol><li>增加存储开销</li><li>访问外存次数多</li></ol></li></ul></blockquote></li><li><p>直接文件（连接文件）</p><blockquote><p>直接文件使用散列法或杂凑法（Hash 法），在直接存取存储设备上，把记录的关键字与其地址之间建立某种对应关系，以便实现快速存取。使用 hash 技术需要建立一张 hash 表，一个 hash 表是一个指针数组，数组通过索引访问，数组元素中的指针指向数据记录。</p></blockquote></li></ol></li></ul><div id=523-文件的存取方法 class=anchor>5.2.3 文件的存取方法></div><h3 class="relative group">5.2.3 文件的存取方法
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#523-%e6%96%87%e4%bb%b6%e7%9a%84%e5%ad%98%e5%8f%96%e6%96%b9%e6%b3%95 aria-label=锚点>#</a></span></h3><blockquote><p>常用的存取方法有三种：顺序存取、随机存取和索引存取。</p></blockquote><ol><li>顺序存取</li><li>随机存取</li><li>索引存取</li></ol><div id=524-文件的存储设备 class=anchor>5.2.4 文件的存储设备></div><h3 class="relative group">5.2.4 文件的存储设备
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#524-%e6%96%87%e4%bb%b6%e7%9a%84%e5%ad%98%e5%82%a8%e8%ae%be%e5%a4%87 aria-label=锚点>#</a></span></h3><blockquote><p>存储设备的特性决定了文件的组织和存取方法</p></blockquote><ol><li><p>存储设备</p><ol><li><p>顺序存取设备（磁带）</p></li><li><p>直接存取设备（磁盘）</p><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/image-20220702143535760.png alt=存取设备、物理结构和存取方法间的关系></figure></p></li></ol></li><li><p>卷和块</p></li></ol><div id=53-文件目录 class=anchor>5.3 文件目录></div><h2 class="relative group">5.3 文件目录
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#53-%e6%96%87%e4%bb%b6%e7%9b%ae%e5%bd%95 aria-label=锚点>#</a></span></h2><ol><li>文件名</li><li>文件名到文件物理块的转换</li><li>文件名和结构信息的组织结构</li><li>文件说明</li><li>文件控制块</li><li>文件目录和目录文件</li></ol><div id=530-文件控制块fcb class=anchor>5.3.0 文件控制块（FCB）></div><h3 class="relative group">5.3.0 文件控制块（FCB）
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#530-%e6%96%87%e4%bb%b6%e6%8e%a7%e5%88%b6%e5%9d%97fcb aria-label=锚点>#</a></span></h3><ul><li>文件控制块是按名存取的前提</li><li><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/image-20220702144531308.png alt=image-20220702144531308></figure></li></ul><div id=531-一级目录结构 class=anchor>5.3.1 一级目录结构></div><h3 class="relative group">5.3.1 一级目录结构
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#531-%e4%b8%80%e7%ba%a7%e7%9b%ae%e5%bd%95%e7%bb%93%e6%9e%84 aria-label=锚点>#</a></span></h3><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/image-20220702145102572.png alt=image-20220702145102572></figure></p><div id=532-二级目录结构 class=anchor>5.3.2 二级目录结构></div><h3 class="relative group">5.3.2 二级目录结构
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#532-%e4%ba%8c%e7%ba%a7%e7%9b%ae%e5%bd%95%e7%bb%93%e6%9e%84 aria-label=锚点>#</a></span></h3><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/image-20220702145120566.png alt=image-20220702145120566></figure></p><div id=533-树形目录结构 class=anchor>5.3.3 树形目录结构></div><h3 class="relative group">5.3.3 树形目录结构
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#533-%e6%a0%91%e5%bd%a2%e7%9b%ae%e5%bd%95%e7%bb%93%e6%9e%84 aria-label=锚点>#</a></span></h3><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/image-20220702145141778.png alt=image-20220702145141778></figure></p><p>缺点：</p><ol><li>不便于实现文件共享</li></ol><div id=534-无环图目录结构 class=anchor>5.3.4 无环图目录结构></div><h3 class="relative group">5.3.4 无环图目录结构
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#534-%e6%97%a0%e7%8e%af%e5%9b%be%e7%9b%ae%e5%bd%95%e7%bb%93%e6%9e%84 aria-label=锚点>#</a></span></h3><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/image-20220702145627362.png alt=image-20220702145627362></figure></p><div id=535-索引结点fcb的改进 class=anchor>5.3.5 索引结点（FCB的改进）></div><h3 class="relative group">5.3.5 索引结点（FCB的改进）
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#535-%e7%b4%a2%e5%bc%95%e7%bb%93%e7%82%b9fcb%e7%9a%84%e6%94%b9%e8%bf%9b aria-label=锚点>#</a></span></h3><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/image-20220702145849555.png alt=image-20220702145849555></figure></p><div id=54-文件共享与保护 class=anchor>5.4 文件共享与保护></div><h2 class="relative group">5.4 文件共享与保护
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#54-%e6%96%87%e4%bb%b6%e5%85%b1%e4%ba%ab%e4%b8%8e%e4%bf%9d%e6%8a%a4 aria-label=锚点>#</a></span></h2><div id=541-文件共享 class=anchor>5.4.1 文件共享></div><h3 class="relative group">5.4.1 文件共享
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#541-%e6%96%87%e4%bb%b6%e5%85%b1%e4%ba%ab aria-label=锚点>#</a></span></h3><blockquote><p>文件共享的实现方式有：系统目录实现方式、连接实现方式和符号连接方式。</p></blockquote><ol><li><p>系统目录实现方式</p><blockquote><ul><li><p>用户通过全路径名共享地访问共享文件</p></li><li><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/image-20220702150921767.png alt=image-20220702150921767></figure></p></li><li><p>缺点</p><blockquote><p>无法实现共享文件的动态增长。假设用户 A 和用户 B 通 过系统目录方式实现了对文件 F 的共享。当用户 A 对文件 F 进行修改，使其长度由原来的 20K 增加到 60K 时，对用户 B 而言，自己的目录项中关于文件 F 的长度信息并没有改变， 因而无法实现共享文件的动态增长。也就是说<strong>用户 A 对文件 F 增加了新的内容，用户 B 却看不到增加的内容</strong>。</p></blockquote></li></ul></blockquote></li><li><p>连接实现方式（是基于索引节点的共享方式）</p><blockquote><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/image-20220702150320240.png alt=image-20220702150320240></figure></p><p>缺点：某个用户删除共享文件时，容易造成其他共享用户的指针悬空。</p><p>※根据王道考研课的讲述：只有在count==0时才会允许删除文件，一般情况下，其中一个用户把文件删除，删的只是指向该索引结点的指针，即删除指向文件的指针。</p></blockquote></li><li><p>符号连接方式</p><blockquote><ul><li>类似于Windows的快捷方式</li></ul></blockquote></li></ol><div id=542-文件保护 class=anchor>5.4.2 文件保护></div><h3 class="relative group">5.4.2 文件保护
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#542-%e6%96%87%e4%bb%b6%e4%bf%9d%e6%8a%a4 aria-label=锚点>#</a></span></h3><blockquote><p>一般可以使用以下四种文件保护方式：存取控制矩阵、存取控制表、 密码方式和加密方式。</p></blockquote><ol><li><p>存取控制矩阵</p><blockquote><ul><li>在理论上是可行的，但<strong>实现上确有困难</strong>。当一个系统用户 数和文件数很大时，访问控制矩阵将会变得非常庞大，既占用了大量的内存空间，还会加重 使用文件时对访问控制矩阵扫描所带来的时间开销。</li><li><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/image-20220702151512223.png alt=image-20220702151512223></figure></li></ul></blockquote></li><li><p>存取控制表</p><blockquote><p>分组管理</p><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/image-20220702152137088.png alt=image-20220702152137088></figure></p></blockquote></li><li><p>口令方式</p><blockquote><ul><li><p>两种方式：</p><ol><li>是当用户进入系统，为建立终端进程时获得<strong>系统使用权的口令</strong>。如果用户输入的口令与原来设置的口令不一致的话，该用户将被系统拒绝。</li><li>每个用户在创建文件时，<strong>为每一个创建的文件设置一个口令</strong>，且将其置于文件说明中。 当任一用户想使用该文件时，都必须提供口令。只有当口令匹配时才能对文件进行存取。</li></ol></li><li><p>优点：简单，占用的内存空间以及验证口令所需的时间少。</p></li><li><p>缺点</p><ol><li>用户需要记住的口令数量过大，以致这种方案不可行；</li><li>如果所有文件只使用一个口令，那么它一旦被发现，所有文件都将被访问。</li></ol></li></ul></blockquote></li><li><p>加密方式</p><blockquote><ul><li>在用户创建源文件并将其写入存储设备时 对文件进行编码加密，在读出文件时对其进行译码解密。</li><li>与口令方式相比，加密方式中使用的密钥没有存放在系统中，由用户自己保管，具有 保密性强的优点。</li></ul></blockquote></li></ol><div id=55-文件系统其他功能的实现 class=anchor>5.5 文件系统其他功能的实现></div><h2 class="relative group">5.5 文件系统其他功能的实现
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#55-%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e5%85%b6%e4%bb%96%e5%8a%9f%e8%83%bd%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label=锚点>#</a></span></h2><div id=551-文件操作 class=anchor>5.5.1 文件操作></div><h3 class="relative group">5.5.1 文件操作
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#551-%e6%96%87%e4%bb%b6%e6%93%8d%e4%bd%9c aria-label=锚点>#</a></span></h3><ul><li>操作命令<ul><li>DOS 系统中的 dir，cd，copy，del，attrib，men</li></ul></li><li>系统调用<ul><li>增删查改</li></ul></li></ul><div id=552-文件系统的层次结构 class=anchor>5.5.2 文件系统的层次结构></div><h3 class="relative group">5.5.2 文件系统的层次结构
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#552-%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e7%9a%84%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84 aria-label=锚点>#</a></span></h3><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/image-20220702153454726.png alt=文件系统的层次模型></figure></p><div id=553-外存空间管理 class=anchor>5.5.3 外存空间管理></div><h3 class="relative group">5.5.3 外存空间管理
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#553-%e5%a4%96%e5%ad%98%e7%a9%ba%e9%97%b4%e7%ae%a1%e7%90%86 aria-label=锚点>#</a></span></h3><blockquote><p>外存空间中空闲块的管理可以采用以下方式：（1）空闲块表；（2）空闲块链表；（3） 成组空闲块链；（4）位示图。</p></blockquote><ol><li><p>空闲块表</p><blockquote><ul><li>此表包含两个登记项：该空闲区的第 一个盘块号和盘块总数。</li><li>空闲块表的分配算法有最先适应算法、最佳适应算法和最坏适应算法。</li></ul></blockquote></li><li><p>空闲块链表</p><blockquote><ul><li>删除文件时，释放该文件所占用的空闲块，并把这些块挂到空闲块链表上。这种方法<strong>效率很低</strong>，因为每次申请一块块都要读出空闲块并取得指针，申请多块时要多次读盘</li><li>便于文件动态增长和收缩</li></ul></blockquote></li><li><p>成组空闲块链</p></li><li><p>位示图</p><blockquote><p>优点是可以把位示图全部或大部分保存在主存中，再配合计算机具有的位操作指令，可实现<strong>高速</strong>物理块分配和回收。</p></blockquote></li></ol><div id=554-虚拟文件系统 class=anchor>5.5.4 虚拟文件系统></div><h3 class="relative group">5.5.4 虚拟文件系统
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#554-%e8%99%9a%e6%8b%9f%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f aria-label=锚点>#</a></span></h3><ul><li>虚拟文件系统要实现以下目标：应同时支持多种文件系统；系统中可以安装多个文件系 统，它们应与传统的单一文件系统没有区别，用户的使用接口不变；对网络共享文件提供完 全支持，即访问远程结点上的文件系统应与访问本地结点的文件系统一致；支持开发出新的 文件系统，以模块方式加入到操作系统中</li><li>虚拟文件系统并不是一种实际存在的文件系统，它只存在于内存中，不存在 于外存空间，在操作系统启动时建立，在系统关闭时消亡。</li></ul><div id=6-设备管理 class=anchor>6. 设备管理></div><h1 class="relative group">6. 设备管理
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#6-%e8%ae%be%e5%a4%87%e7%ae%a1%e7%90%86 aria-label=锚点>#</a></span></h1><p>数据传输方式</p><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/image-20220703231124698.png alt=image-20220703231124698></figure></p><ol><li>程序直接控制方式</li><li>中断控制方式</li><li>DMA</li><li>通道</li></ol></br></br></div><script>var oid="views_docs/操作系统笔记/index.md",oid_likes="likes_docs/操作系统笔记/index.md"</script><script type=text/javascript src=/js/page.min.0e49973b4ad0a382c7c6012d8bff8226316642daabc4f8a20477bd08674f3da6e2fa993bc20ad4f51e7c5bb68e6f913a207a7c4fe37ea0e7b806894afce0a64e.js integrity="sha512-DkmXO0rQo4LHxgEti/+CJjFmQtqrxPiiBHe9CGdPPabi+pk7wgrU9R58W7aOb5E6IHp8T+N+oOe4BolK/OCmTg=="></script></section><footer class="pt-8 max-w-prose print:hidden"><section class="flex flex-row flex-wrap justify-center pt-4 text-xl"><a target=_blank class="m-1 rounded bg-neutral-300 p-1.5 text-neutral-700 hover:bg-primary-500 hover:text-neutral dark:bg-neutral-700 dark:text-neutral-300 dark:hover:bg-primary-400 dark:hover:text-neutral-800" href="mailto:?body=https://mykaneki.github.io/docs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/&subject=%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0" title=通过电子邮件发送 aria-label=通过电子邮件发送><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M207.8 20.73c-93.45 18.32-168.7 93.66-187 187.1-27.64 140.9 68.65 266.2 199.1 285.1 19.01 2.888 36.17-12.26 36.17-31.49l1e-4-.6631c0-15.74-11.44-28.88-26.84-31.24-84.35-12.98-149.2-86.13-149.2-174.2.0-102.9 88.61-185.5 193.4-175.4 91.54 8.869 158.6 91.25 158.6 183.2v16.16c0 22.09-17.94 40.05-40 40.05s-40.01-17.96-40.01-40.05v-120.1c0-8.847-7.161-16.02-16.01-16.02l-31.98.0036c-7.299.0-13.2 4.992-15.12 11.68-24.85-12.15-54.24-16.38-86.06-5.106-38.75 13.73-68.12 48.91-73.72 89.64-9.483 69.01 43.81 128 110.9 128 26.44.0 50.43-9.544 69.59-24.88 24 31.3 65.23 48.69 109.4 37.49C465.2 369.3 496 324.1 495.1 277.2V256.3c0-149.2-133.9-265.632-287.3-235.57zM239.1 304.3c-26.47.0-48-21.56-48-48.05s21.53-48.05 48-48.05 48 21.56 48 48.05-20.6 48.05-48 48.05z"/></svg></span></a></section><div class=pt-8><hr class="border-dotted border-neutral-300 dark:border-neutral-600"><div class="flex justify-between pt-3"><span><a class="flex group mr-3" href=/docs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%A0%E9%A2%98/><span class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400">&larr;</span>
<span class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400">&rarr;</span>
<span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">操作系统习题</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"></span></span></a></span><span><a class="flex text-right group ml-3" href=/docs/%E5%A4%A7%E6%95%B0%E6%8D%AE/><span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">大数据基本配置和使用</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"></span></span><span class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400">&rarr;</span>
<span class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400">&larr;</span></a></span></div></div></footer></article><div class="pointer-events-none absolute top-[100vh] bottom-0 w-12 ltr:right-0 rtl:left-0"><a href=#the-top class="pointer-events-auto sticky top-[calc(100vh-5.5rem)] flex h-12 w-12 mb-16 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 backdrop-blur hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400" aria-label title>&uarr;</a></div></main><footer class="py-10 print:hidden"><nav class="flex flex-row pb-4 text-base font-medium text-neutral-500 dark:text-neutral-400"><ul class="flex flex-col list-none sm:flex-row"><li class="flex mb-1 ltr:text-right rtl:text-left sm:mb-0 ltr:sm:mr-7 ltr:sm:last:mr-0 rtl:sm:ml-7 rtl:sm:last:ml-0"><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2" href=/tags/ title=Tags>标签</a></li><li class="flex mb-1 ltr:text-right rtl:text-left sm:mb-0 ltr:sm:mr-7 ltr:sm:last:mr-0 rtl:sm:ml-7 rtl:sm:last:ml-0"><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2" href=/series/ title=Series>系列</a></li></ul></nav><div class="flex items-center justify-between"><p class="text-sm text-neutral-500 dark:text-neutral-400">&copy;
2023
mykaneki</p><p class="text-xs text-neutral-500 dark:text-neutral-400">由 <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://gohugo.io/ target=_blank rel="noopener noreferrer">Hugo</a> & <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://blowfish.page/ target=_blank rel="noopener noreferrer">Blowfish</a> 强力驱动</p></div><script>mediumZoom(document.querySelectorAll("img:not(.nozoom)"),{margin:24,background:"rgba(0,0,0,0.5)",scrollOffset:0})</script><script type=text/javascript src=/js/process.min.2166d3adac1679c00a75161830ab5725d3efc0e3d3f8c2453fb01d0907948436c25f0f8a7ad824322fa22f3f9c85fd4d0a1d5c856f53b862157da25a57dc3d52.js integrity="sha512-IWbTrawWecAKdRYYMKtXJdPvwOPT+MJFP7AdCQeUhDbCXw+KetgkMi+iLz+chf1NCh1chW9TuGIVfaJaV9w9Ug=="></script></footer><div id=search-wrapper class="invisible fixed inset-0 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm dark:bg-neutral-900/50 sm:p-6 md:p-[10vh] lg:p-[12vh]" data-url=https://mykaneki.github.io/ style=z-index:500><div id=search-modal class="flex flex-col w-full max-w-3xl min-h-0 mx-auto border rounded-md shadow-lg top-20 border-neutral-200 bg-neutral dark:border-neutral-700 dark:bg-neutral-800"><header class="relative z-10 flex items-center justify-between flex-none px-2"><form class="flex items-center flex-auto min-w-0"><div class="flex items-center justify-center w-8 h-8 text-neutral-400"><span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></div><input type=search id=search-query class="flex flex-auto h-12 mx-1 bg-transparent appearance-none focus:outline-dotted focus:outline-2 focus:outline-transparent" placeholder=Search tabindex=0></form><button id=close-search-button class="flex items-center justify-center w-8 h-8 text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400" title="Close (Esc)">
<span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentcolor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></button></header><section class="flex-auto px-2 overflow-auto"><ul id=search-results></ul></section></div></div></div></body></html>