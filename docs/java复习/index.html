<!doctype html><html lang=zh-cn dir=ltr class=scroll-smooth data-default-appearance=dark data-auto-appearance=true><head><meta charset=utf-8><meta http-equiv=content-language content="zh-cn"><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><title>&#183; mykaneki's blog</title><meta name=title content=" &#183; mykaneki's blog"><meta name=description content="My awesome website"><link rel=canonical href=https://mykaneki.github.io/docs/java%E5%A4%8D%E4%B9%A0/><link type=text/css rel=stylesheet href=/css/main.bundle.min.b9ea6ac1de9e040e17a3a3e7bbe17d49f4f29c24060418953590fa329ba8420aae6994d37a142bf60fdba7fd747c9e01ed54a547790b87172d9ccd7c4074b5ca.css integrity="sha512-uepqwd6eBA4Xo6Pnu+F9SfTynCQGBBiVNZD6MpuoQgquaZTTehQr9g/bp/10fJ4B7VSlR3kLhxctnM18QHS1yg=="><script type=text/javascript src=/js/main.min.cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e.js integrity="sha512-z4PhNX7vuL3xVChQ1m2AB9Yg5AULVxXcg/SpIdNs6c5H0NE8XYXysP+DGNKHfuwvY7kxvUdBeoGlODJ6+SfaPg=="></script>
<script type=text/javascript src=/js/appearance.min.f94f4c4636d9e3ec8f5ee53cdc8ffa3d01bf87cd92ac85e6797550b1e2b80dc9118d838f3eb24c55109352455e72ff082dfe560283154e5a8f87fd75107b59c4.js integrity="sha512-+U9MRjbZ4+yPXuU83I/6PQG/h82SrIXmeXVQseK4DckRjYOPPrJMVRCTUkVecv8ILf5WAoMVTlqPh/11EHtZxA=="></script>
<script defer type=text/javascript id=script-bundle src=/js/main.bundle.min.3ddcf04f5b0d4c32f72e726d3c12eebccd8c3c9f9daa9a13414808895de0ae1e1cdddda6849680d5bd96dbb60d0b1e0b24c29f5c83e5631e55e7e6bc02015490.js integrity="sha512-PdzwT1sNTDL3LnJtPBLuvM2MPJ+dqpoTQUgIiV3grh4c3d2mhJaA1b2W27YNCx4LJMKfXIPlYx5V5+a8AgFUkA==" data-copy data-copied></script>
<script src=/js/zoom.min.js></script>
<link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta property="og:title" content><meta property="og:description" content="day03 Java语言的特性> day03 Java语言的特性 # ~
（1）Java的简单性
Java语言底层是C++，所以JVM是用C++语言写好的一个虚拟的电脑。
没有指针概念，不允许直接通过指针操作内存；java只支持单继承；
（2）Java的跨平台
（3）Java的健壮性
GC机制，自动垃圾回收机制
（4）Java完全面向对象
（5）Java语言支持多线程
~~
什么是跨平台，什么是可移植？~
​	java语言只要编写一次，可以做到到处运行。(.java - .class 字节码 - 机器码 JVM)
跨平台指的是Java程序可以在不同的操作系统上运行，而不需要修改源代码或重新编译。这是因为Java程序运行在JVM（Java虚拟机）上，而JVM负责将Java字节码转换为特定平台的机器码 1。
可移植指的是Java程序可以在不同的硬件和软件环境中保持一致的行为和结果。这是因为Java语言规范定义了一套严格的规则，例如数据类型的大小、数值运算的精度、字符编码等~~
JVM在哪里？怎么安装JVM？
不同的操作系统需要安装对应版本的JVM？
JDK JRE JVM三者关系？~"><meta property="og:type" content="article"><meta property="og:url" content="https://mykaneki.github.io/docs/java%E5%A4%8D%E4%B9%A0/"><meta property="og:image" content="https://mykaneki.github.io/docs/java%E5%A4%8D%E4%B9%A0/featured.jpg"><meta property="article:section" content="docs"><meta property="og:site_name" content="mykaneki's blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://mykaneki.github.io/docs/java%E5%A4%8D%E4%B9%A0/featured.jpg"><meta name=twitter:title content><meta name=twitter:description content="day03 Java语言的特性> day03 Java语言的特性 # ~
（1）Java的简单性
Java语言底层是C++，所以JVM是用C++语言写好的一个虚拟的电脑。
没有指针概念，不允许直接通过指针操作内存；java只支持单继承；
（2）Java的跨平台
（3）Java的健壮性
GC机制，自动垃圾回收机制
（4）Java完全面向对象
（5）Java语言支持多线程
~~
什么是跨平台，什么是可移植？~
​	java语言只要编写一次，可以做到到处运行。(.java - .class 字节码 - 机器码 JVM)
跨平台指的是Java程序可以在不同的操作系统上运行，而不需要修改源代码或重新编译。这是因为Java程序运行在JVM（Java虚拟机）上，而JVM负责将Java字节码转换为特定平台的机器码 1。
可移植指的是Java程序可以在不同的硬件和软件环境中保持一致的行为和结果。这是因为Java语言规范定义了一套严格的规则，例如数据类型的大小、数值运算的精度、字符编码等~~
JVM在哪里？怎么安装JVM？
不同的操作系统需要安装对应版本的JVM？
JDK JRE JVM三者关系？~"><script type=application/ld+json>[{"@context":"https://schema.org","@type":"Article","articleSection":"Docs","name":"","headline":"","abstract":"day03 Java语言的特性\u003e day03 Java语言的特性 # ~\n（1）Java的简单性\nJava语言底层是C\u002b\u002b，所以JVM是用C\u002b\u002b语言写好的一个虚拟的电脑。\n没有指针概念，不允许直接通过指针操作内存；java只支持单继承；\n（2）Java的跨平台\n（3）Java的健壮性\nGC机制，自动垃圾回收机制\n（4）Java完全面向对象\n（5）Java语言支持多线程\n~~\n什么是跨平台，什么是可移植？~\n​\tjava语言只要编写一次，可以做到到处运行。(.java - .class 字节码 - 机器码 JVM)\n跨平台指的是Java程序可以在不同的操作系统上运行，而不需要修改源代码或重新编译。这是因为Java程序运行在JVM（Java虚拟机）上，而JVM负责将Java字节码转换为特定平台的机器码 1。\n可移植指的是Java程序可以在不同的硬件和软件环境中保持一致的行为和结果。这是因为Java语言规范定义了一套严格的规则，例如数据类型的大小、数值运算的精度、字符编码等~~\nJVM在哪里？怎么安装JVM？\n不同的操作系统需要安装对应版本的JVM？\nJDK JRE JVM三者关系？~","inLanguage":"zh-cn","url":"https:\/\/mykaneki.github.io\/docs\/java%E5%A4%8D%E4%B9%A0\/","author":{"@type":"Person","name":"mykaneki"},"mainEntityOfPage":"true","wordCount":"1554"}]</script><meta name=author content="mykaneki"><link href=cmy_kaneki@qq.com rel=me><link href=https://github.com/mykaneki rel=me><script async src="https://www.googletagmanager.com/gtag/js?id=G-5MM4NB6CC9"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-5MM4NB6CC9",{anonymize_ip:!1})}</script><script src=https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js></script>
<script src=https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js></script>
<script src=https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js></script>
<script>const firebaseConfig={apiKey:"AIzaSyC5UrDhesjW3q1GpRz06wXtA8mFaJzCORk",authDomain:"AIzaSyC5UrDhesjW3q1GpRz06wXtA8mFaJzCORk",projectId:"mykaneki-github-page",storageBucket:"mykaneki-github-page.appspot.com",messagingSenderId:"615146370767",appId:"1:615146370767:web:ffa28dccc2b7017e77a9ba",measurementId:"G-5MM4NB6CC9"};var app=firebase.initializeApp(firebaseConfig),db=firebase.firestore(),auth=firebase.auth()</script></head><body class="flex flex-col h-screen px-6 m-auto text-lg leading-7 max-w-7xl bg-neutral text-neutral-900 dark:bg-neutral-800 dark:text-neutral sm:px-14 md:px-24 lg:px-32"><div id=the-top class="absolute flex self-center"><a class="px-3 py-1 text-sm -translate-y-8 rounded-b-lg bg-primary-200 focus:translate-y-0 dark:bg-neutral-600" href=#main-content><span class="font-bold text-primary-600 ltr:pr-2 rtl:pl-2 dark:text-primary-400">&darr;</span>Skip to main content</a></div><div style=padding-left:0;padding-right:0 class="flex items-center justify-between px-4 py-6 sm:px-6 md:justify-start space-x-3"><div class="flex flex-1 items-center justify-between"><nav class="flex space-x-3"><a href=/ class="text-base font-medium text-gray-500 hover:text-gray-900">mykaneki&rsquo;s blog</a></nav><div class="hidden md:flex items-center space-x-5 md:ml-12"><a href=/docs/ class="text-base font-medium text-gray-500 hover:text-gray-900" title=Docs>文档</a>
<a href=/posts/ class="text-base font-medium text-gray-500 hover:text-gray-900" title=Posts>文章</a>
<a href=/series/ class="text-base font-medium text-gray-500 hover:text-gray-900" title=Series>系列</a>
<button id=search-button class="text-base hover:text-primary-600 dark:hover:text-primary-400" title>
<span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></button><div class="ltr:mr-14 rtl:ml-14 cursor-pointer text-sm text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400"><button id=appearance-switcher type=button><div class="flex items-center justify-center h-12 dark:hidden"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="items-center justify-center hidden h-12 dark:flex"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button></div></div><div class="flex md:hidden items-center space-x-5 md:ml-12"><span></span>
<button id=search-button-mobile class="text-base hover:text-primary-600 dark:hover:text-primary-400" title>
<span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></button>
<button id=appearance-switcher-mobile type=button style=margin-right:5px><div class="flex items-center justify-center h-12 dark:hidden"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="items-center justify-center hidden h-12 dark:flex"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button></div></div><div class="-my-2 -mr-2 md:hidden"><label id=menu-button for=menu-controller class=block><input type=checkbox id=menu-controller class=hidden><div class="cursor-pointer hover:text-primary-600 dark:hover:text-primary-400"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentcolor" d="M0 96C0 78.33 14.33 64 32 64H416c17.7.0 32 14.33 32 32 0 17.7-14.3 32-32 32H32C14.33 128 0 113.7.0 96zM0 256c0-17.7 14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32H32c-17.67.0-32-14.3-32-32zM416 448H32c-17.67.0-32-14.3-32-32s14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32z"/></svg></span></div><div id=menu-wrapper style=padding-top:25px class="fixed inset-0 z-30 invisible w-screen h-screen m-auto overflow-auto transition-opacity opacity-0 cursor-default bg-neutral-100/50 backdrop-blur-sm dark:bg-neutral-900/50"><ul class="flex movedown flex-col w-full px-6 py-6 mx-auto overflow-visible list-none ltr:text-right rtl:text-left max-w-7xl sm:px-14 md:px-24 lg:px-32 sm:py-10 sm:pt-10"><li class=mb-1><span class="cursor-pointer hover:text-primary-600 dark:hover:text-primary-400"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentcolor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></span></li><li class=mb-1><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2" href=/docs/ title=Docs><span class="inline-block align-text-bottom"></span>文档</a></li><li class=mb-1><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2" href=/posts/ title=Posts><span class="inline-block align-text-bottom"></span>文章</a></li><li class=mb-1><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2" href=/series/ title=Series><span class="inline-block align-text-bottom"></span>系列</a></li></ul></div></label></div></div><div class="relative flex flex-col grow"><main id=main-content class=grow><article><div id=hero class="h-[150px] md:h-[200px]"></div><div class="fixed inset-x-0 top-0 h-[800px] single_hero_background nozoom" style=background-image:url(/docs/java%E5%A4%8D%E4%B9%A0/featured_huc10de423c5e055270d1fd83e0f3dd326_824846_1200x0_resize_q75_box.jpg)><div class="absolute inset-0 bg-gradient-to-t from-neutral dark:from-neutral-800 to-transparent mix-blend-normal"></div><div class="absolute inset-0 opacity-30 dark:opacity-60 bg-gradient-to-t from-neutral dark:from-neutral-800 to-neutral dark:to-neutral-800 mix-blend-normal"></div></div><div id=background-blur class="fixed opacity-0 inset-x-0 top-0 h-full single_hero_background nozoom backdrop-blur-2xl"></div><script>window.addEventListener("scroll",function(){var t=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,n=document.getElementById("background-blur");n.style.opacity=t/300})</script><header id=single_header class="mt-5 max-w-prose"><ol class="text-sm text-neutral-500 dark:text-neutral-400 print:hidden"><li class="inline hidden"><a class="hover:underline decoration-neutral-300 dark:underline-neutral-600" href=/>Documentation</a><span class="px-1 text-primary-500">/</span></li><li class=inline><a class="hover:underline decoration-neutral-300 dark:underline-neutral-600" href=/docs/>Docs</a><span class="px-1 text-primary-500">/</span></li><li class="inline hidden"><a class="hover:underline decoration-neutral-300 dark:underline-neutral-600" href=/docs/java%E5%A4%8D%E4%B9%A0/>docs</a><span class="px-1 text-primary-500">/</span></li></ol><h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral"></h1><div class="mt-1 mb-6 text-base text-neutral-500 dark:text-neutral-400 print:hidden"><div class="flex flex-row flex-wrap items-center"><span>1554 字</span><span class="px-2 text-primary-500">&#183;</span><span>
<span id=views_docs/Java复习/index.md title=views>0</span>
<span class="inline-block align-text-bottom"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path fill="currentcolor" d="M288 32c-80.8.0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7.0 24.6C17.3 304 48.6 356 95.4 399.4 142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1 3.3-7.9 3.3-16.7.0-24.6-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144 64.5-144 144-144 144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64-11.5.0-22.3-3-31.6-8.4-.2 2.8-.4 5.5-.4 8.4.0 53 43 96 96 96s96-43 96-96-43-96-96-96c-2.8.0-5.6.1-8.4.4 5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></span></span><span class="px-2 text-primary-500">&#183;</span><span>
<span id=likes_docs/Java复习/index.md title=likes>0</span>
<span class="inline-block align-text-bottom"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M47.6 300.4 228.3 469.1c7.5 7 17.4 10.9 27.7 10.9s20.2-3.9 27.7-10.9L464.4 300.4c30.4-28.3 47.6-68 47.6-109.5v-5.8c0-69.9-50.5-129.5-119.4-141C347 36.5 300.6 51.4 268 84L256 96 244 84c-32.6-32.6-79-47.5-124.6-39.9C50.5 55.6.0 115.2.0 185.1v5.8c0 41.5 17.2 81.2 47.6 109.5z"/></svg></span></span></span><span class="px-2 text-primary-500">&#183;</span><span>
<button id=likes_button class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400" onclick=process_article()>
<span id=likes_button_heart style=display:none class="inline-block align-text-bottom"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M47.6 300.4 228.3 469.1c7.5 7 17.4 10.9 27.7 10.9s20.2-3.9 27.7-10.9L464.4 300.4c30.4-28.3 47.6-68 47.6-109.5v-5.8c0-69.9-50.5-129.5-119.4-141C347 36.5 300.6 51.4 268 84L256 96 244 84c-32.6-32.6-79-47.5-124.6-39.9C50.5 55.6.0 115.2.0 185.1v5.8c0 41.5 17.2 81.2 47.6 109.5z"/></svg></span></span><span id=likes_button_emtpty_heart class="inline-block align-text-bottom"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M244 84l11.1 12 12-11.98C300.6 51.37 347 36.51 392.6 44.1 461.5 55.58 512 115.2 512 185.1V190.9c0 41.5-17.2 81.2-47.6 109.5L283.7 469.1c-7.5 7-17.4 10.9-27.7 10.9S235.8 476.1 228.3 469.1L47.59 300.4C17.23 272.1.0 232.4.0 190.9V185.1c0-69.9 50.52-129.52 119.4-141 44.7-7.59 92 7.27 124.6 39.9C243.1 84 244 84.01 244 84zm11.1 79.9-45-46.8c-21.7-20.82-52.5-30.7-82.8-25.66C81.55 99.07 48 138.7 48 185.1V190.9c0 28.2 11.71 55.2 32.34 74.4L256 429.3l175.7-164c20.6-19.2 32.3-46.2 32.3-74.4V185.1c0-46.4-33.6-86.03-79.3-93.66C354.4 86.4 323.6 96.28 301.9 117.1l-46.8 46.8z"/></svg></span></span><span id=likes_button_text>&nbsp;Like</span></button></span></div><div class="flex flex-row flex-wrap items-center"></div><div class="flex flex-row flex-wrap items-center"></div></div></header><section class="flex flex-col max-w-full mt-0 prose dark:prose-invert lg:flex-row"><div class="order-first sm:max-w-prose lg:ml-auto px-0 lg:order-last lg:max-w-xs ltr:lg:pl-8 rtl:lg:pr-8"><div class="toc ltr:pl-5 rtl:pr-5 print:hidden lg:sticky lg:top-10"><details open class="mt-0 overflow-hidden rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 hidden lg:block"><summary class="block py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">Table of Contents</summary><div class="min-w-[220px] py-2 border-dotted border-neutral-300 ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#day03-java语言的特性>day03 Java语言的特性</a></li><li><a href=#day04-path>day04 path</a></li><li><a href=#day05-变量数据类型>day05 变量、数据类型</a></li><li><a href=#day06-数据类型>day06 数据类型</a></li><li><a href=#day07-类型转换>day07 类型转换~</a></li><li><a href=#day08>day08</a></li><li><a href=#day-10>day 10</a></li><li><a href=#day-11>day 11</a></li><li><a href=#day-13-类-对象-构造方法>day 13 类 对象 构造方法~</a></li><li><a href=#day-16-this-继承>day 16 this 继承~</a></li><li><a href=#day-17-继承-多态>day 17 继承 多态</a></li><li><a href=#day-25>day 25</a></li><li><a href=#day-27-异常处理机制>day 27 异常处理机制</a></li><li><a href=#day-28-集合>day 28 集合</a><ul><li><a href=#arrarylist集合>ArraryList集合</a></li><li><a href=#linkedlist集合>LInkedList集合</a></li><li><a href=#vector集合>vector集合</a></li></ul></li><li><a href=#泛型>泛型</a></li></ul></nav></div></details><details class="mt-0 overflow-hidden rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 lg:hidden"><summary class="py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">Table of Contents</summary><div class="py-2 border-dotted border-neutral-300 ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#day03-java语言的特性>day03 Java语言的特性</a></li><li><a href=#day04-path>day04 path</a></li><li><a href=#day05-变量数据类型>day05 变量、数据类型</a></li><li><a href=#day06-数据类型>day06 数据类型</a></li><li><a href=#day07-类型转换>day07 类型转换~</a></li><li><a href=#day08>day08</a></li><li><a href=#day-10>day 10</a></li><li><a href=#day-11>day 11</a></li><li><a href=#day-13-类-对象-构造方法>day 13 类 对象 构造方法~</a></li><li><a href=#day-16-this-继承>day 16 this 继承~</a></li><li><a href=#day-17-继承-多态>day 17 继承 多态</a></li><li><a href=#day-25>day 25</a></li><li><a href=#day-27-异常处理机制>day 27 异常处理机制</a></li><li><a href=#day-28-集合>day 28 集合</a><ul><li><a href=#arrarylist集合>ArraryList集合</a></li><li><a href=#linkedlist集合>LInkedList集合</a></li><li><a href=#vector集合>vector集合</a></li></ul></li><li><a href=#泛型>泛型</a></li></ul></nav></div></details></div></div><div class="min-w-0 min-h-0 max-w-prose"><div id=day03-java语言的特性 class=anchor>day03 Java语言的特性></div><h2 class="relative group">day03 Java语言的特性
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#day03-java%e8%af%ad%e8%a8%80%e7%9a%84%e7%89%b9%e6%80%a7 aria-label=锚点>#</a></span></h2><p>~</p><p>（1）Java的简单性</p><p>Java语言底层是<strong>C++</strong>，所以JVM是用C++语言写好的一个虚拟的电脑。</p><p>没有指针概念，不允许直接通过指针操作内存；java只支持单继承；</p><p>（2）Java的跨平台</p><p>（3）Java的健壮性</p><p>GC机制，自动垃圾回收机制</p><p>（4）Java完全面向对象</p><p>（5）Java语言支持多线程</p><p>~~</p><p><strong>什么是跨平台，什么是可移植？</strong>~</p><p>​ java语言只要编写一次，可以做到到处运行。(.java - .class 字节码 - 机器码 JVM)</p><p>跨平台指的是Java程序可以在不同的操作系统上运行，而不需要修改源代码或重新编译。这是因为Java程序运行在JVM（Java虚拟机）上，而JVM负责将Java字节码转换为特定平台的机器码<a href="https://bing.com/search?q=java+%e8%b7%a8%e5%b9%b3%e5%8f%b0+%e5%8f%af%e7%a7%bb%e6%a4%8d" target=_blank>
1</a>。</p><p>可移植指的是Java程序可以在不同的硬件和软件环境中保持一致的行为和结果。这是因为Java语言规范定义了一套严格的规则，例如数据类型的大小、数值运算的精度、字符编码等~~</p><p><strong>JVM在哪里？怎么安装JVM？</strong></p><p><strong>不同的操作系统需要安装对应版本的JVM？</strong></p><p><strong>JDK JRE JVM三者关系？</strong>~</p><pre><code>JDK:Java开发工具箱
JRE:java运行环境
JVM:java虚拟机

JDK包括JRE，JRE包括JVM。

JVM是不能独立安装的。
JRE和JDK都是可以独立安装的。
有单独的JDK安装包。
也有单独的JRE安装包。
没有单独的JVM安装包。

安装JDK的时候：JRE就自动安装了，同时JRE内部的JVM也就自动安装了。
安装JRE的时候：JVM也就自动安装了。
</code></pre><p>~~</p><p><strong>java程序从开发到最终运行经历了什么？</strong>~</p><p>编译使用编译器（javac【JDK安装后自带】）对xxx.java文件进行编译和运行（JRE在起作用）</p><p>只有编译通过了才会生成class字节码文件</p><p>编译阶段和运行阶段<strong>可以在不同的操作系统中完成</strong>；</p><p>如果需要在不同系统上运行java代码，只需要拷贝<code>.class</code>文件并且有JRE~~</p><div id=day04-path class=anchor>day04 path></div><h2 class="relative group">day04 path
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#day04-path aria-label=锚点>#</a></span></h2><p><strong>怎么编译？使用什么命令？这个命令怎么用？</strong>~</p><p>为什么ipconfig、ping等命令可以使用呢？为什么javac用不了？
我们发现windows操作系统中有这样一个环境变量，名字叫做：path，
并且发现path环境变量的值是：
C:\Windows\system32;%SystemRoot%;%SystemRoot%\System32\Wbem;%SYSTEMROOT%\System32\WindowsPowerShell\v1.0<br>我们还发现了在：C:\Windows\System32 这个目录下存在：ipconfig.exe</p><pre><code>	注意：修改完环境变量之后，DOS命令窗口必须关闭重新打开才会起作用。
	注意：环境变量包括“系统变量”和“用户变量”
			系统变量：范围比较大，系统变量会让计算机所有用户都起作用。
			用户变量：范围比较小，这个变量只是作用于当前用户。
</code></pre><p>~~</p><p><strong>path环境变量的作用是什么？</strong>~
path环境变量的作用就是给windows操作系统指路的。
告诉windows操作系统去哪里找这个命令文件。~~</p><p><strong>java HelloWorld.class 对不对？？？？？</strong>~
不对！！！！
正确的写法是：
java HelloWorld~~</p><p><strong>“java HelloWorld”的执行过程以及原理。</strong>~</p><p>D:\course\JavaProjects\02-JavaSE\chapter01>java HelloWorld
敲完回车，都发生了什么？？？？？</p><ol><li><p>启动JVM</p></li><li><p>JVM启动类加载器<code>classloader</code>，在硬盘上寻找字节码文件</p><blockquote><p>找不到类对应的字节码文件会报错</p></blockquote><p><strong>默认从哪里开始找？如何让类加载器去指定的路径下加载字节码文件？</strong></p><p>默认情况下类加载器（classloader）会从当前路径下找。</p><p>我们需要设置一个环境变量，叫做：classpath，是给“类加载器”指路的，配置了classpath=D:\course之后，类加载器只会去D:\course目录下“xxx.class”文件不再从当前路径下找了。</p><blockquote><p>classpath环境变量不属于windows操作系统，classpath环境变量隶属于java。</p></blockquote></li></ol><p>~~</p><div id=day05-变量数据类型 class=anchor>day05 变量、数据类型></div><h2 class="relative group">day05 变量、数据类型
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#day05-%e5%8f%98%e9%87%8f%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b aria-label=锚点>#</a></span></h2><p><strong>什么是变量？变量的三要素？</strong>~
变量就是一个存数据盒子。（盒子大小谁来决定啊？数据类型）
在内存中的<strong>最基本</strong>的存储单元。
存数据用的，而且这个数据是<strong>可变的</strong>，所以叫做变量。~~</p><p><strong>变量的分类</strong>~</p><p>变量的分类可以依据声明的位置；</p><p>方法体当中声明的叫做<strong>局部变量</strong>，局部变量只在该方法体中有效，方法结束后该变量的内存就释放了；</p><p>方法体外，类体内，声明的变量叫做<strong>成员变量</strong>；</p><p>成员变量又包括：<strong>实例变量和静态变量</strong>；</p><p>成员变量被static修饰的叫做静态变量，没有被static修饰的叫做实例变量；</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 通过测试得出结论是：a,b没有赋值，c赋值100
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>int</span> a<span style=color:#f92672>,</span> b<span style=color:#f92672>,</span> c <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><p>~~</p><div id=day06-数据类型 class=anchor>day06 数据类型></div><h2 class="relative group">day06 数据类型
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#day06-%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b aria-label=锚点>#</a></span></h2><p><strong>数据类型有什么用？</strong>~</p><p>数据类型用来声明变量，程序在运行过程中根据不同的数据类型分配不同大小的空间。（确定盒子的大小）~~</p><p><strong>数据类型在java语言中包括两种</strong>~</p><p>基本数据类型、引用数据类型</p><p>java中整数型字面量被<strong>默认当做int类型来处理</strong>，想以long的形式表示需要在字面量后添加L/l</p><p>java开发中浮点型字面量默认被当做double来处理，想默认被当做float处理，需要在字面量后面添加F/f</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 编译器会报错吗？为什么？
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 在java中，整数型字面量一上来编译器就会将它看做int类型
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 而2147483648已经超出了int的范围，所以在没有赋值之前就出错了。
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 记住，不是e放不下2147483648，e是long类型，完全可以容纳2147483648
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 只不过2147483648本身已经超出了int范围。
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 错误: 整数太大
</span></span></span><span style=display:flex><span><span style=color:#75715e>//long e = 2147483648;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 怎么解决这个问题呢？
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>long</span> e <span style=color:#f92672>=</span> <span style=color:#ae81ff>2147483648L</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>e<span style=color:#f92672>);</span>
</span></span></code></pre></div><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/202302271511678.png alt=image-20230227151055566></figure></p><p>！！！</p><p>Java语言表达式所操作的<code>boolean</code>值，在编译之后都使用<code>Java</code>虚拟机中的<code>int</code>数据类型来代替，而<code>boolean</code>数组将会被编码成<code>Java</code>虚拟机的<code>byte</code>数组。（<strong>boolean类型数组的访问与修改共用byte类型数组的baload和 bastore指令</strong>，因为两者共用，只有两者字节一样才能通用呀）</p><p>有几个取值范围需要大家记住：
(1个字节)byte: [-128 ~ 127]
(2个字节)short:[-32768 ~ 32767] 可以表示65536个不同的数字
(4个字节)int: [-2147483648 ~ 2147483647]
(2个字节)char: [0~65535] 可以表示65536个不同的数字</p><pre><code>		short和char实际上容量相同，不过char可以表示更大的数字。
		因为char表示的是文字，文件没有正负之分，所以char可以表示
		更大的数字。
		
		char可以存储1个汉字吗？
		// 可以的，汉字占用2个字节，java中的char类型占用2个字节，正好。
</code></pre><p>~~</p><p><strong>float和double存储数据的时候都是存储的近似值。为什么？</strong>~</p><p>​ 因为现实世界中有这种无线循环的数据，例如：3.3333333333333&mldr;.</p><p>​ 数据实际上是无限循环，但是计算机的内存有限，用一个有限的资源</p><p>​ 表示无限的数据，只能存储近似值。</p><p>如果用在银行方面或者说使用在财务方面，double 也是远远不够的，在java中提供了一种精度更高的类型，这种类型专门 使用在财务软件方面：java.math**.BigDecimal** 不是基本数据类型，属于 引用数据类型。）</p><p>~~</p><div id=day07-类型转换 class=anchor>day07 类型转换~></div><h2 class="relative group">day07 类型转换~
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#day07-%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2 aria-label=锚点>#</a></span></h2><p>八种基本数据类型中，除 boolean 类型不能转换，剩下七种类型之间都可以进行转换</p><p>多种数据类型做混合运算的时候，最终的结果类型是“最大容量”对应的类型。 char+short+byte 这个除外。 因为char + short + byte混合运算的时候，会各自先转换成int再做运算。</p><p>大容量转换成小容量，可能出现精度损失，谨慎使用；</p><p>逻辑运算符：
& | ! && ||</p><p>逻辑运算符要求两边都是布尔类型，并且最终结果还是布尔类型。
左边是布尔类型 & 右边还是布尔类型 &ndash;>最终结果还是布尔类型。
& 两边都是true，结果才是true
| 一边是true，结果就是true
! 取反</p><pre><code>		&amp;&amp;实际上和&amp;运算结果完全相同，区别在于：&amp;&amp;有短路现象。
		左边的为false的时候：&amp;&amp; 短路了。

		左边为true的时候：|| 短路了。
</code></pre><p>~~</p><div id=day08 class=anchor>day08></div><h2 class="relative group">day08
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#day08 aria-label=锚点>#</a></span></h2><p><strong>控制语句包括几类？</strong>~
3类：
选择语句 if语句 switch语句
循环语句
转向语句</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>完整语法结构：</span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>switch</span><span style=color:#f92672>(</span><span style=color:#960050;background-color:#1e0010>值</span><span style=color:#f92672>){</span> <span style=color:#75715e>//值允许是String、int，（byte,short,char可以自动转换int）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#66d9ef>case</span> <span style=color:#960050;background-color:#1e0010>值</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>case</span> <span style=color:#960050;background-color:#1e0010>值</span>x<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>					java<span style=color:#960050;background-color:#1e0010>语句</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>break</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>case</span> <span style=color:#960050;background-color:#1e0010>值</span><span style=color:#ae81ff>2</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>					java<span style=color:#960050;background-color:#1e0010>语句</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>break</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>case</span> <span style=color:#960050;background-color:#1e0010>值</span><span style=color:#ae81ff>3</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>					java<span style=color:#960050;background-color:#1e0010>语句</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>break</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>					java<span style=color:#960050;background-color:#1e0010>语句</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>				<span style=color:#f92672>}</span>
</span></span></code></pre></div><p>~~</p><div id=day-10 class=anchor>day 10></div><h2 class="relative group">day 10
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#day-10 aria-label=锚点>#</a></span></h2><p><strong>public class 和class的区别</strong>~
一个java文件中可以定义多个class
一个class编译之后会生成1个class字节码文件，2个class编译之后会生成2个class文件
任何一个class中都可以编写main方法，每一个main方法都是一个入口，想选择其中任意一个入口进入，应该怎么做？</p><p>想从哪个入口进去执行，你就加载哪个类就行了！！！如：java T1、java T2</p><p>以下例子没有main可以编译但不可以运行</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Test2</span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Test3</span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>){</span>
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>public static void main(String[] args){ //这是一个入口方法。同一个类不能有两个入口。(args可以改名字，随意，对于主方法来说只有这个位置可以改，其它位置不能动)</p><p>类中写方法，方法中才写Java语句</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 以下程序符合java语法规则吗？
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 不是不运行，是编译报错。编译过不去，运行肯定不行。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Test5</span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 类体当中应该是方法，而不是直接的java语句
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 这里可以写吗？
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;hello1&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 主方法，入口
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>){</span>
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 这里可以写吗？
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;hello2&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>​ public的类可以没有
​ <strong>public的类如果有的话，只能有1个</strong>，并<strong>且public的类名要求和文件名一致。</strong>（如果和文件名不一致，报错信息如下：Test8.java:20: 错误: 类 B 是公共的, 应在名为 B.java 的文件中声明）~~</p><p><strong>标识符的命名规范？</strong>~
见名知意
驼峰命名方式，一高一低
类名、接口名：首字母大写，后面每个单词首字母大写。
变量名、方法名：首字母小写，后面每个单词首字母大写。
常量名：全部大写，每个单词之间使用下划线衔接。~~</p><p><strong>分析程序运行过程中的内存变化</strong>~
方法只定义不调用是不会执行的。
方法调用时：压栈 （在栈中给该方法分配空间）
方法执行结束时：弹栈（将该方法占用的空间释放，局部变量的内存也释放。）~~</p><p><strong>JVM的内存结构中三块比较重要的内存空间。</strong>~
方法区：
存储代码片段，存储xxx.class字节码文件，这个空间是最先有数据的，
类加载器首先将代码加载到这里。
堆内存：
后面讲（面向对象）
栈内存：
stack栈当中存储什么？
每个方法执行时所需要的内存空间（局部变量）。~~</p><div id=day-11 class=anchor>day 11></div><h2 class="relative group">day 11
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#day-11 aria-label=锚点>#</a></span></h2><p><strong>调用方法时，什么情况下“类名.”可以省略?</strong>~</p><p>a()方法调用b()方法的时候，a和b方法都在同一个类中，“类名.”可以省略。如果不在同一个类中“类名.”不能省略。~~</p><p><strong>break;语句和return;语句有什么区别？</strong>~</p><p>​ 不是一个级别。</p><p>​ break;用来止switch和离它最近的循环。</p><p>​ return;用来终止离它最近的一个方法。~~</p><p><strong>JVM主要内存空间</strong>~</p><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/202302272020902.png alt=image-20230227202055802></figure>~~</p><p><strong>计算n的阶乘</strong>~</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 使用递归的方式计算N的阶乘
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 5的阶乘：5 * 4 * 3 * 2 * 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 用递归的方式实现一个。
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 使用for循环的方式实现一个。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RecursionTest04</span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>){</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>int</span> jieGuo <span style=color:#f92672>=</span> jieCheng<span style=color:#f92672>(</span>n<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>		System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>jieGuo<span style=color:#f92672>);</span> <span style=color:#75715e>// 120
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>jieCheng2<span style=color:#f92672>(</span><span style=color:#ae81ff>5</span><span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>jieCheng2</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> n<span style=color:#f92672>){</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>int</span> result <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;=</span> n<span style=color:#f92672>;</span> i<span style=color:#f92672>++){</span>
</span></span><span style=display:flex><span>			result <span style=color:#f92672>*=</span> i<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>		<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> result<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>jieCheng</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> n<span style=color:#f92672>){</span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 5 * 4 * 3 * 2 * 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span><span style=color:#f92672>(</span>n <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>){</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>		<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>		int result = n * jieCheng(n - 1);
</span></span></span><span style=display:flex><span><span style=color:#75715e>		return result;
</span></span></span><span style=display:flex><span><span style=color:#75715e>		*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> n <span style=color:#f92672>*</span> jieCheng<span style=color:#f92672>(</span>n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>~~</p><div id=day-13-类-对象-构造方法 class=anchor>day 13 类 对象 构造方法~></div><h2 class="relative group">day 13 类 对象 构造方法~
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#day-13-%e7%b1%bb-%e5%af%b9%e8%b1%a1-%e6%9e%84%e9%80%a0%e6%96%b9%e6%b3%95 aria-label=锚点>#</a></span></h2><pre><code>这几个术语你需要自己能够阐述出来：
	类：不存在的，人类大脑思考总结一个模板（这个模板当中描述了共同特征。）
	对象：实际存在的个体。
	实例：对象还有另一个名字叫做实例。
	实例化：通过类这个模板创建对象的过程，叫做：实例化。
	抽象：多个对象具有共同特征，进行思考总结抽取共同特征的过程。

	类 --【实例化】--&gt; 对象(实例)
	对象 --【抽象】--&gt; 类
</code></pre><p>~~</p><p><strong>Java语言中，实例变量在访问的时候，是不是必须先创建对象？</strong>~</p><p>Java语言中，实例变量是属于对象的变量，必须先创建对象后，才可以通过这个对象来访问。而静态变量是属于类的变量，可以直接使用类名来引用，不需要创建对象。~~</p><p><strong>构造方法</strong>~</p><pre><code>	1.构造方法有什么作用？
	2.构造方法怎么定义，语法是什么？
	构造方法不需要指定返回值类型!!
	3.构造方法怎么调用，使用哪个运算符？
	4.什么是缺省构造器？
	5.怎么防止缺省构造器丢失？
	6.实例变量在类加载时初始化吗？实例变量在什么时候初始化？
</code></pre><p><figure><img class="my-0 rounded-md" src=https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1431/202302272040737.png alt=image-20230227204010631></figure></p><p>~~</p><p><strong>方法在调用的时候参数是如何传递的？</strong>~</p><p>在调用swap方法时，传递的是a和b的值的复制，而不是a和b本身。所以，在swap方法内部，交换了x和y的值，并不会影响到main方法内部的a和b的值。</p><p>如果参数是引用类型，那么传递的是引用变量的地址的复制，而不是对象本身。这样，被调用方法可以通过引用变量来访问和修改<strong>对象的属性</strong>，但是不能改变引用变量指向的对象。~~</p><p><strong>如何让swap方法真正地交换两个Person对象呢？</strong>~</p><p>使用一个数组来包装这两个对象，然后传递数组的引用。这样，被调用方法就可以改变数组中的元素，从而实现交换。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Test</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        Person p1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Tom&#34;</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>18</span><span style=color:#f92672>);</span> <span style=color:#75715e>// 创建一个Person对象，赋值给p1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Person p2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Jerry&#34;</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>20</span><span style=color:#f92672>);</span> <span style=color:#75715e>// 创建另一个Person对象，赋值给p2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Person<span style=color:#f92672>[]</span> arr <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>p1<span style=color:#f92672>,</span> p2<span style=color:#f92672>};</span> <span style=color:#75715e>// 创建一个数组，包含p1和p2指向的对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        swap<span style=color:#f92672>(</span>arr<span style=color:#f92672>);</span> <span style=color:#75715e>// 调用swap方法，传递arr的地址的复制
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;arr[0] = &#34;</span> <span style=color:#f92672>+</span> arr<span style=color:#f92672>[</span><span style=color:#ae81ff>0</span><span style=color:#f92672>]</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;, arr[1] = &#34;</span> <span style=color:#f92672>+</span> arr<span style=color:#f92672>[</span><span style=color:#ae81ff>1</span><span style=color:#f92672>]);</span> <span style=color:#75715e>// 输出arr中的元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>swap</span><span style=color:#f92672>(</span>Person<span style=color:#f92672>[]</span> x<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#75715e>// 定义swap方法，接收x的地址的复制
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Person temp <span style=color:#f92672>=</span> x<span style=color:#f92672>[</span><span style=color:#ae81ff>0</span><span style=color:#f92672>];</span> <span style=color:#75715e>// 交换x中的元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        x<span style=color:#f92672>[</span><span style=color:#ae81ff>0</span><span style=color:#f92672>]</span> <span style=color:#f92672>=</span> x<span style=color:#f92672>[</span><span style=color:#ae81ff>1</span><span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>        x<span style=color:#f92672>[</span><span style=color:#ae81ff>1</span><span style=color:#f92672>]</span> <span style=color:#f92672>=</span> temp<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;x[0] = &#34;</span> <span style=color:#f92672>+</span> x<span style=color:#f92672>[</span><span style=color:#ae81ff>0</span><span style=color:#f92672>]</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;, x[1] = &#34;</span> <span style=color:#f92672>+</span> x<span style=color:#f92672>[</span><span style=color:#ae81ff>1</span><span style=color:#f92672>]);</span> <span style=color:#75715e>// 输出x中的元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> age<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span><span style=color:#f92672>(</span>String name<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> age<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> age<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>运行这段代码，你会看到输出是：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>x<span style=color:#f92672>[</span><span style=color:#ae81ff>0</span><span style=color:#f92672>]</span> <span style=color:#f92672>=</span> Jerry<span style=color:#960050;background-color:#1e0010>@</span><span style=color:#ae81ff>74</span>a14482<span style=color:#f92672>,</span> x<span style=color:#f92672>[</span><span style=color:#ae81ff>1</span><span style=color:#f92672>]</span> <span style=color:#f92672>=</span> Tom<span style=color:#960050;background-color:#1e0010>@</span><span style=color:#ae81ff>4554617</span>c
</span></span><span style=display:flex><span>arr<span style=color:#f92672>[</span><span style=color:#ae81ff>0</span><span style=color:#f92672>]</span> <span style=color:#f92672>=</span> Jerry<span style=color:#960050;background-color:#1e0010>@</span><span style=color:#ae81ff>74</span>a14482<span style=color:#f92672>,</span> arr<span style=color:#f92672>[</span><span style=color:#ae81ff>1</span><span style=color:#f92672>]</span> <span style=color:#f92672>=</span> Tom<span style=color:#960050;background-color:#1e0010>@</span><span style=color:#ae81ff>4554617</span>c
</span></span></code></pre></div><p>~~</p><p><strong>对象和引用的区别？</strong>~</p><p>对象是通过new出来的，在堆内存中存储。
引用是在栈内存中存储的一个变量，它指向了对象在堆内存中的地址。~~</p><p><strong>实例变量在类加载时初始化吗？实例变量在什么时候初始化？类变量又是什么时候初始化的？</strong>~</p><p>类变量是属于类的，它们在加载类时初始化1。程序可以在两个地方对类变量进行初始化1：</p><p>定义类变量时指定初始值，如static int count = 0;
在静态初始化块中对类变量赋值，如static {count = 0;}</p><p><a href=https://blog.csdn.net/weixin_41814716/article/details/100020455 target=_blank>实例变量是属于对象的，它们在对象创建时初始化</a><a href=https://blog.csdn.net/weixin_41814716/article/details/100020455 target=_blank>
1</a><a href=https://www.cnblogs.com/walkingzq/p/8490383.html target=_blank>
2</a><a href=https://blog.csdn.net/weixin_41814716/article/details/100020455 target=_blank>
。程序可以在三个地方对实例变量进行初始化</a><a href=https://blog.csdn.net/weixin_41814716/article/details/100020455 target=_blank>
1</a>：</p><ul><li><p>定义实例变量时指定初始值，如<code>int age = 18;</code></p></li><li><p>在构造器中对实例变量赋值，如<code>this.age = age;</code>（注意，如果是默认的构造器，也是会赋默认值的）</p></li><li><p>在<strong>初始化块</strong>中对实例变量赋值，如<code>{age = 18;}</code></p><blockquote><p>初始化块是类中的一段代码块，用花括号括起来，它可以对类属性或对象属性进行初始化。</p><p>初始化块有两种：普通初始化块和静态初始化块。</p><p>普通初始化块在创建对象时隐式调用</p><p>静态初始化块在加载类时执行一次</p></blockquote></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>下面是一个代码例子，演示了三种对实例变量进行初始化的方式：</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//定义实例变量时指定初始值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    String name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Tom&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> age<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//在构造器中对实例变量赋值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> age<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> age<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//在初始化块中对实例变量赋值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;执行普通初始化块&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        age <span style=color:#f92672>=</span> <span style=color:#ae81ff>18</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Test</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        Person p <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person<span style=color:#f92672>(</span><span style=color:#ae81ff>20</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>p<span style=color:#f92672>.</span><span style=color:#a6e22e>name</span><span style=color:#f92672>);</span> <span style=color:#75715e>//输出Tom
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>p<span style=color:#f92672>.</span><span style=color:#a6e22e>age</span><span style=color:#f92672>);</span> <span style=color:#75715e>//输出20
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>~~</p><p><strong>静态和普通的初始化块同时出现的代码例子吗 ？ 那么如果有多个初始化块 ， 它们的执行顺序是怎样的呢 ？ 另外，不是说类体内只能写方法体吗？</strong>~</p><p>代码例子，同时使用了静态和普通的初始化块：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//定义类变量时指定初始值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    String name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Tom&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> age<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//在静态初始化块中对类变量赋值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>static</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;执行静态初始化块&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        count <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//在构造器中对实例变量赋值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> age<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> age<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//在普通初始化块中对实例变量赋值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;执行普通初始化块&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        age <span style=color:#f92672>=</span> <span style=color:#ae81ff>18</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Jerry&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Test</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        Person p1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person<span style=color:#f92672>(</span><span style=color:#ae81ff>20</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>p1<span style=color:#f92672>.</span><span style=color:#a6e22e>name</span><span style=color:#f92672>);</span> <span style=color:#75715e>//输出Jerry
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>p1<span style=color:#f92672>.</span><span style=color:#a6e22e>age</span><span style=color:#f92672>);</span> <span style=color:#75715e>//输出20
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>Person<span style=color:#f92672>.</span><span style=color:#a6e22e>count</span><span style=color:#f92672>);</span> <span style=color:#75715e>//输出1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        Person p2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person<span style=color:#f92672>(</span><span style=color:#ae81ff>30</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>p2<span style=color:#f92672>.</span><span style=color:#a6e22e>name</span><span style=color:#f92672>);</span> <span style=color:#75715e>//输出Jerry
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>p2<span style=color:#f92672>.</span><span style=color:#a6e22e>age</span><span style=color:#f92672>);</span> <span style=color:#75715e>//输出30
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>Person<span style=color:#f92672>.</span><span style=color:#a6e22e>count</span><span style=color:#f92672>);</span> <span style=color:#75715e>//输出1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>如果有多个初始化块，它们的执行顺序是这样的：</p><ul><li>静态初始化块按照它们在类体中出现的顺序执行一次，只有在第一次加载类时才会执行。</li><li>普通初始化块按照它们在类体中出现的顺序执行，每次创建对象时都会执行。</li><li>构造器最后执行，每次创建对象时都会执行。</li></ul><p>另外，你说的不是很准确。类体内可以写属性、方法、构造器、初始化块、内部类等成员。但是不能写任意的语句，比如<code>System.out.println("Hello");</code>就不是一个合法的成员。~</p><p><strong>{ System.out.println(&ldquo;Hello&rdquo;); } 加个花括号就可以写任意语句了吗</strong>~</p><p>不是的，加个花括号就变成了一个初始化块，它也是一个类的成员，不能随意写语句。初始化块的作用是对属性进行初始化，而不是执行其他的逻辑。如果你想在类体内写任意的语句，你可以把它们放在一个方法里面，然后调用这个方法。~~</p><p><strong>Java中 为什么不能在类体内直接执行语句~</strong></p><p>Java是一种面向对象的编程语言，它要求所有的代码都必须封装在类和方法中。类是一种抽象的数据类型，它定义了对象的属性和行为。方法是一种具体的操作，它实现了类的行为或功能。在类体内直接执行语句会破坏类的封装性和结构性，导致代码难以理解和维护。</p><p>如果你想要在类体内输出一些信息，你可以使用静态代码块或构造方法~~</p><div id=day-16-this-继承 class=anchor>day 16 this 继承~></div><h2 class="relative group">day 16 this 继承~
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#day-16-this-%e7%bb%a7%e6%89%bf aria-label=锚点>#</a></span></h2><p>（1）this在内存中是怎么存储的，this的本质是什么</p><p>this是一个关键字，全部小写。</p><p>this存储在<strong>堆内存的对象内部</strong>。</p><p><strong>this是一个变量，是一个引用，保存内存地址指向自身。</strong></p><p>（2）this可以使用在实例方法中，<strong>不能使用在静态方法中</strong></p><p>this使用在实例方法中，谁调用这个实例方法this就代表谁，<strong>this代表的是当前正在执行这个动作的对象</strong>，而静态方法的执行没有当前对象的参与，是通过“类名.”的方式访问的，固然在静态方法中是无法使用this的。</p><p>（3）在实例方法中，this什么时候可以省略，什么时候不能省略</p><p>实例方法中的“this.”多数情况下是可以省略的，但如果是为了区分局部变量和实例变量的话，不能省略。</p><p>（4）静态方法中可以直接访问本类中其他静态方法，不能直接访问本类中其他实例方法</p><p>（5）实例方法中可以直接访问本类中其他静态方法，也可以直接访问本类中其他实例方法</p><p>（6）一条法则：静态方法采用“类名.”方式访问，实例方法采用“引用.”方式访问。你需要记住“类名.”什么时候可以省略，“引用.”什么时候可以省略</p><p>（7）在当前的构造方法中使用“this(实参)”调用本类中其他构造方法</p><p>目的是代码复用。</p><p><strong>this()只能出现在构造方法第一行。</strong></p><p>~~</p><p><strong>子类继承父类，在创建子类对象时，构造方法是如何执行的</strong>~</p><p>（1）在创建子类的构造方法在执行的时候会先去调用父类的构造方法。</p><p>（2）虽然父类的构造方法执行了，但并<strong>不会创建父类对象</strong>，父类构造方法执行的作用是为了<strong>初始化当前子类对象中的父类型特征</strong>。</p><p>（3）创建子类对象的时候，Object类中的无参数构造方法是一定会执行的。</p><p>（4）当一个构造方法第一行没有显示的调用“this(参数)”，也没有显示的调用“super(参数)”时，<strong>默认</strong>会有一个“super();”</p><p>（5）this()和super()都只能出现在构造方法<strong>第一行</strong>，<strong>两者不能共存。</strong>~~</p><div id=day-17-继承-多态 class=anchor>day 17 继承 多态></div><h2 class="relative group">day 17 继承 多态
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#day-17-%e7%bb%a7%e6%89%bf-%e5%a4%9a%e6%80%81 aria-label=锚点>#</a></span></h2><p><strong>方法重载和方法覆盖有什么区别？</strong>~</p><pre><code>	方法重载发生在同一个类当中。

	方法覆盖是发生在具有继承关系的父子类之间。

	方法重载是一个类中，方法名相同，参数列表不同。

	方法覆盖是具有继承关系的父子类，并且重写之后的方法必须和之前的方法一致：
		方法名一致、参数列表一致、返回值类型一致。
</code></pre><p>~~</p><p><strong>向上转型和向下转型</strong>~</p><p>向上转型：子&mdash;>父 (upcasting)
又被称为自动类型转换：Animal a = new Cat();</p><p>向下转型：父&mdash;>子 (downcasting)
又被称为强制类型转换：Cat c = (Cat)a; 需要添加强制类型转换符。</p><p>ClassCastException（类型转换异常）</p><p>向下转型之前一定要使用<strong>instanceof</strong>运算符进行判断。~~</p><p><strong>什么是多态。</strong>~
多种形态，多种状态，编译和运行有两个不同的状态。
编译期叫做静态绑定。
运行期叫做动态绑定。</p><p>Animal a = new Cat();//编译看左边，方法看右边</p><p>~~</p><p><strong>final关键字</strong>~</p><ol><li>final修饰的类无法被继承</li><li>final修饰的方法无法被覆盖</li><li>final修饰的变量，只能赋一次值</li><li>final修饰的实例变量必须<strong>手动赋值</strong>，不能采用系统默认值。</li><li>final修饰的引用一旦指向某个对象，则不能再重新指向其它对象，但该引用指向的对象<strong>内部的数据是可以修改</strong>的。</li><li>final修饰的实例变量一般和static联合使用，称为<strong>常量</strong></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>double</span> PI <span style=color:#f92672>=</span> <span style=color:#ae81ff>3.1415926</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><p>~~</p><p><strong>抽象类和接口以及抽象类和接口的区别</strong> ~</p><ol><li><p>一个非抽象的类，继承抽象类，必须将抽象类中的抽象方法进行覆盖/重写/实现。所以，final和abstract不能联合使用，这两个关键字是对立的。</p></li><li><p><strong>抽象类有构造方法</strong>，这个构造方法是供子类使用的。</p></li><li><p>抽象类可以没有抽象方法，这样做仅仅是不让该类创建对象</p></li><li><p><code>public abstract void doSome();</code></p></li><li><p>java语言中凡是没有方法体的方法都是抽象方法？错</p><blockquote><p>Object类中就有很多方法都没有方法体，都是以“;”结尾的，但他们
都不是抽象方法，例如：
public native int hashCode();
这个方法底层调用了C++写的动态链接库程序。
前面修饰符列表中没有：abstract。有一个native。表示调用JVM本地程序。</p></blockquote></li></ol><p><strong>为什么抽象类不能被实例化？</strong>~</p><ul><li>抽象类是一种<strong>不完整的类</strong>，它包含了一些没有实现的抽象方法，所以不能直接创建对象。</li><li>抽象类是一种<strong>设计层面的概念</strong>，它用来表示一种共性的特征，而不是具体的实例。</li><li>抽象类是<strong>为了被继承而存在的</strong>，它要求子类必须重写它的抽象方法，否则子类也会变成抽象类</li></ul><p>抽象类就像一个模板或者一个规范，它定义了一些必须要有的功能，但是具体怎么实现这些功能，它不关心，交给子类去实现。所以你不能直接使用一个模板或者一个规范来创建对象，你需要先根据这个模板或者规范来创建一个具体的子类，然后再用这个子类来创建对象。~~</p><p><strong>接口基础语法</strong>~</p><p><code>[修饰符列表] interface 接口名{}</code></p><ol><li><p>接口中<strong>只</strong>允许出现<strong>常量和抽象方法</strong></p></li><li><p>接口是完全抽象的，没有构造方法，无法实例化。</p><blockquote><p>！<strong>抽象类有构造方法</strong>，这个构造方法是供子类使用的。</p></blockquote></li><li><p>一个完整的类声明的语法格式</p><p><code>public class MyClass extends Superclass implements MyInterface1,MyInterface2{}</code> ~~</p></li></ol><p><strong>抽象类和接口怎么选择</strong>~</p><p>接口和抽象类的概念不一样。接口是对动作的抽象，抽象类是对根源的抽象。抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。~~</p><p><strong>4个访问控制权限：控制的范围是什么？</strong>~</p><table><thead><tr><th>访问控制修饰符</th><th>本类</th><th>同包</th><th>子类</th><th>任意位置</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>默认</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>~~</p><p><strong>访问控制权限修饰符可以修饰什么？</strong>~
属性（4个都能用）
方法（4个都能用）
类（public和默认能用，其它不行。）
接口（public和默认能用，其它不行。）</p><div id=day-25 class=anchor>day 25></div><h2 class="relative group">day 25
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#day-25 aria-label=锚点>#</a></span></h2><p>~~</p><p><strong>StringBuffer/StringBuilder/String 有什么区别？怎么选择？只用StringBuffer可以完全替代String吗？</strong>~</p><ul><li>String是<strong>线程安全</strong>的字符串<strong>常量</strong></li></ul><blockquote><p>常量不可变，这意味着它可以被缓存和共享，从而节省内存和时间。字符串常量池就是一种缓存机制，可以避免创建重复的字符串对象。具体来说：当我们写 String s = “hello”; 时，JVM会先在字符串常量池中查找是否已经存在"hello"这个字符串对象，如果存在，则直接返回它的引用给s；如果不存在，则在字符串常量池中创建一个新的"hello"对象，并返回它的引用给s。</p></blockquote><ul><li>StringBuilder和StringBuffer都是字符串<strong>变量</strong>，区别在于是否线程安全。StringBuffer线程安全，StringBuilder不安全，因此性能略高。</li><li>只用StringBuffer不能完全替代String。有时候使用String更合适和高效。在需要一个不可变或者只需少量操作的字符串时，使用String会更合适和高效。</li><li>如果使用局部变量，使用StringBuilder，因为局部变量在栈里，不共享，没有线程安全问题。</li></ul><p>~~</p><p><strong>包装类的写法和继承的父类</strong>~</p><p>每个类型的包装类的构造方法的参数都有对应的基本数据类型和<strong>String类型</strong></p><table><thead><tr><th>基本数据类型</th><th>包装类型</th><th>父类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td><td>Number</td></tr><tr><td>short</td><td>Short</td><td>Number</td></tr><tr><td>int</td><td>Integer</td><td>Number</td></tr><tr><td>long</td><td>Long</td><td>Number</td></tr><tr><td>char</td><td>Character</td><td>Object</td></tr><tr><td>float</td><td>Float</td><td>Number</td></tr><tr><td>double</td><td>Double</td><td>Number</td></tr><tr><td>boolean</td><td>Boolean</td><td>Object</td></tr></tbody></table><p>~~</p><p><strong>自动装箱和自动拆箱</strong> ~</p><table><thead><tr><th>装箱（基本数据类型&mdash;>引用数据类型）</th><th>自动装箱</th></tr></thead><tbody><tr><td>Integer I = new Integer(123) ;</td><td>Integer x = 123 ;</td></tr><tr><td>Character c = new Character(&lsquo;a&rsquo;) ;</td><td>Character X = &lsquo;a&rsquo; ;</td></tr></tbody></table><table><thead><tr><th>拆箱（引用数据类型&mdash;>基本数据类型）</th><th>自动拆箱</th></tr></thead><tbody><tr><td>int retValue = i.intValue() ;</td><td>int y = x ;</td></tr><tr><td>double retValue = d.doubleValue() ;</td><td>double Y = new Double(13.14) ;</td></tr></tbody></table><p>~~</p><div id=day-27-异常处理机制 class=anchor>day 27 异常处理机制></div><h2 class="relative group">day 27 异常处理机制
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#day-27-%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86%e6%9c%ba%e5%88%b6 aria-label=锚点>#</a></span></h2><p><strong>异常分类</strong>~</p><p>Object下有Throwable（可抛出的）
Throwable下有两个分支：Error（不可处理，直接退出JVM）和Exception（可处理的）
Exception下有两个分支：
Exception的直接子类：编译时异常。
RuntimeException：运行时异常。</p><p>~~</p><p><strong>编译时异常发生在编译阶段，对吗？</strong> ~</p><p>不对，编译时异常和运行时异常，都是发生在<strong>运行阶段</strong>。编译阶段异常是不会发生的。因为异常的发生就是<strong>new异常对象</strong>，而程序运行阶段才可以new对象</p><p>~~</p><p><strong>main方法throws异常，会发生什么？</strong> ~</p><p>Java中异常发生之后如果一直上抛，最终抛给了main方法，main方法继续
向上抛，<strong>抛给了调用者JVM</strong>，JVM知道这个异常发生，只有一个结果。<strong>终止java程序</strong>的执行。</p><p>~~</p><div id=day-28-集合 class=anchor>day 28 集合></div><h2 class="relative group">day 28 集合
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#day-28-%e9%9b%86%e5%90%88 aria-label=锚点>#</a></span></h2><p><strong>集合是什么？能存储什么？</strong> ~</p><p>集合实际上就是一个<strong>容器</strong>。可以来容纳其它类型的数据。集合<strong>不能直接存储基本数据类型</strong>，另外集合也不能直接存储java对象，
集合中存储的是<strong>引用</strong>。</p><p>~~</p><p><strong>java中集合根据存储元素的方式分为两大类</strong> ~</p><p>一类是<strong>单个方式</strong>存储元素：
java.util.Collection;</p><p>一类是以<strong>键值对</strong>儿的方式存储元素
java.util.Map;</p><p>~~</p><p><strong>迭代器注意事项</strong> ~</p><p>迭代器迭代元素的过程中<strong>不能使用</strong>集合对象的remove方法删除元素，<strong>要使用</strong>迭代器Iterator的remove方法来删除元素，防止出现异常：<code>ConcurrentModificationException</code></p><p>~~</p><p><strong>为什么使用集合的remove方法会报错？</strong> ~</p><p>迭代器实际上是集合的快照，使用集合的remove方法，会使得原型和快照不一致。但是用Iterator的remove方法来删除元素，则快照和原型都会一起删除。</p><p>~~</p><p><strong>ArraryList、LInkedList、vector</strong> 初始化容量、底层是什么数据结构、扩容大小、优缺点、线程安全吗？~</p><div id=arrarylist集合 class=anchor>ArraryList集合></div><h3 class="relative group">ArraryList集合
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#arrarylist%e9%9b%86%e5%90%88 aria-label=锚点>#</a></span></h3><ol><li><p>当第一个元素添加进去时，初始化容量为10.</p></li><li><p>底层是数组。</p></li><li><p>每次扩容都扩容到原容量的1.5倍。</p></li><li><p>平时使用什么集合最多？</p></li></ol><p>ArrayList集合。因为往数组末尾添加元素，效率不受影响。另外，我们平时检索和查找的操作较多。</p><div id=linkedlist集合 class=anchor>LInkedList集合></div><h3 class="relative group">LInkedList集合
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#linkedlist%e9%9b%86%e5%90%88 aria-label=锚点>#</a></span></h3><ol><li>无初始化容量</li><li>底层是双向链表</li><li>add第一个元素时，first和last都指向这第一个元素（参考源码）</li></ol><div id=vector集合 class=anchor>vector集合></div><h3 class="relative group">vector集合
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#vector%e9%9b%86%e5%90%88 aria-label=锚点>#</a></span></h3><ol><li>初始化容量为10。</li><li>底层是数组。</li><li>每次扩容都扩容到原来的两倍。</li><li>线程安全但效率较低。</li><li>把非线程安全的arraylist转换成线程安全的vector的方法。</li></ol><p><code>Collections.synchronizedList(myList);</code></p><ol start=6><li>Collections类是一个工具类，Collection是一个接口。</li></ol><p>~~</p><div id=泛型 class=anchor>泛型></div><h2 class="relative group">泛型
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e6%b3%9b%e5%9e%8b aria-label=锚点>#</a></span></h2><p><strong>优缺点</strong> ~</p><ol><li><p>泛型只在<strong>编译阶段</strong>起作用，给编译器参考，运行阶段意义不大</p></li><li><p>优点</p></li><li><ol><li>集合中存储的类型统一了</li><li>从集合中取出的元素是泛型指定的类型，不需要进行大量“向下转型”。</li></ol></li></ol><p>※ 注意：若是要调用子类特有方法，还是需要转型</p><ol><li>缺点：导致集合中存储的元素<strong>缺乏多样性</strong></li></ol><p>~~</p><p><strong>遍历Map集合的两种方式</strong> ~</p><p>第一种方式：获取所有的key，通过遍历key，来遍历value</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>        <span style=color:#75715e>// 获取所有的key，所有的key是一个Set集合
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Set<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> keys <span style=color:#f92672>=</span> map<span style=color:#f92672>.</span><span style=color:#a6e22e>keySet</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 遍历key，通过key获取value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 迭代器可以
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Iterator<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> it <span style=color:#f92672>=</span> keys<span style=color:#f92672>.</span><span style=color:#a6e22e>iterator</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span><span style=color:#f92672>(</span>it<span style=color:#f92672>.</span><span style=color:#a6e22e>hasNext</span><span style=color:#f92672>()){</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 取出其中一个key
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            Integer key <span style=color:#f92672>=</span> it<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 通过key获取value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            String value <span style=color:#f92672>=</span> map<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>key<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>key <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;=&#34;</span> <span style=color:#f92672>+</span> value<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// foreach也可以
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span><span style=color:#f92672>(</span>Integer key <span style=color:#f92672>:</span> keys<span style=color:#f92672>){</span>
</span></span><span style=display:flex><span>            System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>key <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;=&#34;</span> <span style=color:#f92672>+</span> map<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>key<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span></code></pre></div><p>第二种方式：Set&lt;Map.Entry&lt;K,V&#187; entrySet()，把Map集合直接全部转换成Set集合。Set集合中元素的类型是：Map.Entry</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>        <span style=color:#75715e>// 以上这个方法是把Map集合直接全部转换成Set集合。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// Set集合中元素的类型是：Map.Entry
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Set<span style=color:#f92672>&lt;</span>Map<span style=color:#f92672>.</span><span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>,</span>String<span style=color:#f92672>&gt;&gt;</span> set <span style=color:#f92672>=</span> map<span style=color:#f92672>.</span><span style=color:#a6e22e>entrySet</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 遍历Set集合，每一次取出一个Node
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 迭代器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       Iterator<span style=color:#f92672>&lt;</span>Map<span style=color:#f92672>.</span><span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>,</span>String<span style=color:#f92672>&gt;&gt;</span> it2 <span style=color:#f92672>=</span> set<span style=color:#f92672>.</span><span style=color:#a6e22e>iterator</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span><span style=color:#f92672>(</span>it2<span style=color:#f92672>.</span><span style=color:#a6e22e>hasNext</span><span style=color:#f92672>()){</span>
</span></span><span style=display:flex><span>            Map<span style=color:#f92672>.</span><span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>,</span>String<span style=color:#f92672>&gt;</span> node <span style=color:#f92672>=</span> it2<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            Integer key <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span><span style=color:#a6e22e>getKey</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            String value <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span><span style=color:#a6e22e>getValue</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>key <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;=&#34;</span> <span style=color:#f92672>+</span> value<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// foreach
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 这种方式效率比较高，因为获取key和value都是直接从node对象中获取的属性值。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 这种方式比较适合于大数据量。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span><span style=color:#f92672>(</span>Map<span style=color:#f92672>.</span><span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>,</span>String<span style=color:#f92672>&gt;</span> node <span style=color:#f92672>:</span> set<span style=color:#f92672>){</span>
</span></span><span style=display:flex><span>            System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>node<span style=color:#f92672>.</span><span style=color:#a6e22e>getKey</span><span style=color:#f92672>()</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;---&gt;&#34;</span> <span style=color:#f92672>+</span> node<span style=color:#f92672>.</span><span style=color:#a6e22e>getValue</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span></code></pre></div><p><strong>map.put(k,v) 原理</strong> ~</p><ol><li>先将k、v封装到Node对象当中</li><li>底层调用k的hashcode方法得出hash值</li><li>根据hash值计算放在哪个数组，若数组为null直接放，若有链表，则将新k与原来的k进行equals，如果TRUE就覆盖，false的就添加到链表末尾</li></ol><p>~~</p><p><strong>v=map.get(k)原理</strong> ~</p><ol><li>先计算k的hashcode，找到数组下标</li><li>如果该数组没有链表，返回null</li><li>如果有，那就有，对k使用equals，TRUE则返回，false则返回v</li></ol><p>~~</p><p><strong>hashmap集合底层数据结构、默认初始容量、默认加载因子、扩容大小</strong> ~</p><p><strong>数组+链表+红黑树</strong>，如果哈希表单向链表中的元素超过8个，单向链表就会变成红黑树，而当红黑树上的结点数量小于6时，会变回单向链表。</p><p>默认初始化容量为16，默认加载因子为0.75，扩容到原来容量的2倍</p><p>~~</p><p><strong>为什么HashMap集合初始化容量必须是2的倍数</strong> ~</p><p>HashMap的底层数据结构是数组+链表+红黑树。将元素放在table数组上面，是用hash值%数组大小定位位置，而HashMap是用hash值& (数组大小-1)，却能和前面达到一样的效果，这就得益于HashMap的大小必须是2的倍数</p><p>~~</p><p><strong>为什么扩容因子是0.75</strong>~</p><p>扩容因子也叫负载因子，表示一个散列表空间的使用程度。所以负载因子越大则散列表的装填程度越高，也就是能容纳更多的元素，元素多了，链表大了，所以此时索引效率就会降低。反之，负载因子越小则链表中的数据量就越稀疏，此时会对空间造成烂费，但是此时索引效率高。</p><p>而0.75的原因和泊松分布有关。用0.75作为加载因子，每个碰撞位置的链表长度超过８个是几乎不可能的。</p><p>~~</p><p><strong>对自定义的类型来说，TreeSet可以排序吗</strong>~</p><p>放到TreeSet或者TreeMap集合key部分的元素要想做到排序,包括两种方式：</p><p>​ 第一种：存放在key部分的元素实现java.lang.Comparable接口。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>compareTo</span><span style=color:#f92672>(</span>Vip v<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 写排序规则，按照什么进行比较。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>age</span> <span style=color:#f92672>==</span> v<span style=color:#f92672>.</span><span style=color:#a6e22e>age</span><span style=color:#f92672>){</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 年龄相同时按照名字排序。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 姓名是String类型，可以直接比。调用compareTo来完成比较。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>name</span><span style=color:#f92672>.</span><span style=color:#a6e22e>compareTo</span><span style=color:#f92672>(</span>v<span style=color:#f92672>.</span><span style=color:#a6e22e>name</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 年龄不一样
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>age</span> <span style=color:#f92672>-</span> v<span style=color:#f92672>.</span><span style=color:#a6e22e>age</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span></code></pre></div><p>​ 第二种：创建TreeMap集合时通过构造方法传递一个比较器，比较器实现java.util.Comparator接口。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 给构造方法传递一个比较器。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//TreeSet&lt;WuGui&gt; wuGuis = new TreeSet&lt;&gt;(new WuGuiComparator());
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 大家可以使用匿名内部类的方式（这个类没有名字。直接new接口。）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        TreeSet<span style=color:#f92672>&lt;</span>WuGui<span style=color:#f92672>&gt;</span> wuGuis <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> TreeSet<span style=color:#f92672>&lt;&gt;(</span><span style=color:#66d9ef>new</span> Comparator<span style=color:#f92672>&lt;</span>WuGui<span style=color:#f92672>&gt;()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>compare</span><span style=color:#f92672>(</span>WuGui o1<span style=color:#f92672>,</span> WuGui o2<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> o1<span style=color:#f92672>.</span><span style=color:#a6e22e>age</span> <span style=color:#f92672>-</span> o2<span style=color:#f92672>.</span><span style=color:#a6e22e>age</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>});</span>
</span></span></code></pre></div><p>~~</p><p><strong>Comparable和Comparator怎么选择呢？</strong>~</p><p>当比较规则不会发生改变的时候，或者说当比较规则只有1个的时候，建议实现Comparable接口。</p><p>如果比较规则有多个，并且需要多个比较规则之间频繁切换，建议使用Comparator接口。</p><p>~~</p><p><strong>hashmap、hashtable、concurrenthashmap的区别</strong> ~</p><p>HashMap、HashTable和ConcurrentHashMap都是基于数组+链表的数据结构，用于存储键值对。它们的主要区别如下：</p><p>HashMap是非线程安全的，也就是说多个线程同时操作HashMap可能会导致数据不一致。HashTable和ConcurrentHashMap都是线程安全的，可以在多线程环境下使用。
HashTable使用单一锁来保护整个哈希表，这意味着每次修改数据时都需要锁住整个哈希表，效率较低。ConcurrentHashMap使用分段锁来保护哈希表的不同部分，这样可以减少锁的竞争，提高并发性能。
HashMap允许键和值为null，而HashTable和ConcurrentHashMap不允许键和值为null。
HashMap属于传统的集合框架（Collection framework），而ConcurrentHashMap属于并发的集合框架（Executor framework）。</p><p>~~</p><p><strong>Collections集合工具类</strong>~
怎么获取一个线程安全的ArrayList
集合排序：Collections.sort(collection)</p><p>~~</p><p><strong>Java中有三大变量？</strong> ~</p><pre><code>实例变量：在堆中。

静态变量：在方法区。

局部变量：在栈中。

以上三大变量中：
	局部变量永远都不会存在线程安全问题。
	因为局部变量不共享。（一个线程一个栈。）
	局部变量在栈中。所以局部变量永远都不会共享。

实例变量在堆中，堆只有1个。
静态变量在方法区中，方法区只有1个。
堆和方法区都是多线程共享的，所以可能存在线程安全问题。

局部变量+常量：不会有线程安全问题。
成员变量：可能会有线程安全问题。
</code></pre><p>~~</p><p><strong>以后开发中应该怎么解决线程安全问题？</strong>~</p><pre><code>是一上来就选择线程同步吗？synchronized
	不是，synchronized会让程序的执行效率降低，用户体验不好。
	系统的用户吞吐量降低。用户体验差。在不得已的情况下再选择
	线程同步机制。

第一种方案：尽量使用局部变量代替“实例变量和静态变量”。适用于无状态的对象

第二种方案：如果必须是实例变量，那么可以考虑创建多个对象，这样
实例变量的内存就不共享了。适用于有状态但是不需要共享状态的对象（一个线程对应1个对象，100个线程对应100个对象，
对象不共享，就没有数据安全问题了。）

第三种方案：如果不能使用局部变量，对象也不能创建多个，这个时候
就只能选择synchronized了。线程同步机制。适用于有状态并且需要共享状态的对象
</code></pre><p>~~</p><p><strong>死锁代码</strong>~</p><p>开发中synchronize不要嵌套使用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> com.bjpowernode.java.deadlock<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>死锁代码要会写。
</span></span></span><span style=display:flex><span><span style=color:#75715e>一般面试官要求你会写。
</span></span></span><span style=display:flex><span><span style=color:#75715e>只有会写的，才会在以后的开发中注意这个事儿。
</span></span></span><span style=display:flex><span><span style=color:#75715e>因为死锁很难调试。
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DeadLock</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        Object o1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        Object o2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// t1和t2两个线程共享o1,o2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Thread t1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MyThread1<span style=color:#f92672>(</span>o1<span style=color:#f92672>,</span>o2<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        Thread t2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MyThread2<span style=color:#f92672>(</span>o1<span style=color:#f92672>,</span>o2<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        t1<span style=color:#f92672>.</span><span style=color:#a6e22e>start</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        t2<span style=color:#f92672>.</span><span style=color:#a6e22e>start</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyThread1</span> <span style=color:#66d9ef>extends</span> Thread<span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    Object o1<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    Object o2<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>MyThread1</span><span style=color:#f92672>(</span>Object o1<span style=color:#f92672>,</span>Object o2<span style=color:#f92672>){</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>o1</span> <span style=color:#f92672>=</span> o1<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>o2</span> <span style=color:#f92672>=</span> o2<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span><span style=color:#f92672>(){</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>synchronized</span> <span style=color:#f92672>(</span>o1<span style=color:#f92672>){</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>sleep</span><span style=color:#f92672>(</span><span style=color:#ae81ff>1000</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>InterruptedException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                e<span style=color:#f92672>.</span><span style=color:#a6e22e>printStackTrace</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>synchronized</span> <span style=color:#f92672>(</span>o2<span style=color:#f92672>){</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyThread2</span> <span style=color:#66d9ef>extends</span> Thread <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    Object o1<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    Object o2<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>MyThread2</span><span style=color:#f92672>(</span>Object o1<span style=color:#f92672>,</span>Object o2<span style=color:#f92672>){</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>o1</span> <span style=color:#f92672>=</span> o1<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>o2</span> <span style=color:#f92672>=</span> o2<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span><span style=color:#f92672>(){</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>synchronized</span> <span style=color:#f92672>(</span>o2<span style=color:#f92672>){</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>sleep</span><span style=color:#f92672>(</span><span style=color:#ae81ff>1000</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>InterruptedException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                e<span style=color:#f92672>.</span><span style=color:#a6e22e>printStackTrace</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>synchronized</span> <span style=color:#f92672>(</span>o1<span style=color:#f92672>){</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>~~</p><p><strong>实现定时器</strong>~</p><p>在java的类库中已经写好了一个定时器：java.util.Timer，可以直接拿来用。
不过，这种方式在目前的开发中也很少用，因为现在有很多高级框架都是支持
定时任务的。</p><pre><code>在实际的开发中，目前使用较多的是Spring框架中提供的SpringTask框架，
这个框架只要进行简单的配置，就可以完成定时器的任务。
</code></pre><p>使用反射机制和多态有关系吗</p><ul><li>什么是反射机制？有什么作用？</li><li>反射机制如何获取 Class 对象？</li><li>反射机制如何创建对象？</li><li>反射机制如何访问私有成员？</li><li>反射机制有什么优缺点？</li><li>什么是多态？有什么作用？</li><li>多态的实现方式有哪些？</li><li>多态的运行时绑定原理是什么？</li><li>多态中如何调用父类特有方法？</li><li>private修饰的方法可以通过反射访问，那么private意义何在？
答：首先java的private修饰符并不是为了安全性设计的，private并不是解决“安全”问题的。private想表达的不是“安全性”的意思，而是面向对象编程的封装概念，是一种编译器可以帮助我们在设计上的一个点。private的设计理念是对一个类的封装，而封装带来的好处是，在项目开发过程当中，修改一个类的private属性是不影响使用的，因为不存在对private代码的显式引用。反射技术主要是为实现一些开发工具以及框架服务。在实际的开发过程当中，我们应该尽量避免使用反射。而在使用反射时也要非常小心。</li><li>反射和多态的区别<ul><li>同为运行时获取信息，多态获取的信息仅仅在于确定方法应用所指向的实际对象。而反射在于获取一个类的所有信息。</li><li>多态是一种面向对象语言的机制。而反射技术是java提供的专门用于动态获取类的信息的技术。</li></ul></li></ul></br></br></div><script>var oid="views_docs/Java复习/index.md",oid_likes="likes_docs/Java复习/index.md"</script><script type=text/javascript src=/js/page.min.0e49973b4ad0a382c7c6012d8bff8226316642daabc4f8a20477bd08674f3da6e2fa993bc20ad4f51e7c5bb68e6f913a207a7c4fe37ea0e7b806894afce0a64e.js integrity="sha512-DkmXO0rQo4LHxgEti/+CJjFmQtqrxPiiBHe9CGdPPabi+pk7wgrU9R58W7aOb5E6IHp8T+N+oOe4BolK/OCmTg=="></script></section><footer class="pt-8 max-w-prose print:hidden"><section class="flex flex-row flex-wrap justify-center pt-4 text-xl"><a target=_blank class="m-1 rounded bg-neutral-300 p-1.5 text-neutral-700 hover:bg-primary-500 hover:text-neutral dark:bg-neutral-700 dark:text-neutral-300 dark:hover:bg-primary-400 dark:hover:text-neutral-800" href="mailto:?body=https://mykaneki.github.io/docs/java%E5%A4%8D%E4%B9%A0/&amp;subject=" title=通过电子邮件发送 aria-label=通过电子邮件发送><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M207.8 20.73c-93.45 18.32-168.7 93.66-187 187.1-27.64 140.9 68.65 266.2 199.1 285.1 19.01 2.888 36.17-12.26 36.17-31.49l1e-4-.6631c0-15.74-11.44-28.88-26.84-31.24-84.35-12.98-149.2-86.13-149.2-174.2.0-102.9 88.61-185.5 193.4-175.4 91.54 8.869 158.6 91.25 158.6 183.2v16.16c0 22.09-17.94 40.05-40 40.05s-40.01-17.96-40.01-40.05v-120.1c0-8.847-7.161-16.02-16.01-16.02l-31.98.0036c-7.299.0-13.2 4.992-15.12 11.68-24.85-12.15-54.24-16.38-86.06-5.106-38.75 13.73-68.12 48.91-73.72 89.64-9.483 69.01 43.81 128 110.9 128 26.44.0 50.43-9.544 69.59-24.88 24 31.3 65.23 48.69 109.4 37.49C465.2 369.3 496 324.1 495.1 277.2V256.3c0-149.2-133.9-265.632-287.3-235.57zM239.1 304.3c-26.47.0-48-21.56-48-48.05s21.53-48.05 48-48.05 48 21.56 48 48.05-20.6 48.05-48 48.05z"/></svg></span></a></section><div class=pt-8><hr class="border-dotted border-neutral-300 dark:border-neutral-600"><div class="flex justify-between pt-3"><span><a class="flex group mr-3" href=/docs/%E6%9D%82%E8%AE%B0/><span class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400">&larr;</span>
<span class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400">&rarr;</span>
<span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">杂记</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"></span></span></a></span><span><a class="flex text-right group ml-3" href=/docs/%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%E9%A1%B9%E7%9B%AE/><span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500"></span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"></span></span><span class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400">&rarr;</span>
<span class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400">&larr;</span></a></span></div></div></footer></article><div class="pointer-events-none absolute top-[100vh] bottom-0 w-12 ltr:right-0 rtl:left-0"><a href=#the-top class="pointer-events-auto sticky top-[calc(100vh-5.5rem)] flex h-12 w-12 mb-16 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 backdrop-blur hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400" aria-label title>&uarr;</a></div></main><footer class="py-10 print:hidden"><nav class="flex flex-row pb-4 text-base font-medium text-neutral-500 dark:text-neutral-400"><ul class="flex flex-col list-none sm:flex-row"><li class="flex mb-1 ltr:text-right rtl:text-left sm:mb-0 ltr:sm:mr-7 ltr:sm:last:mr-0 rtl:sm:ml-7 rtl:sm:last:ml-0"><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2" href=/tags/ title=Tags>标签</a></li><li class="flex mb-1 ltr:text-right rtl:text-left sm:mb-0 ltr:sm:mr-7 ltr:sm:last:mr-0 rtl:sm:ml-7 rtl:sm:last:ml-0"><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2" href=/series/ title=Series>系列</a></li></ul></nav><div class="flex items-center justify-between"><p class="text-sm text-neutral-500 dark:text-neutral-400">&copy;
2023
mykaneki</p><p class="text-xs text-neutral-500 dark:text-neutral-400">由 <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://gohugo.io/ target=_blank rel="noopener noreferrer">Hugo</a> & <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://blowfish.page/ target=_blank rel="noopener noreferrer">Blowfish</a> 强力驱动</p></div><script>mediumZoom(document.querySelectorAll("img:not(.nozoom)"),{margin:24,background:"rgba(0,0,0,0.5)",scrollOffset:0})</script><script type=text/javascript src=/js/process.min.2166d3adac1679c00a75161830ab5725d3efc0e3d3f8c2453fb01d0907948436c25f0f8a7ad824322fa22f3f9c85fd4d0a1d5c856f53b862157da25a57dc3d52.js integrity="sha512-IWbTrawWecAKdRYYMKtXJdPvwOPT+MJFP7AdCQeUhDbCXw+KetgkMi+iLz+chf1NCh1chW9TuGIVfaJaV9w9Ug=="></script></footer><div id=search-wrapper class="invisible fixed inset-0 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm dark:bg-neutral-900/50 sm:p-6 md:p-[10vh] lg:p-[12vh]" data-url=https://mykaneki.github.io/ style=z-index:500><div id=search-modal class="flex flex-col w-full max-w-3xl min-h-0 mx-auto border rounded-md shadow-lg top-20 border-neutral-200 bg-neutral dark:border-neutral-700 dark:bg-neutral-800"><header class="relative z-10 flex items-center justify-between flex-none px-2"><form class="flex items-center flex-auto min-w-0"><div class="flex items-center justify-center w-8 h-8 text-neutral-400"><span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></div><input type=search id=search-query class="flex flex-auto h-12 mx-1 bg-transparent appearance-none focus:outline-dotted focus:outline-2 focus:outline-transparent" placeholder=Search tabindex=0></form><button id=close-search-button class="flex items-center justify-center w-8 h-8 text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400" title="Close (Esc)">
<span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentcolor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></button></header><section class="flex-auto px-2 overflow-auto"><ul id=search-results></ul></section></div></div></div></body></html>