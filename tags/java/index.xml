<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on mykaneki's blog</title><link>https://mykaneki.github.io/tags/java/</link><description>Recent content in Java on mykaneki's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 07 Jan 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://mykaneki.github.io/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>饿了么项目总结</title><link>https://mykaneki.github.io/posts/%E9%A5%BF%E4%BA%86%E4%B9%88%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</link><pubDate>Fri, 07 Jan 2022 00:00:00 +0000</pubDate><guid>https://mykaneki.github.io/posts/%E9%A5%BF%E4%BA%86%E4%B9%88%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</guid><description>饿了么项目总结> 饿了么项目总结 # jdbc学习
注册驱动
告诉java程序即将连接哪个品牌的数据库 使用了资源绑定器绑定属性配置文件bundle.getString(&amp;ldquo;DRIVER&amp;rdquo;); 获取连接
表示JVM的进程和数据库进程之间的通道打开了，属于进程之间的通信。消耗大，使用完必须关闭 获取数据库对象
执行SQL
有两种方法：statement和preparedstatement
preparedstatement statement 编译一次执行多次，效率更高 编译一次执行一次 解决SQL注入问题 存在SQL注入问题 会在编译阶段做类型的安全检查 大多数情况都用预编译 需要进行SQL语句拼接的时候才用（例如：商城的升序和降序） SQL注入
sql语句： select * from user where loginName = '&amp;quot;+loginName+&amp;quot;' and loginPwd = '&amp;quot;+loginPwd+&amp;quot;'</description></item><item><title>细节或技巧</title><link>https://mykaneki.github.io/docs/%E7%BB%86%E8%8A%82%E6%88%96%E6%8A%80%E5%B7%A7/</link><pubDate>Sun, 03 Jan 2021 00:00:00 +0000</pubDate><guid>https://mykaneki.github.io/docs/%E7%BB%86%E8%8A%82%E6%88%96%E6%8A%80%E5%B7%A7/</guid><description>数组越界问题> 数组越界问题 # int main(int argc, char* argv[]){ int i = 0; int arr[3] = {0}; for(; i&amp;lt;=3; i++){ arr[i] = 0; printf(&amp;#34;hello world\n&amp;#34;); } return 0; } 疑问：这段代码的运行结果理论上是无限打印，实际上VS编译器中只打印了四次。
在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。根据我们前面讲的数组寻址公式，a[3]也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。</description></item></channel></rss>