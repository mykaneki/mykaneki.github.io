<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>数据结构 on mykaneki's blog</title><link>https://mykaneki.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><description>Recent content in 数据结构 on mykaneki's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 25 Feb 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://mykaneki.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.xml" rel="self" type="application/rss+xml"/><item><title>排序</title><link>https://mykaneki.github.io/posts/basicalgorithms/</link><pubDate>Sat, 25 Feb 2023 00:00:00 +0000</pubDate><guid>https://mykaneki.github.io/posts/basicalgorithms/</guid><description>快速排序> 快速排序 # 分治
算法步骤
确定分界点，x = q[(l+r)/2] 调整范围，使得左边&amp;lt;=x，右边&amp;gt;=x 递归处理两段 算法模板（双指针）
#include&amp;lt;iostream&amp;gt; using namespace std; const int N = 1e5+10; int n; int q[N]; void quick_sort(int q[], int l, int r) { // 只有一个数，不需要排序 if(l &amp;gt;= r) return; // x=[l] 不完全正确 // i和j在数组两侧，因为每次都是先移动再判断 int x = q[(l+r)/2], i = l - 1, j = r + 1; while(i &amp;lt; j) { while(q[++i]&amp;lt;x); while(q[--j]&amp;gt;x); if(i &amp;lt; j) swap(q[i],q[j]); } quick_sort(q,l,j); quick_sort(q,j+1,r); } int main() { scanf(&amp;#34;%d&amp;#34;,&amp;amp;n); for(int i = 0; i &amp;lt; n; i++) scanf(&amp;#34;%d&amp;#34;,&amp;amp;q[i]); quick_sort(q,0,n-1); for(int i = 0; i &amp;lt; n; i++) printf(&amp;#34;%d &amp;#34;,q[i]); return 0; } 归并排序> 归并排序 # 分治</description></item></channel></rss>